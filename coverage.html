
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>valkey-go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/valkey-io/valkey-go/binary.go (0.0%)</option>
				
				<option value="file1">github.com/valkey-io/valkey-go/bitmap.go (0.0%)</option>
				
				<option value="file2">github.com/valkey-io/valkey-go/cache.go (0.0%)</option>
				
				<option value="file3">github.com/valkey-io/valkey-go/client.go (6.0%)</option>
				
				<option value="file4">github.com/valkey-io/valkey-go/cluster.go (0.0%)</option>
				
				<option value="file5">github.com/valkey-io/valkey-go/helper.go (0.0%)</option>
				
				<option value="file6">github.com/valkey-io/valkey-go/lru.go (3.3%)</option>
				
				<option value="file7">github.com/valkey-io/valkey-go/lua.go (0.0%)</option>
				
				<option value="file8">github.com/valkey-io/valkey-go/message.go (6.9%)</option>
				
				<option value="file9">github.com/valkey-io/valkey-go/mux.go (28.1%)</option>
				
				<option value="file10">github.com/valkey-io/valkey-go/pipe.go (24.5%)</option>
				
				<option value="file11">github.com/valkey-io/valkey-go/pool.go (15.1%)</option>
				
				<option value="file12">github.com/valkey-io/valkey-go/pubsub.go (14.3%)</option>
				
				<option value="file13">github.com/valkey-io/valkey-go/resp.go (48.4%)</option>
				
				<option value="file14">github.com/valkey-io/valkey-go/retry.go (5.3%)</option>
				
				<option value="file15">github.com/valkey-io/valkey-go/ring.go (80.9%)</option>
				
				<option value="file16">github.com/valkey-io/valkey-go/sentinel.go (0.0%)</option>
				
				<option value="file17">github.com/valkey-io/valkey-go/singleflight.go (0.0%)</option>
				
				<option value="file18">github.com/valkey-io/valkey-go/standalone.go (28.2%)</option>
				
				<option value="file19">github.com/valkey-io/valkey-go/syncp.go (6.0%)</option>
				
				<option value="file20">github.com/valkey-io/valkey-go/url.go (0.0%)</option>
				
				<option value="file21">github.com/valkey-io/valkey-go/valkey.go (60.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package valkey

import (
        "encoding/binary"
        "encoding/json"
        "math"
        "unsafe"
)

// BinaryString convert the provided []byte into a string without a copy. It does what strings.Builder.String() does.
// Valkey Strings are binary safe; this means that it is safe to store any []byte into Valkey directly.
// Users can use this BinaryString helper to insert a []byte as the part of valkey command. For example:
//
//        client.B().Set().Key(valkey.BinaryString([]byte{0})).Value(valkey.BinaryString([]byte{0})).Build()
//
// To read back the []byte of the string returned from the Valkey, it is recommended to use the ValkeyMessage.AsReader.
func BinaryString(bs []byte) string <span class="cov0" title="0">{
        return unsafe.String(unsafe.SliceData(bs), len(bs))
}</span>

// VectorString32 convert the provided []float32 into a string. Users can use this to build vector search queries:
//
//        client.B().FtSearch().Index("idx").Query("*=&gt;[KNN 5 @vec $V]").
//            Params().Nargs(2).NameValue().NameValue("V", valkey.VectorString32([]float32{1})).
//            Dialect(2).Build()
func VectorString32(v []float32) string <span class="cov0" title="0">{
        b := make([]byte, len(v)*4)
        for i, e := range v </span><span class="cov0" title="0">{
                i := i * 4
                binary.LittleEndian.PutUint32(b[i:i+4], math.Float32bits(e))
        }</span>
        <span class="cov0" title="0">return BinaryString(b)</span>
}

// ToVector32 reverts VectorString32. User can use this to convert valkey response back to []float32.
func ToVector32(s string) []float32 <span class="cov0" title="0">{
        bs := unsafe.Slice(unsafe.StringData(s), len(s))
        vs := make([]float32, 0, len(bs)/4)
        for i := 0; i &lt; len(bs); i += 4 </span><span class="cov0" title="0">{
                vs = append(vs, math.Float32frombits(binary.LittleEndian.Uint32(bs[i:i+4])))
        }</span>
        <span class="cov0" title="0">return vs</span>
}

// VectorString64 convert the provided []float64 into a string. Users can use this to build vector search queries:
//
//        client.B().FtSearch().Index("idx").Query("*=&gt;[KNN 5 @vec $V]").
//            Params().Nargs(2).NameValue().NameValue("V", valkey.VectorString64([]float64{1})).
//            Dialect(2).Build()
func VectorString64(v []float64) string <span class="cov0" title="0">{
        b := make([]byte, len(v)*8)
        for i, e := range v </span><span class="cov0" title="0">{
                i := i * 8
                binary.LittleEndian.PutUint64(b[i:i+8], math.Float64bits(e))
        }</span>
        <span class="cov0" title="0">return BinaryString(b)</span>
}

// ToVector64 reverts VectorString64. User can use this to convert valkey response back to []float64.
func ToVector64(s string) []float64 <span class="cov0" title="0">{
        bs := unsafe.Slice(unsafe.StringData(s), len(s))
        vs := make([]float64, 0, len(bs)/8)
        for i := 0; i &lt; len(bs); i += 8 </span><span class="cov0" title="0">{
                vs = append(vs, math.Float64frombits(binary.LittleEndian.Uint64(bs[i:i+8])))
        }</span>
        <span class="cov0" title="0">return vs</span>
}

// JSON convert the provided parameter into a JSON string. Users can use this JSON helper to work with RedisJSON commands.
// For example:
//
//        client.B().JsonSet().Key("a").Path("$.myField").Value(valkey.JSON("str")).Build()
func JSON(in any) string <span class="cov0" title="0">{
        bs, err := json.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return BinaryString(bs)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package valkey

type bitmap struct {
        exts []uint64  // 24 bytes
        bits [3]uint64 // 24 bytes
}

func (b *bitmap) Init(n int) <span class="cov0" title="0">{
        if n &gt; 192 </span><span class="cov0" title="0">{
                b.exts = make([]uint64, (n-192+63)/64)
        }</span>
}

func (b *bitmap) Set(i int) <span class="cov0" title="0">{
        if i &lt; 192 </span><span class="cov0" title="0">{
                b.bits[i/64] |= 1 &lt;&lt; (i % 64)
        }</span> else<span class="cov0" title="0"> {
                b.exts[(i-192)/64] |= 1 &lt;&lt; (i % 64)
        }</span>
}

func (b *bitmap) Get(i int) bool <span class="cov0" title="0">{
        if i &lt; 192 </span><span class="cov0" title="0">{
                return b.bits[i/64]&amp;(1&lt;&lt;(i%64)) != 0
        }</span>
        <span class="cov0" title="0">return b.exts[(i-192)/64]&amp;(1&lt;&lt;(i%64)) != 0</span>
}

func (b *bitmap) Len() int <span class="cov0" title="0">{
        return len(b.exts)*64 + 192
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package valkey

import (
        "context"
        "sync"
        "time"
)

// NewCacheStoreFn can be provided in ClientOption for using a custom CacheStore implementation
type NewCacheStoreFn func(CacheStoreOption) CacheStore

// CacheStoreOption will be passed to NewCacheStoreFn
type CacheStoreOption struct {
        // CacheSizeEachConn is valkey client side cache size that bind to each TCP connection to a single valkey instance.
        // The default is DefaultCacheBytes.
        CacheSizeEachConn int
}

// CacheStore is the store interface for the client side caching
// More detailed interface requirement can be found in cache_test.go
type CacheStore interface {
        // Flight is called when DoCache and DoMultiCache, with the requested client side ttl and the current time.
        // It should look up the store in a single-flight manner and return one of the following three combinations:
        // Case 1: (empty ValkeyMessage, nil CacheEntry)     &lt;- when cache missed, and valkey will send the request to valkey.
        // Case 2: (empty ValkeyMessage, non-nil CacheEntry) &lt;- when cache missed, and valkey will use CacheEntry.Wait to wait for response.
        // Case 3: (non-empty ValkeyMessage, nil CacheEntry) &lt;- when cache hit
        Flight(key, cmd string, ttl time.Duration, now time.Time) (v ValkeyMessage, e CacheEntry)
        // Update is called when receiving the response of the request sent by the above Flight Case 1 from valkey.
        // It should not only update the store but also deliver the response to all CacheEntry.Wait and return a desired client side PXAT of the response.
        // Note that the server side expire time can be retrieved from ValkeyMessage.CachePXAT.
        Update(key, cmd string, val ValkeyMessage) (pxat int64)
        // Cancel is called when the request sent by the above Flight Case 1 failed.
        // It should not only deliver the error to all CacheEntry.Wait but also remove the CacheEntry from the store.
        Cancel(key, cmd string, err error)
        // Delete is called when receiving invalidation notifications from valkey.
        // If the keys are nil, then it should delete all non-pending cached entries under all keys.
        // If the keys are not nil, then it should delete all non-pending cached entries under those keys.
        Delete(keys []ValkeyMessage)
        // Close is called when the connection between valkey is broken.
        // It should flush all cached entries and deliver the error to all pending CacheEntry.Wait.
        Close(err error)
}

// CacheEntry should be used to wait for a single-flight response when cache missed.
type CacheEntry interface {
        Wait(ctx context.Context) (ValkeyMessage, error)
}

// SimpleCache is an alternative interface should be paired with NewSimpleCacheAdapter to construct a CacheStore
type SimpleCache interface {
        Get(key string) ValkeyMessage
        Set(key string, val ValkeyMessage)
        Del(key string)
        Flush()
}

// NewSimpleCacheAdapter converts a SimpleCache into CacheStore
func NewSimpleCacheAdapter(store SimpleCache) CacheStore <span class="cov0" title="0">{
        return &amp;adapter{store: store, flights: make(map[string]map[string]CacheEntry)}
}</span>

type adapter struct {
        store   SimpleCache
        flights map[string]map[string]CacheEntry
        mu      sync.RWMutex
}

func (a *adapter) Flight(key, cmd string, ttl time.Duration, now time.Time) (ValkeyMessage, CacheEntry) <span class="cov0" title="0">{
        a.mu.RLock()
        if v := a.store.Get(key + cmd); v.typ != 0 &amp;&amp; v.relativePTTL(now) &gt; 0 </span><span class="cov0" title="0">{
                a.mu.RUnlock()
                return v, nil
        }</span>
        <span class="cov0" title="0">flight := a.flights[key][cmd]
        a.mu.RUnlock()
        if flight != nil </span><span class="cov0" title="0">{
                return ValkeyMessage{}, flight
        }</span>
        <span class="cov0" title="0">a.mu.Lock()
        entries := a.flights[key]
        if entries == nil &amp;&amp; a.flights != nil </span><span class="cov0" title="0">{
                entries = make(map[string]CacheEntry, 1)
                a.flights[key] = entries
        }</span>
        <span class="cov0" title="0">if flight = entries[cmd]; flight == nil &amp;&amp; entries != nil </span><span class="cov0" title="0">{
                entries[cmd] = &amp;adapterEntry{ch: make(chan struct{}), xat: now.Add(ttl).UnixMilli()}
        }</span>
        <span class="cov0" title="0">a.mu.Unlock()
        return ValkeyMessage{}, flight</span>
}

func (a *adapter) Update(key, cmd string, val ValkeyMessage) (sxat int64) <span class="cov0" title="0">{
        a.mu.Lock()
        entries := a.flights[key]
        if flight, ok := entries[cmd].(*adapterEntry); ok </span><span class="cov0" title="0">{
                sxat = val.getExpireAt()
                if flight.xat &lt; sxat || sxat == 0 </span><span class="cov0" title="0">{
                        sxat = flight.xat
                        val.setExpireAt(sxat)
                }</span>
                <span class="cov0" title="0">a.store.Set(key+cmd, val)
                flight.set(val, nil)
                entries[cmd] = nil</span>
        }
        <span class="cov0" title="0">a.mu.Unlock()
        return</span>
}

func (a *adapter) Cancel(key, cmd string, err error) <span class="cov0" title="0">{
        a.mu.Lock()
        entries := a.flights[key]
        if flight, ok := entries[cmd].(*adapterEntry); ok </span><span class="cov0" title="0">{
                flight.set(ValkeyMessage{}, err)
                entries[cmd] = nil
        }</span>
        <span class="cov0" title="0">a.mu.Unlock()</span>
}

func (a *adapter) del(key string) <span class="cov0" title="0">{
        entries := a.flights[key]
        for cmd, e := range entries </span><span class="cov0" title="0">{
                if e == nil </span><span class="cov0" title="0">{
                        a.store.Del(key + cmd)
                        delete(entries, cmd)
                }</span>
        }
        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                delete(a.flights, key)
        }</span>
}

func (a *adapter) Delete(keys []ValkeyMessage) <span class="cov0" title="0">{
        a.mu.Lock()
        if keys == nil </span><span class="cov0" title="0">{
                for key := range a.flights </span><span class="cov0" title="0">{
                        a.del(key)
                }</span>
        } else<span class="cov0" title="0"> {
                for _, k := range keys </span><span class="cov0" title="0">{
                        a.del(k.string())
                }</span>
        }
        <span class="cov0" title="0">a.mu.Unlock()</span>
}

func (a *adapter) Close(err error) <span class="cov0" title="0">{
        a.mu.Lock()
        flights := a.flights
        a.flights = nil
        a.store.Flush()
        a.mu.Unlock()
        for _, entries := range flights </span><span class="cov0" title="0">{
                for _, e := range entries </span><span class="cov0" title="0">{
                        if e != nil </span><span class="cov0" title="0">{
                                e.(*adapterEntry).set(ValkeyMessage{}, err)
                        }</span>
                }
        }
}

type adapterEntry struct {
        err error
        ch  chan struct{}
        val ValkeyMessage
        xat int64
}

func (a *adapterEntry) set(val ValkeyMessage, err error) <span class="cov0" title="0">{
        a.err, a.val = err, val
        close(a.ch)
}</span>

func (a *adapterEntry) Wait(ctx context.Context) (ValkeyMessage, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ValkeyMessage{}, ctx.Err()</span>
        case &lt;-a.ch:<span class="cov0" title="0">
                return a.val, a.err</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package valkey

import (
        "context"
        "io"
        "sync/atomic"
        "time"

        "github.com/valkey-io/valkey-go/internal/cmds"
)

type singleClient struct {
        conn         conn
        retryHandler retryHandler
        stop         uint32
        cmd          Builder
        retry        bool
        hasLftm      bool
        DisableCache bool
}

func newSingleClient(opt *ClientOption, prev conn, connFn connFn, retryer retryHandler) (*singleClient, error) <span class="cov0" title="0">{
        if len(opt.InitAddress) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoAddr
        }</span>

        <span class="cov0" title="0">if opt.ReplicaOnly </span><span class="cov0" title="0">{
                return nil, ErrReplicaOnlyNotSupported
        }</span>

        <span class="cov0" title="0">conn := connFn(opt.InitAddress[0], opt)
        conn.Override(prev)
        err := conn.Dial()
        if err != nil </span><span class="cov0" title="0">{
                if !opt.ForceSingleClient </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        // return a singleClient instance even when Dial fails if ForceSingleClient is true.
        <span class="cov0" title="0">return newSingleClientWithConn(conn, cmds.NewBuilder(cmds.NoSlot), !opt.DisableRetry, opt.DisableCache, retryer, opt.ConnLifetime &gt; 0), err</span>
}

func newSingleClientWithConn(conn conn, builder Builder, retry, disableCache bool, retryer retryHandler, hasLftm bool) *singleClient <span class="cov8" title="1">{
        return &amp;singleClient{cmd: builder, conn: conn, retry: retry, retryHandler: retryer, hasLftm: hasLftm, DisableCache: disableCache}
}</span>

func (c *singleClient) B() Builder <span class="cov8" title="1">{
        return c.cmd
}</span>

func (c *singleClient) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov8" title="1">{
        attempts := 1
</span>retry:
        <span class="cov8" title="1">resp = c.conn.Do(ctx, cmd)
        if err := resp.Error(); err != nil </span><span class="cov8" title="1">{
                if err == errConnExpired </span><span class="cov0" title="0">{
                        goto retry</span>
                }
                <span class="cov8" title="1">if c.retry &amp;&amp; cmd.IsReadOnly() &amp;&amp; c.isRetryable(err, ctx) </span><span class="cov0" title="0">{
                        if c.retryHandler.WaitOrSkipRetry(ctx, attempts, cmd, err) </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov8" title="1">if resp.NonValkeyError() == nil </span><span class="cov8" title="1">{ // not recycle cmds if error, since cmds may be used later in the pipe.
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov8" title="1">return resp</span>
}

func (c *singleClient) DoStream(ctx context.Context, cmd Completed) ValkeyResultStream <span class="cov0" title="0">{
        s := c.conn.DoStream(ctx, cmd)
        cmds.PutCompleted(cmd)
        return s
}</span>

func (c *singleClient) DoMultiStream(ctx context.Context, multi ...Completed) MultiValkeyResultStream <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return ValkeyResultStream{e: io.EOF}
        }</span>
        <span class="cov0" title="0">s := c.conn.DoMultiStream(ctx, multi...)
        for _, cmd := range multi </span><span class="cov0" title="0">{
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (c *singleClient) DoMulti(ctx context.Context, multi ...Completed) (resps []ValkeyResult) <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">attempts := 1
</span>retry:
        <span class="cov0" title="0">resps = c.conn.DoMulti(ctx, multi...).s
        if c.hasLftm </span><span class="cov0" title="0">{
                var ml []Completed
        </span>recover:
                <span class="cov0" title="0">ml = ml[:0]
                var txIdx int // check transaction block, if zero, then not in transaction
                for i, resp := range resps </span><span class="cov0" title="0">{
                        if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                if txIdx &gt; 0 </span><span class="cov0" title="0">{
                                        ml = multi[txIdx:]
                                }</span> else<span class="cov0" title="0"> {
                                        ml = multi[i:]
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                        // if no error, then check if transaction block
                        <span class="cov0" title="0">if isMulti(multi[i]) </span><span class="cov0" title="0">{
                                txIdx = i
                        }</span> else<span class="cov0" title="0"> if isExec(multi[i]) </span><span class="cov0" title="0">{
                                txIdx = 0
                        }</span>
                }
                <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                        rs := c.conn.DoMulti(ctx, ml...).s
                        resps = append(resps[:len(resps)-len(rs)], rs...)
                        goto recover</span>
                }
        }
        <span class="cov0" title="0">if c.retry &amp;&amp; allReadOnly(multi) </span><span class="cov0" title="0">{
                for i, resp := range resps </span><span class="cov0" title="0">{
                        if c.isRetryable(resp.Error(), ctx) </span><span class="cov0" title="0">{
                                shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                        ctx, attempts, multi[i], resp.Error(),
                                )
                                if shouldRetry </span><span class="cov0" title="0">{
                                        attempts++
                                        goto retry</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                if resps[i].NonValkeyError() == nil </span><span class="cov0" title="0">{
                        cmds.PutCompleted(cmd)
                }</span>
        }
        <span class="cov0" title="0">return resps</span>
}

func (c *singleClient) DoMultiCache(ctx context.Context, multi ...CacheableTTL) (resps []ValkeyResult) <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">attempts := 1
</span>retry:
        <span class="cov0" title="0">resps = c.conn.DoMultiCache(ctx, multi...).s
        if c.hasLftm </span><span class="cov0" title="0">{
                var ml []CacheableTTL
        </span>recover:
                <span class="cov0" title="0">ml = ml[:0]
                for i, resp := range resps </span><span class="cov0" title="0">{
                        if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                ml = multi[i:]
                                break</span>
                        }
                }
                <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                        rs := c.conn.DoMultiCache(ctx, ml...).s
                        resps = append(resps[:len(resps)-len(rs)], rs...)
                        goto recover</span>
                }
        }
        <span class="cov0" title="0">if c.retry </span><span class="cov0" title="0">{
                for i, resp := range resps </span><span class="cov0" title="0">{
                        if c.isRetryable(resp.Error(), ctx) </span><span class="cov0" title="0">{
                                shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                        ctx, attempts, Completed(multi[i].Cmd), resp.Error(),
                                )
                                if shouldRetry </span><span class="cov0" title="0">{
                                        attempts++
                                        goto retry</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                if err := resps[i].NonValkeyError(); err == nil || err == ErrDoCacheAborted </span><span class="cov0" title="0">{
                        cmds.PutCacheable(cmd.Cmd)
                }</span>
        }
        <span class="cov0" title="0">return resps</span>
}

func (c *singleClient) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp ValkeyResult) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">resp = c.conn.DoCache(ctx, cmd, ttl)
        if err := resp.Error(); err != nil </span><span class="cov0" title="0">{
                if err == errConnExpired </span><span class="cov0" title="0">{
                        goto retry</span>
                }
                <span class="cov0" title="0">if c.retry &amp;&amp; c.isRetryable(err, ctx) </span><span class="cov0" title="0">{
                        if c.retryHandler.WaitOrSkipRetry(ctx, attempts, Completed(cmd), err) </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">if err := resp.NonValkeyError(); err == nil || err == ErrDoCacheAborted </span><span class="cov0" title="0">{
                cmds.PutCacheable(cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (c *singleClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">err = c.conn.Receive(ctx, subscribe, fn)
        if err == errConnExpired </span><span class="cov0" title="0">{
                goto retry</span>
        }
        <span class="cov0" title="0">if c.retry </span><span class="cov0" title="0">{
                if _, ok := err.(*ValkeyError); !ok &amp;&amp; c.isRetryable(err, ctx) </span><span class="cov0" title="0">{
                        shouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, subscribe, err)
                        if shouldRetry </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                cmds.PutCompleted(subscribe)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *singleClient) Dedicated(fn func(DedicatedClient) error) (err error) <span class="cov0" title="0">{
        wire := c.conn.Acquire(context.Background())
        dsc := &amp;dedicatedSingleClient{cmd: c.cmd, conn: c.conn, wire: wire, retry: c.retry, retryHandler: c.retryHandler}
        err = fn(dsc)
        dsc.release()
        return err
}</span>

func (c *singleClient) Dedicate() (DedicatedClient, func()) <span class="cov0" title="0">{
        wire := c.conn.Acquire(context.Background())
        dsc := &amp;dedicatedSingleClient{cmd: c.cmd, conn: c.conn, wire: wire, retry: c.retry, retryHandler: c.retryHandler}
        return dsc, dsc.release
}</span>

func (c *singleClient) Nodes() map[string]Client <span class="cov0" title="0">{
        return map[string]Client{c.conn.Addr(): c}
}</span>

func (c *singleClient) Mode() ClientMode <span class="cov0" title="0">{
        return ClientModeStandalone
}</span>

func (c *singleClient) Close() <span class="cov8" title="1">{
        atomic.StoreUint32(&amp;c.stop, 1)
        c.conn.Close()
}</span>

type dedicatedSingleClient struct {
        conn         conn
        wire         wire
        retryHandler retryHandler
        mark         uint32
        cmd          Builder
        retry        bool
}

func (c *dedicatedSingleClient) B() Builder <span class="cov0" title="0">{
        return c.cmd
}</span>

func (c *dedicatedSingleClient) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">if err := c.check(); err != nil </span><span class="cov0" title="0">{
                return newErrResult(err)
        }</span>
        <span class="cov0" title="0">resp = c.wire.Do(ctx, cmd)
        if c.retry &amp;&amp; cmd.IsReadOnly() &amp;&amp; isRetryable(resp.Error(), c.wire, ctx) </span><span class="cov0" title="0">{
                shouldRetry := c.retryHandler.WaitOrSkipRetry(
                        ctx, attempts, cmd, resp.Error(),
                )
                if shouldRetry </span><span class="cov0" title="0">{
                        attempts++
                        goto retry</span>
                }
        }
        <span class="cov0" title="0">if resp.NonValkeyError() == nil </span><span class="cov0" title="0">{
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (c *dedicatedSingleClient) DoMulti(ctx context.Context, multi ...Completed) (resp []ValkeyResult) <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">attempts := 1
        retryable := c.retry
        if retryable </span><span class="cov0" title="0">{
                retryable = allReadOnly(multi)
        }</span>
retry:
        <span class="cov0" title="0">if err := c.check(); err != nil </span><span class="cov0" title="0">{
                return fillErrs(len(multi), err)
        }</span>
        <span class="cov0" title="0">resp = c.wire.DoMulti(ctx, multi...).s
        for i, cmd := range multi </span><span class="cov0" title="0">{
                if retryable &amp;&amp; isRetryable(resp[i].Error(), c.wire, ctx) </span><span class="cov0" title="0">{
                        shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                ctx, attempts, multi[i], resp[i].Error(),
                        )
                        if shouldRetry </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
                <span class="cov0" title="0">if resp[i].NonValkeyError() == nil </span><span class="cov0" title="0">{
                        cmds.PutCompleted(cmd)
                }</span>
        }
        <span class="cov0" title="0">return resp</span>
}

func (c *dedicatedSingleClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">if err := c.check(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = c.wire.Receive(ctx, subscribe, fn)
        if c.retry </span><span class="cov0" title="0">{
                if _, ok := err.(*ValkeyError); !ok &amp;&amp; isRetryable(err, c.wire, ctx) </span><span class="cov0" title="0">{
                        shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                ctx, attempts, subscribe, err,
                        )
                        if shouldRetry </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                cmds.PutCompleted(subscribe)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *dedicatedSingleClient) SetPubSubHooks(hooks PubSubHooks) &lt;-chan error <span class="cov0" title="0">{
        if err := c.check(); err != nil </span><span class="cov0" title="0">{
                ch := make(chan error, 1)
                ch &lt;- err
                return ch
        }</span>
        <span class="cov0" title="0">return c.wire.SetPubSubHooks(hooks)</span>
}

func (c *dedicatedSingleClient) Close() <span class="cov0" title="0">{
        c.wire.Close()
        c.release()
}</span>

func (c *dedicatedSingleClient) check() error <span class="cov0" title="0">{
        if atomic.LoadUint32(&amp;c.mark) != 0 </span><span class="cov0" title="0">{
                return ErrDedicatedClientRecycled
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *dedicatedSingleClient) release() <span class="cov0" title="0">{
        if atomic.CompareAndSwapUint32(&amp;c.mark, 0, 1) </span><span class="cov0" title="0">{
                c.conn.Store(c.wire)
        }</span>
}

func (c *singleClient) isRetryable(err error, ctx context.Context) bool <span class="cov0" title="0">{
        if err == nil || err == Nil || err == ErrDoCacheAborted || atomic.LoadUint32(&amp;c.stop) != 0 || ctx.Err() != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                return err.IsLoading()
        }</span>
        <span class="cov0" title="0">return true</span>
}

func isRetryable(err error, w wire, ctx context.Context) bool <span class="cov0" title="0">{
        if err == nil || err == Nil || w.Error() != nil || ctx.Err() != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                return err.IsLoading()
        }</span>
        <span class="cov0" title="0">return true</span>
}

func allReadOnly(multi []Completed) bool <span class="cov0" title="0">{
        for _, cmd := range multi </span><span class="cov0" title="0">{
                if cmd.IsWrite() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func chooseSlot(multi []Completed) uint16 <span class="cov0" title="0">{
        for i := 0; i &lt; len(multi); i++ </span><span class="cov0" title="0">{
                if multi[i].Slot() != cmds.InitSlot </span><span class="cov0" title="0">{
                        for j := i + 1; j &lt; len(multi); j++ </span><span class="cov0" title="0">{
                                if multi[j].Slot() != cmds.InitSlot &amp;&amp; multi[j].Slot() != multi[i].Slot() </span><span class="cov0" title="0">{
                                        return cmds.NoSlot
                                }</span>
                        }
                        <span class="cov0" title="0">return multi[i].Slot()</span>
                }
        }
        <span class="cov0" title="0">return cmds.InitSlot</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package valkey

import (
        "context"
        "errors"
        "io"
        "net"
        "strconv"
        "sync"
        "sync/atomic"
        "time"

        "github.com/valkey-io/valkey-go/internal/cmds"
        "github.com/valkey-io/valkey-go/internal/util"
)

// ErrNoSlot indicates that there is no valkey node owning the key slot.
var ErrNoSlot = errors.New("the slot has no valkey node")
var ErrReplicaOnlyConflict = errors.New("ReplicaOnly conflicts with SendToReplicas option")
var ErrInvalidShardsRefreshInterval = errors.New("ShardsRefreshInterval must be greater than or equal to 0")
var ErrReplicaOnlyConflictWithReplicaSelector = errors.New("ReplicaOnly conflicts with ReplicaSelector option")
var ErrSendToReplicasNotSet = errors.New("SendToReplicas must be set when ReplicaSelector is set")

type clusterClient struct {
        pslots       [16384]conn
        retryHandler retryHandler
        opt          *ClientOption
        rOpt         *ClientOption
        conns        map[string]connrole
        connFn       connFn
        stopCh       chan struct{}
        sc           call
        rslots       []conn
        mu           sync.RWMutex
        stop         uint32
        cmd          Builder
        retry        bool
        hasLftm      bool
}

// NOTE: connrole and conn must be initialized at the same time
type connrole struct {
        conn   conn
        hidden bool
        //replica bool &lt;- this field is removed because a server may have mixed roles at the same time in the future. https://github.com/valkey-io/valkey/issues/1372
}

var replicaOnlySelector = func(_ uint16, replicas []ReplicaInfo) int <span class="cov0" title="0">{
        return util.FastRand(len(replicas))
}</span>

func newClusterClient(opt *ClientOption, connFn connFn, retryer retryHandler) (*clusterClient, error) <span class="cov0" title="0">{
        client := &amp;clusterClient{
                cmd:          cmds.NewBuilder(cmds.InitSlot),
                connFn:       connFn,
                opt:          opt,
                conns:        make(map[string]connrole),
                retry:        !opt.DisableRetry,
                retryHandler: retryer,
                stopCh:       make(chan struct{}),
                hasLftm:      opt.ConnLifetime &gt; 0,
        }

        if opt.ReplicaOnly &amp;&amp; opt.SendToReplicas != nil </span><span class="cov0" title="0">{
                return nil, ErrReplicaOnlyConflict
        }</span>
        <span class="cov0" title="0">if opt.ReplicaOnly &amp;&amp; opt.ReplicaSelector != nil </span><span class="cov0" title="0">{
                return nil, ErrReplicaOnlyConflictWithReplicaSelector
        }</span>
        <span class="cov0" title="0">if opt.ReplicaSelector != nil &amp;&amp; opt.SendToReplicas == nil </span><span class="cov0" title="0">{
                return nil, ErrSendToReplicasNotSet
        }</span>

        <span class="cov0" title="0">if opt.SendToReplicas != nil &amp;&amp; opt.ReplicaSelector == nil </span><span class="cov0" title="0">{
                opt.ReplicaSelector = replicaOnlySelector
        }</span>

        <span class="cov0" title="0">if opt.SendToReplicas != nil </span><span class="cov0" title="0">{
                rOpt := *opt
                rOpt.ReplicaOnly = true
                client.rOpt = &amp;rOpt
        }</span>

        <span class="cov0" title="0">client.connFn = func(dst string, opt *ClientOption) conn </span><span class="cov0" title="0">{
                cc := connFn(dst, opt)
                cc.SetOnCloseHook(func(err error) </span><span class="cov0" title="0">{
                        client.lazyRefresh()
                }</span>)
                <span class="cov0" title="0">return cc</span>
        }

        <span class="cov0" title="0">if err := client.init(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := client.refresh(context.Background()); err != nil </span><span class="cov0" title="0">{
                return client, err
        }</span>

        <span class="cov0" title="0">if opt.ClusterOption.ShardsRefreshInterval &gt; 0 </span><span class="cov0" title="0">{
                go client.runClusterTopologyRefreshment()
        }</span> else<span class="cov0" title="0"> if opt.ClusterOption.ShardsRefreshInterval &lt; 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidShardsRefreshInterval
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func (c *clusterClient) init() error <span class="cov0" title="0">{
        if len(c.opt.InitAddress) == 0 </span><span class="cov0" title="0">{
                return ErrNoAddr
        }</span>
        <span class="cov0" title="0">results := make(chan error, len(c.opt.InitAddress))
        for _, addr := range c.opt.InitAddress </span><span class="cov0" title="0">{
                cc := c.connFn(addr, c.opt)
                go func(addr string, cc conn) </span><span class="cov0" title="0">{
                        if err := cc.Dial(); err == nil </span><span class="cov0" title="0">{
                                c.mu.Lock()
                                if _, ok := c.conns[addr]; ok </span><span class="cov0" title="0">{
                                        go cc.Close() // abort the new connection instead of closing the old one, which may already been used
                                }</span> else<span class="cov0" title="0"> {
                                        c.conns[addr] = connrole{
                                                conn: cc,
                                        }
                                }</span>
                                <span class="cov0" title="0">c.mu.Unlock()
                                results &lt;- nil</span>
                        } else<span class="cov0" title="0"> {
                                results &lt;- err
                        }</span>
                }(addr, cc)
        }
        <span class="cov0" title="0">es := make([]error, cap(results))
        for i := 0; i &lt; cap(results); i++ </span><span class="cov0" title="0">{
                if err := &lt;-results; err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> {
                        es[i] = err
                }</span>
        }
        <span class="cov0" title="0">return es[0]</span>
}

func (c *clusterClient) refresh(ctx context.Context) (err error) <span class="cov0" title="0">{
        return c.sc.Do(ctx, c._refresh)
}</span>

func (c *clusterClient) lazyRefresh() <span class="cov0" title="0">{
        c.sc.LazyDo(time.Second, c._refresh)
}</span>

type clusterslots struct {
        addr  string
        reply ValkeyResult
        ver   int
}

func (s clusterslots) parse(tls bool) map[string]group <span class="cov0" title="0">{
        if s.ver &lt; 8 </span><span class="cov0" title="0">{
                return parseSlots(s.reply.val, s.addr)
        }</span>
        <span class="cov0" title="0">return parseShards(s.reply.val, s.addr, tls)</span>
}

func getClusterSlots(c conn, timeout time.Duration) clusterslots <span class="cov0" title="0">{
        var ctx context.Context
        var cancel context.CancelFunc
        if timeout &gt; 0 </span><span class="cov0" title="0">{
                ctx, cancel = context.WithTimeout(context.Background(), timeout)
                defer cancel()
        }</span> else<span class="cov0" title="0"> {
                ctx = context.Background()
        }</span>
        <span class="cov0" title="0">v := c.Version()
        if v &lt; 8 </span><span class="cov0" title="0">{
                return clusterslots{reply: c.Do(ctx, cmds.SlotCmd), addr: c.Addr(), ver: v}
        }</span>
        <span class="cov0" title="0">return clusterslots{reply: c.Do(ctx, cmds.ShardsCmd), addr: c.Addr(), ver: v}</span>
}

func (c *clusterClient) _refresh() (err error) <span class="cov0" title="0">{
        c.mu.RLock()
        results := make(chan clusterslots, len(c.conns))
        pending := make([]conn, 0, len(c.conns))
        for _, cc := range c.conns </span><span class="cov0" title="0">{
                pending = append(pending, cc.conn)
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()

        var result clusterslots
        for i := 0; i &lt; cap(results); i++ </span><span class="cov0" title="0">{
                if i&amp;3 == 0 </span><span class="cov0" title="0">{ // batch CLUSTER SLOTS/CLUSTER SHARDS for every 4 connections
                        for j := i; j &lt; i+4 &amp;&amp; j &lt; len(pending); j++ </span><span class="cov0" title="0">{
                                go func(c conn, timeout time.Duration) </span><span class="cov0" title="0">{
                                        results &lt;- getClusterSlots(c, timeout)
                                }</span>(pending[j], c.opt.ConnWriteTimeout)
                        }
                }
                <span class="cov0" title="0">result = &lt;-results
                err = result.reply.Error()
                if len(result.reply.val.values()) != 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">pending = nil

        groups := result.parse(c.opt.TLSConfig != nil)
        conns := make(map[string]connrole, len(groups))
        for master, g := range groups </span><span class="cov0" title="0">{
                conns[master] = connrole{conn: c.connFn(master, c.opt)}
                if c.rOpt != nil </span><span class="cov0" title="0">{
                        for _, nodeInfo := range g.nodes[1:] </span><span class="cov0" title="0">{
                                conns[nodeInfo.Addr] = connrole{conn: c.connFn(nodeInfo.Addr, c.rOpt)}
                        }</span>
                } else<span class="cov0" title="0"> {
                        for _, nodeInfo := range g.nodes[1:] </span><span class="cov0" title="0">{
                                conns[nodeInfo.Addr] = connrole{conn: c.connFn(nodeInfo.Addr, c.opt)}
                        }</span>
                }
        }
        // make sure InitAddress always be present
        <span class="cov0" title="0">for _, addr := range c.opt.InitAddress </span><span class="cov0" title="0">{
                if _, ok := conns[addr]; !ok </span><span class="cov0" title="0">{
                        conns[addr] = connrole{
                                conn:   c.connFn(addr, c.opt),
                                hidden: true,
                        }
                }</span>
        }

        <span class="cov0" title="0">var removes []conn

        c.mu.RLock()
        for addr, cc := range c.conns </span><span class="cov0" title="0">{
                if fresh, ok := conns[addr]; ok </span><span class="cov0" title="0">{
                        fresh.conn = cc.conn
                        conns[addr] = fresh
                }</span> else<span class="cov0" title="0"> {
                        removes = append(removes, cc.conn)
                }</span>
        }
        <span class="cov0" title="0">c.mu.RUnlock()

        pslots := [16384]conn{}
        var rslots []conn
        for master, g := range groups </span><span class="cov0" title="0">{
                switch </span>{
                case c.opt.ReplicaOnly &amp;&amp; len(g.nodes) &gt; 1:<span class="cov0" title="0">
                        nodesCount := len(g.nodes)
                        for _, slot := range g.slots </span><span class="cov0" title="0">{
                                for i := slot[0]; i &lt;= slot[1] &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; 16384; i++ </span><span class="cov0" title="0">{
                                        pslots[i] = conns[g.nodes[1+util.FastRand(nodesCount-1)].Addr].conn
                                }</span>
                        }
                case c.rOpt != nil:<span class="cov0" title="0">
                        if len(rslots) == 0 </span><span class="cov0" title="0">{ // lazy init
                                rslots = make([]conn, 16384)
                        }</span>
                        <span class="cov0" title="0">if len(g.nodes) &gt; 1 </span><span class="cov0" title="0">{
                                n := len(g.nodes) - 1

                                if c.opt.EnableReplicaAZInfo </span><span class="cov0" title="0">{
                                        var wg sync.WaitGroup
                                        for i := 1; i &lt;= n; i += 4 </span><span class="cov0" title="0">{ // batch AZ() for every 4 connections
                                                for j := i; j &lt;= i+4 &amp;&amp; j &lt;= n; j++ </span><span class="cov0" title="0">{
                                                        wg.Add(1)
                                                        go func(wg *sync.WaitGroup, conn conn, info *ReplicaInfo) </span><span class="cov0" title="0">{
                                                                info.AZ = conn.AZ()
                                                                wg.Done()
                                                        }</span>(&amp;wg, conns[g.nodes[j].Addr].conn, &amp;g.nodes[j])
                                                }
                                                <span class="cov0" title="0">wg.Wait()</span>
                                        }
                                }

                                <span class="cov0" title="0">for _, slot := range g.slots </span><span class="cov0" title="0">{
                                        for i := slot[0]; i &lt;= slot[1] &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; 16384; i++ </span><span class="cov0" title="0">{
                                                pslots[i] = conns[master].conn
                                                rIndex := c.opt.ReplicaSelector(uint16(i), g.nodes[1:])
                                                if rIndex &gt;= 0 &amp;&amp; rIndex &lt; n </span><span class="cov0" title="0">{
                                                        rslots[i] = conns[g.nodes[1+rIndex].Addr].conn
                                                }</span> else<span class="cov0" title="0"> {
                                                        rslots[i] = conns[master].conn
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                for _, slot := range g.slots </span><span class="cov0" title="0">{
                                        for i := slot[0]; i &lt;= slot[1] &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; 16384; i++ </span><span class="cov0" title="0">{
                                                pslots[i] = conns[master].conn
                                                rslots[i] = conns[master].conn
                                        }</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        for _, slot := range g.slots </span><span class="cov0" title="0">{
                                for i := slot[0]; i &lt;= slot[1] &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; 16384; i++ </span><span class="cov0" title="0">{
                                        pslots[i] = conns[master].conn
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">c.mu.Lock()
        c.pslots = pslots
        c.rslots = rslots
        c.conns = conns
        c.mu.Unlock()

        if len(removes) &gt; 0 </span><span class="cov0" title="0">{
                go func(removes []conn) </span><span class="cov0" title="0">{
                        time.Sleep(time.Second * 5)
                        for _, cc := range removes </span><span class="cov0" title="0">{
                                cc.Close()
                        }</span>
                }(removes)
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *clusterClient) single() (conn conn) <span class="cov0" title="0">{
        return c._pick(cmds.InitSlot, false)
}</span>

func (c *clusterClient) nodes() []string <span class="cov0" title="0">{
        c.mu.RLock()
        nodes := make([]string, 0, len(c.conns))
        for addr := range c.conns </span><span class="cov0" title="0">{
                nodes = append(nodes, addr)
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()
        return nodes</span>
}

type nodes []ReplicaInfo

type group struct {
        nodes nodes
        slots [][2]int64
}

func parseEndpoint(fallback, endpoint string, port int64) string <span class="cov0" title="0">{
        switch endpoint </span>{
        case "":<span class="cov0" title="0">
                endpoint, _, _ = net.SplitHostPort(fallback)</span>
        case "?":<span class="cov0" title="0">
                return ""</span>
        }
        <span class="cov0" title="0">return net.JoinHostPort(endpoint, strconv.FormatInt(port, 10))</span>
}

// parseSlots - map valkey slots for each valkey nodes/addresses
// defaultAddr is needed in case the node does not know its own IP
func parseSlots(slots ValkeyMessage, defaultAddr string) map[string]group <span class="cov0" title="0">{
        groups := make(map[string]group, len(slots.values()))
        for _, v := range slots.values() </span><span class="cov0" title="0">{
                master := parseEndpoint(defaultAddr, v.values()[2].values()[0].string(), v.values()[2].values()[1].intlen)
                if master == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">g, ok := groups[master]
                if !ok </span><span class="cov0" title="0">{
                        g.slots = make([][2]int64, 0)
                        g.nodes = make(nodes, 0, len(v.values())-2)
                        for i := 2; i &lt; len(v.values()); i++ </span><span class="cov0" title="0">{
                                if dst := parseEndpoint(defaultAddr, v.values()[i].values()[0].string(), v.values()[i].values()[1].intlen); dst != "" </span><span class="cov0" title="0">{
                                        g.nodes = append(g.nodes, ReplicaInfo{Addr: dst})
                                }</span>
                        }
                }
                <span class="cov0" title="0">g.slots = append(g.slots, [2]int64{v.values()[0].intlen, v.values()[1].intlen})
                groups[master] = g</span>
        }
        <span class="cov0" title="0">return groups</span>
}

// parseShards - map valkey shards for each valkey nodes/addresses
// defaultAddr is needed in case the node does not know its own IP
func parseShards(shards ValkeyMessage, defaultAddr string, tls bool) map[string]group <span class="cov0" title="0">{
        groups := make(map[string]group, len(shards.values()))
        for _, v := range shards.values() </span><span class="cov0" title="0">{
                m := -1
                shard, _ := v.AsMap()
                shardSlots := shard["slots"]
                shardNodes := shard["nodes"]
                slots := shardSlots.values()
                _nodes := shardNodes.values()
                g := group{
                        nodes: make(nodes, 0, len(_nodes)),
                        slots: make([][2]int64, len(slots)/2),
                }
                for i := range g.slots </span><span class="cov0" title="0">{
                        g.slots[i][0], _ = slots[i*2].AsInt64()
                        g.slots[i][1], _ = slots[i*2+1].AsInt64()
                }</span>
                <span class="cov0" title="0">for _, n := range _nodes </span><span class="cov0" title="0">{
                        dict, _ := n.AsMap()
                        if dictHealth := dict["health"]; dictHealth.string() != "online" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">port := dict["port"].intlen
                        if tls &amp;&amp; dict["tls-port"].intlen &gt; 0 </span><span class="cov0" title="0">{
                                port = dict["tls-port"].intlen
                        }</span>
                        <span class="cov0" title="0">dictEndpoint := dict["endpoint"]
                        if dst := parseEndpoint(defaultAddr, dictEndpoint.string(), port); dst != "" </span><span class="cov0" title="0">{
                                if dictRole := dict["role"]; dictRole.string() == "master" </span><span class="cov0" title="0">{
                                        m = len(g.nodes)
                                }</span>
                                <span class="cov0" title="0">g.nodes = append(g.nodes, ReplicaInfo{Addr: dst})</span>
                        }
                }
                <span class="cov0" title="0">if m &gt;= 0 </span><span class="cov0" title="0">{
                        g.nodes[0], g.nodes[m] = g.nodes[m], g.nodes[0]
                        groups[g.nodes[0].Addr] = g
                }</span>
        }
        <span class="cov0" title="0">return groups</span>
}

func (c *clusterClient) runClusterTopologyRefreshment() <span class="cov0" title="0">{
        ticker := time.NewTicker(c.opt.ClusterOption.ShardsRefreshInterval)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.lazyRefresh()</span>
                }
        }
}

func (c *clusterClient) _pick(slot uint16, toReplica bool) (p conn) <span class="cov0" title="0">{
        c.mu.RLock()
        if slot == cmds.InitSlot </span><span class="cov0" title="0">{
                for _, cc := range c.conns </span><span class="cov0" title="0">{
                        p = cc.conn
                        break</span>
                }
        } else<span class="cov0" title="0"> if toReplica &amp;&amp; c.rslots != nil </span><span class="cov0" title="0">{
                p = c.rslots[slot]
        }</span> else<span class="cov0" title="0"> {
                p = c.pslots[slot]
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()
        return p</span>
}

func (c *clusterClient) pick(ctx context.Context, slot uint16, toReplica bool) (p conn, err error) <span class="cov0" title="0">{
        if p = c._pick(slot, toReplica); p == nil </span><span class="cov0" title="0">{
                if err := c.refresh(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if p = c._pick(slot, toReplica); p == nil </span><span class="cov0" title="0">{
                        return nil, ErrNoSlot
                }</span>
        }
        <span class="cov0" title="0">return p, nil</span>
}

func (c *clusterClient) redirectOrNew(addr string, prev conn, slot uint16, mode RedirectMode) conn <span class="cov0" title="0">{
        c.mu.RLock()
        cc := c.conns[addr]
        c.mu.RUnlock()
        if cc.conn != nil &amp;&amp; prev != cc.conn </span><span class="cov0" title="0">{
                return cc.conn
        }</span>
        <span class="cov0" title="0">c.mu.Lock()
        if cc = c.conns[addr]; cc.conn == nil </span><span class="cov0" title="0">{
                p := c.connFn(addr, c.opt)
                cc = connrole{conn: p}
                c.conns[addr] = cc
                if mode == RedirectMove </span><span class="cov0" title="0">{
                        c.pslots[slot] = p
                }</span>
        } else<span class="cov0" title="0"> if prev == cc.conn </span><span class="cov0" title="0">{
                // try reconnection if the MOVED redirects to the same host,
                // because the same hostname may actually be resolved into another destination
                // depending on the fail-over implementation. ex: AWS MemoryDB's resize process.
                go func(prev conn) </span><span class="cov0" title="0">{
                        time.Sleep(time.Second * 5)
                        prev.Close()
                }</span>(prev)
                <span class="cov0" title="0">p := c.connFn(addr, c.opt)
                cc = connrole{conn: p}
                c.conns[addr] = cc
                if mode == RedirectMove </span><span class="cov0" title="0">{ // MOVED should always point to the primary.
                        c.pslots[slot] = p
                }</span>
        }
        <span class="cov0" title="0">c.mu.Unlock()
        return cc.conn</span>
}

func (c *clusterClient) B() Builder <span class="cov0" title="0">{
        return c.cmd
}</span>

func (c *clusterClient) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        if resp = c.do(ctx, cmd); resp.NonValkeyError() == nil </span><span class="cov0" title="0">{ // not recycle cmds if error, since cmds may be used later in the pipe.
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (c *clusterClient) do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">cc, err := c.pick(ctx, cmd.Slot(), c.toReplica(cmd))
        if err != nil </span><span class="cov0" title="0">{
                return newErrResult(err)
        }</span>
        <span class="cov0" title="0">resp = cc.Do(ctx, cmd)
        if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                goto retry</span>
        }
<span class="cov0" title="0">process:
        switch addr, mode := c.shouldRefreshRetry(resp.Error(), ctx); mode </span>{
        case RedirectMove:<span class="cov0" title="0">
                ncc := c.redirectOrNew(addr, cc, cmd.Slot(), mode)
        </span>recover1:
                <span class="cov0" title="0">resp = ncc.Do(ctx, cmd)
                if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                        goto recover1</span>
                }
                <span class="cov0" title="0">goto process</span>
        case RedirectAsk:<span class="cov0" title="0">
                ncc := c.redirectOrNew(addr, cc, cmd.Slot(), mode)
        </span>recover2:
                <span class="cov0" title="0">results := ncc.DoMulti(ctx, cmds.AskingCmd, cmd)
                resp = results.s[1]
                if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                        goto recover2</span>
                }
                <span class="cov0" title="0">resultsp.Put(results)
                goto process</span>
        case RedirectRetry:<span class="cov0" title="0">
                if c.retry &amp;&amp; cmd.IsReadOnly() </span><span class="cov0" title="0">{
                        shouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, cmd, resp.Error())
                        if shouldRetry </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">return resp</span>
}

func (c *clusterClient) toReplica(cmd Completed) bool <span class="cov0" title="0">{
        if c.opt.SendToReplicas != nil </span><span class="cov0" title="0">{
                return c.opt.SendToReplicas(cmd)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (c *clusterClient) _pickMulti(multi []Completed) (retries *connretry, init bool) <span class="cov0" title="0">{
        last := cmds.InitSlot

        for _, cmd := range multi </span><span class="cov0" title="0">{
                if cmd.Slot() == cmds.InitSlot </span><span class="cov0" title="0">{
                        init = true
                        break</span>
                }
        }

        <span class="cov0" title="0">c.mu.RLock()
        defer c.mu.RUnlock()

        count := conncountp.Get(len(c.conns), len(c.conns))

        if !init &amp;&amp; c.rslots != nil &amp;&amp; c.opt.SendToReplicas != nil </span><span class="cov0" title="0">{
                var bm bitmap
                bm.Init(len(multi))
                for i, cmd := range multi </span><span class="cov0" title="0">{
                        var cc conn
                        if c.opt.SendToReplicas(cmd) </span><span class="cov0" title="0">{
                                bm.Set(i)
                                cc = c.rslots[cmd.Slot()]
                        }</span> else<span class="cov0" title="0"> {
                                cc = c.pslots[cmd.Slot()]
                        }</span>
                        <span class="cov0" title="0">if cc == nil </span><span class="cov0" title="0">{
                                return nil, false
                        }</span>
                        <span class="cov0" title="0">count.m[cc]++</span>
                }

                <span class="cov0" title="0">retries = connretryp.Get(len(count.m), len(count.m))
                for cc, n := range count.m </span><span class="cov0" title="0">{
                        retries.m[cc] = retryp.Get(0, n)
                }</span>
                <span class="cov0" title="0">conncountp.Put(count)

                for i, cmd := range multi </span><span class="cov0" title="0">{
                        var cc conn
                        if bm.Get(i) </span><span class="cov0" title="0">{
                                cc = c.rslots[cmd.Slot()]
                        }</span> else<span class="cov0" title="0"> {
                                cc = c.pslots[cmd.Slot()]
                        }</span>
                        <span class="cov0" title="0">re := retries.m[cc]
                        re.commands = append(re.commands, cmd)
                        re.cIndexes = append(re.cIndexes, i)</span>
                }
                <span class="cov0" title="0">return retries, init</span>
        }

        <span class="cov0" title="0">inits := 0
        for _, cmd := range multi </span><span class="cov0" title="0">{
                if cmd.Slot() == cmds.InitSlot </span><span class="cov0" title="0">{
                        inits++
                        continue</span>
                }
                <span class="cov0" title="0">if last == cmds.InitSlot </span><span class="cov0" title="0">{
                        last = cmd.Slot()
                }</span> else<span class="cov0" title="0"> if init &amp;&amp; last != cmd.Slot() </span><span class="cov0" title="0">{
                        panic(panicMixCxSlot)</span>
                }
                <span class="cov0" title="0">cc := c.pslots[cmd.Slot()]
                if cc == nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
                <span class="cov0" title="0">count.m[cc]++</span>
        }

        <span class="cov0" title="0">if last == cmds.InitSlot </span><span class="cov0" title="0">{
                // if all commands have no slots, such as INFO, we pick a non-nil slot.
                for i, cc := range c.pslots </span><span class="cov0" title="0">{
                        if cc != nil </span><span class="cov0" title="0">{
                                last = uint16(i)
                                count.m[cc] = inits
                                break</span>
                        }
                }
                <span class="cov0" title="0">if last == cmds.InitSlot </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
        } else<span class="cov0" title="0"> if init </span><span class="cov0" title="0">{
                cc := c.pslots[last]
                count.m[cc] += inits
        }</span>

        <span class="cov0" title="0">retries = connretryp.Get(len(count.m), len(count.m))
        for cc, n := range count.m </span><span class="cov0" title="0">{
                retries.m[cc] = retryp.Get(0, n)
        }</span>
        <span class="cov0" title="0">conncountp.Put(count)

        for i, cmd := range multi </span><span class="cov0" title="0">{
                var cc conn
                if cmd.Slot() != cmds.InitSlot </span><span class="cov0" title="0">{
                        cc = c.pslots[cmd.Slot()]
                }</span> else<span class="cov0" title="0"> {
                        cc = c.pslots[last]
                }</span>
                <span class="cov0" title="0">re := retries.m[cc]
                re.commands = append(re.commands, cmd)
                re.cIndexes = append(re.cIndexes, i)</span>
        }
        <span class="cov0" title="0">return retries, init</span>
}

func (c *clusterClient) pickMulti(ctx context.Context, multi []Completed) (*connretry, bool, error) <span class="cov0" title="0">{
        conns, hasInit := c._pickMulti(multi)
        if conns == nil </span><span class="cov0" title="0">{
                if err := c.refresh(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>
                <span class="cov0" title="0">if conns, hasInit = c._pickMulti(multi); conns == nil </span><span class="cov0" title="0">{
                        return nil, false, ErrNoSlot
                }</span>
        }
        <span class="cov0" title="0">return conns, hasInit, nil</span>
}

func isMulti(cmd Completed) bool <span class="cov0" title="0">{
        return len(cmd.Commands()) == 1 &amp;&amp; cmd.Commands()[0] == "MULTI"
}</span>
func isExec(cmd Completed) bool <span class="cov0" title="0">{
        return len(cmd.Commands()) == 1 &amp;&amp; cmd.Commands()[0] == "EXEC"
}</span>

func (c *clusterClient) doresultfn(
        ctx context.Context, results *valkeyresults, retries *connretry, mu *sync.Mutex, cc conn, cIndexes []int, commands []Completed, resps []ValkeyResult, attempts int, hasInit bool,
) (clean bool) <span class="cov0" title="0">{
        mi := -1
        ei := -1
        clean = true
        for i, resp := range resps </span><span class="cov0" title="0">{
                clean = clean &amp;&amp; resp.NonValkeyError() == nil
                ii := cIndexes[i]
                cm := commands[i]
                results.s[ii] = resp
                addr, mode := c.shouldRefreshRetry(resp.Error(), ctx)
                if mode != RedirectNone </span><span class="cov0" title="0">{
                        nc := cc
                        retryDelay := time.Duration(-1)
                        if mode == RedirectRetry </span><span class="cov0" title="0">{
                                if !c.retry || !cm.IsReadOnly() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">retryDelay = c.retryHandler.RetryDelay(attempts, cm, resp.Error())</span>
                        } else<span class="cov0" title="0"> {
                                nc = c.redirectOrNew(addr, cc, cm.Slot(), mode)
                        }</span>
                        <span class="cov0" title="0">if hasInit &amp;&amp; ei &lt; i </span><span class="cov0" title="0">{ // find out if there is a transaction block or not.
                                for mi = i; mi &gt;= 0 &amp;&amp; !isMulti(commands[mi]) &amp;&amp; !isExec(commands[mi]); mi-- </span>{<span class="cov0" title="0">
                                }</span>
                                <span class="cov0" title="0">for ei = i; ei &lt; len(commands) &amp;&amp; !isMulti(commands[ei]) &amp;&amp; !isExec(commands[ei]); ei++ </span>{<span class="cov0" title="0">
                                }</span>
                                <span class="cov0" title="0">if mi &gt;= 0 &amp;&amp; ei &lt; len(commands) &amp;&amp; isMulti(commands[mi]) &amp;&amp; isExec(commands[ei]) &amp;&amp; resps[mi].val.string() == ok </span><span class="cov0" title="0">{ // a transaction is found.
                                        mu.Lock()
                                        retries.Redirects++
                                        nr := retries.m[nc]
                                        if nr == nil </span><span class="cov0" title="0">{
                                                nr = retryp.Get(0, len(commands))
                                                retries.m[nc] = nr
                                        }</span>
                                        <span class="cov0" title="0">for i := mi; i &lt;= ei; i++ </span><span class="cov0" title="0">{
                                                ii := cIndexes[i]
                                                cm := commands[i]
                                                if mode == RedirectAsk </span><span class="cov0" title="0">{
                                                        nr.aIndexes = append(nr.aIndexes, ii)
                                                        nr.cAskings = append(nr.cAskings, cm)
                                                }</span> else<span class="cov0" title="0"> {
                                                        nr.cIndexes = append(nr.cIndexes, ii)
                                                        nr.commands = append(nr.commands, cm)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">mu.Unlock()
                                        continue</span> // the transaction has been added to the retries, go to the next cmd.
                                }
                        }
                        <span class="cov0" title="0">if hasInit &amp;&amp; mi &lt; i &amp;&amp; i &lt; ei &amp;&amp; mi &gt;= 0 &amp;&amp; isMulti(commands[mi]) </span><span class="cov0" title="0">{
                                continue</span> // the current cmd is in the processed transaction and has been added to the retries.
                        }
                        <span class="cov0" title="0">mu.Lock()
                        if mode != RedirectRetry </span><span class="cov0" title="0">{
                                retries.Redirects++
                        }</span>
                        <span class="cov0" title="0">if mode == RedirectRetry &amp;&amp; retryDelay &gt;= 0 </span><span class="cov0" title="0">{
                                retries.RetryDelay = max(retries.RetryDelay, retryDelay)
                        }</span>
                        <span class="cov0" title="0">nr := retries.m[nc]
                        if nr == nil </span><span class="cov0" title="0">{
                                nr = retryp.Get(0, len(commands))
                                retries.m[nc] = nr
                        }</span>
                        <span class="cov0" title="0">if mode == RedirectAsk </span><span class="cov0" title="0">{
                                nr.aIndexes = append(nr.aIndexes, ii)
                                nr.cAskings = append(nr.cAskings, cm)
                        }</span> else<span class="cov0" title="0"> {
                                nr.cIndexes = append(nr.cIndexes, ii)
                                nr.commands = append(nr.commands, cm)
                        }</span>
                        <span class="cov0" title="0">mu.Unlock()</span>
                }
        }
        <span class="cov0" title="0">return clean</span>
}

func (c *clusterClient) doretry(
        ctx context.Context, cc conn, results *valkeyresults, retries *connretry, re *retry, mu *sync.Mutex, wg *sync.WaitGroup, attempts int, hasInit bool,
) <span class="cov0" title="0">{
        clean := true
        if len(re.commands) != 0 </span><span class="cov0" title="0">{
                resps := cc.DoMulti(ctx, re.commands...)
                if c.hasLftm </span><span class="cov0" title="0">{
                        var ml []Completed
                </span>recover:
                        <span class="cov0" title="0">ml = ml[:0]
                        var txIdx int // check transaction block, if zero, then not in transaction
                        for i, resp := range resps.s </span><span class="cov0" title="0">{
                                if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                        if txIdx &gt; 0 </span><span class="cov0" title="0">{
                                                ml = re.commands[txIdx:]
                                        }</span> else<span class="cov0" title="0"> {
                                                ml = re.commands[i:]
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                                // if no error, then check if transaction block
                                <span class="cov0" title="0">if isMulti(re.commands[i]) </span><span class="cov0" title="0">{
                                        txIdx = i
                                }</span> else<span class="cov0" title="0"> if isExec(re.commands[i]) </span><span class="cov0" title="0">{
                                        txIdx = 0
                                }</span>
                        }
                        <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                                rs := cc.DoMulti(ctx, ml...).s
                                resps.s = append(resps.s[:len(resps.s)-len(rs)], rs...)
                                goto recover</span>
                        }
                }
                <span class="cov0" title="0">clean = c.doresultfn(ctx, results, retries, mu, cc, re.cIndexes, re.commands, resps.s, attempts, hasInit)
                resultsp.Put(resps)</span>
        }
        <span class="cov0" title="0">if len(re.cAskings) != 0 </span><span class="cov0" title="0">{
                resps := c.askingMulti(cc, ctx, re.cAskings)
                clean = c.doresultfn(ctx, results, retries, mu, cc, re.aIndexes, re.cAskings, resps.s, attempts, hasInit) &amp;&amp; clean
                resultsp.Put(resps)
        }</span>
        <span class="cov0" title="0">if clean </span><span class="cov0" title="0">{
                retryp.Put(re)
        }</span>
        <span class="cov0" title="0">wg.Done()</span>
}

func (c *clusterClient) DoMulti(ctx context.Context, multi ...Completed) []ValkeyResult <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">retries, hasInit, err := c.pickMulti(ctx, multi)
        if err != nil </span><span class="cov0" title="0">{
                return fillErrs(len(multi), err)
        }</span>
        <span class="cov0" title="0">defer connretryp.Put(retries)

        var wg sync.WaitGroup
        var mu sync.Mutex

        results := resultsp.Get(len(multi), len(multi))

        attempts := 1

</span>retry:
        <span class="cov0" title="0">retries.RetryDelay = -1 // Assume no retry. Because a client retry flag can be set to false.

        var cc1 conn
        var re1 *retry
        wg.Add(len(retries.m))
        mu.Lock()
        for cc, re := range retries.m </span><span class="cov0" title="0">{
                delete(retries.m, cc)
                cc1 = cc
                re1 = re
                break</span>
        }
        <span class="cov0" title="0">for cc, re := range retries.m </span><span class="cov0" title="0">{
                delete(retries.m, cc)
                go c.doretry(ctx, cc, results, retries, re, &amp;mu, &amp;wg, attempts, hasInit)
        }</span>
        <span class="cov0" title="0">mu.Unlock()
        c.doretry(ctx, cc1, results, retries, re1, &amp;mu, &amp;wg, attempts, hasInit)
        wg.Wait()

        if len(retries.m) != 0 </span><span class="cov0" title="0">{
                if retries.Redirects &gt; 0 </span><span class="cov0" title="0">{
                        retries.Redirects = 0
                        goto retry</span>
                }
                <span class="cov0" title="0">if retries.RetryDelay &gt;= 0 </span><span class="cov0" title="0">{
                        c.retryHandler.WaitForRetry(ctx, retries.RetryDelay)
                        attempts++
                        goto retry</span>
                }
        }

        <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                if results.s[i].NonValkeyError() == nil </span><span class="cov0" title="0">{
                        cmds.PutCompleted(cmd)
                }</span>
        }
        <span class="cov0" title="0">return results.s</span>
}

func fillErrs(n int, err error) (results []ValkeyResult) <span class="cov0" title="0">{
        results = resultsp.Get(n, n).s
        for i := range results </span><span class="cov0" title="0">{
                results[i] = newErrResult(err)
        }</span>
        <span class="cov0" title="0">return results</span>
}

func (c *clusterClient) doCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp ValkeyResult) <span class="cov0" title="0">{
        attempts := 1

</span>retry:
        <span class="cov0" title="0">cc, err := c.pick(ctx, cmd.Slot(), c.toReplica(Completed(cmd)))
        if err != nil </span><span class="cov0" title="0">{
                return newErrResult(err)
        }</span>
        <span class="cov0" title="0">resp = cc.DoCache(ctx, cmd, ttl)
        if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                goto retry</span>
        }
<span class="cov0" title="0">process:
        switch addr, mode := c.shouldRefreshRetry(resp.Error(), ctx); mode </span>{
        case RedirectMove:<span class="cov0" title="0">
                ncc := c.redirectOrNew(addr, cc, cmd.Slot(), mode)
        </span>recover:
                <span class="cov0" title="0">resp = ncc.DoCache(ctx, cmd, ttl)
                if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                        goto recover</span>
                }
                <span class="cov0" title="0">goto process</span>
        case RedirectAsk:<span class="cov0" title="0">
                results := c.askingMultiCache(c.redirectOrNew(addr, cc, cmd.Slot(), mode), ctx, []CacheableTTL{CT(cmd, ttl)})
                resp = results.s[0]
                resultsp.Put(results)
                goto process</span>
        case RedirectRetry:<span class="cov0" title="0">
                if c.retry </span><span class="cov0" title="0">{
                        shouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, Completed(cmd), resp.Error())
                        if shouldRetry </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">return resp</span>
}

func (c *clusterClient) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp ValkeyResult) <span class="cov0" title="0">{
        resp = c.doCache(ctx, cmd, ttl)
        if err := resp.NonValkeyError(); err == nil || err == ErrDoCacheAborted </span><span class="cov0" title="0">{
                cmds.PutCacheable(cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (c *clusterClient) askingMulti(cc conn, ctx context.Context, multi []Completed) *valkeyresults <span class="cov0" title="0">{
        var inTx bool
        commands := make([]Completed, 0, len(multi)*2)
        for _, cmd := range multi </span><span class="cov0" title="0">{
                if inTx </span><span class="cov0" title="0">{
                        commands = append(commands, cmd)
                        inTx = !isExec(cmd)
                }</span> else<span class="cov0" title="0"> {
                        commands = append(commands, cmds.AskingCmd, cmd)
                        inTx = isMulti(cmd)
                }</span>
        }
        <span class="cov0" title="0">results := resultsp.Get(0, len(multi))
        resps := cc.DoMulti(ctx, commands...)
        if c.hasLftm </span><span class="cov0" title="0">{
                var ml []Completed
        </span>recover:
                <span class="cov0" title="0">ml = ml[:0]
                var askingIdx int
                for i, resp := range resps.s </span><span class="cov0" title="0">{
                        if commands[i] == cmds.AskingCmd </span><span class="cov0" title="0">{
                                askingIdx = i
                        }</span>
                        <span class="cov0" title="0">if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                ml = commands[askingIdx:]
                                break</span>
                        }
                }
                <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                        rs := cc.DoMulti(ctx, ml...).s
                        resps.s = append(resps.s[:len(resps.s)-len(rs)], rs...)
                        goto recover</span>
                }
        }
        <span class="cov0" title="0">for i, resp := range resps.s </span><span class="cov0" title="0">{
                if commands[i] != cmds.AskingCmd </span><span class="cov0" title="0">{
                        results.s = append(results.s, resp)
                }</span>
        }
        <span class="cov0" title="0">resultsp.Put(resps)
        return results</span>
}

func (c *clusterClient) askingMultiCache(cc conn, ctx context.Context, multi []CacheableTTL) *valkeyresults <span class="cov0" title="0">{
        commands := make([]Completed, 0, len(multi)*6)
        for _, cmd := range multi </span><span class="cov0" title="0">{
                ck, _ := cmds.CacheKey(cmd.Cmd)
                commands = append(commands, cc.OptInCmd(), cmds.AskingCmd, cmds.MultiCmd, cmds.NewCompleted([]string{"PTTL", ck}), Completed(cmd.Cmd), cmds.ExecCmd)
        }</span>
        <span class="cov0" title="0">results := resultsp.Get(0, len(multi))
        resps := cc.DoMulti(ctx, commands...)
        if c.hasLftm </span><span class="cov0" title="0">{
                var ml []Completed
        </span>recover:
                <span class="cov0" title="0">ml = ml[:0]
                for i := 5; i &lt; len(resps.s); i += 6 </span><span class="cov0" title="0">{ // check exec command error only
                        if resps.s[i].NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                ml = commands[i-5:]
                                break</span>
                        }
                }
                <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                        rs := cc.DoMulti(ctx, ml...).s
                        resps.s = append(resps.s[:len(resps.s)-len(rs)], rs...)
                        goto recover</span>
                }
        }
        <span class="cov0" title="0">for i := 5; i &lt; len(resps.s); i += 6 </span><span class="cov0" title="0">{
                if arr, err := resps.s[i].ToArray(); err != nil </span><span class="cov0" title="0">{
                        if preErr := resps.s[i-1].Error(); preErr != nil </span><span class="cov0" title="0">{ // if {Cmd} get a ValkeyError
                                err = preErr
                        }</span>
                        <span class="cov0" title="0">results.s = append(results.s, newErrResult(err))</span>
                } else<span class="cov0" title="0"> {
                        results.s = append(results.s, newResult(arr[len(arr)-1], nil))
                }</span>
        }
        <span class="cov0" title="0">resultsp.Put(resps)
        return results</span>
}

func (c *clusterClient) _pickMultiCache(multi []CacheableTTL) *connretrycache <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        count := conncountp.Get(len(c.conns), len(c.conns))
        if c.opt.SendToReplicas == nil || c.rslots == nil </span><span class="cov0" title="0">{
                for _, cmd := range multi </span><span class="cov0" title="0">{
                        p := c.pslots[cmd.Cmd.Slot()]
                        if p == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">count.m[p]++</span>
                }

                <span class="cov0" title="0">retries := connretrycachep.Get(len(count.m), len(count.m))
                for cc, n := range count.m </span><span class="cov0" title="0">{
                        retries.m[cc] = retrycachep.Get(0, n)
                }</span>
                <span class="cov0" title="0">conncountp.Put(count)

                for i, cmd := range multi </span><span class="cov0" title="0">{
                        cc := c.pslots[cmd.Cmd.Slot()]
                        re := retries.m[cc]
                        re.commands = append(re.commands, cmd)
                        re.cIndexes = append(re.cIndexes, i)
                }</span>

                <span class="cov0" title="0">return retries</span>
        } else<span class="cov0" title="0"> {
                var destination []conn
                var stackDestination [32]conn
                if len(multi) &lt;= len(stackDestination) </span><span class="cov0" title="0">{
                        destination = stackDestination[:len(multi)]
                }</span> else<span class="cov0" title="0"> {
                        destination = make([]conn, len(multi))
                }</span>
                <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                        var p conn
                        if c.opt.SendToReplicas(Completed(cmd.Cmd)) </span><span class="cov0" title="0">{
                                p = c.rslots[cmd.Cmd.Slot()]
                        }</span> else<span class="cov0" title="0"> {
                                p = c.pslots[cmd.Cmd.Slot()]
                        }</span>
                        <span class="cov0" title="0">if p == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">destination[i] = p
                        count.m[p]++</span>
                }

                <span class="cov0" title="0">retries := connretrycachep.Get(len(count.m), len(count.m))
                for cc, n := range count.m </span><span class="cov0" title="0">{
                        retries.m[cc] = retrycachep.Get(0, n)
                }</span>
                <span class="cov0" title="0">conncountp.Put(count)

                for i, cmd := range multi </span><span class="cov0" title="0">{
                        cc := destination[i]
                        re := retries.m[cc]
                        re.commands = append(re.commands, cmd)
                        re.cIndexes = append(re.cIndexes, i)
                }</span>

                <span class="cov0" title="0">return retries</span>
        }
}

func (c *clusterClient) pickMultiCache(ctx context.Context, multi []CacheableTTL) (*connretrycache, error) <span class="cov0" title="0">{
        conns := c._pickMultiCache(multi)
        if conns == nil </span><span class="cov0" title="0">{
                if err := c.refresh(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if conns = c._pickMultiCache(multi); conns == nil </span><span class="cov0" title="0">{
                        return nil, ErrNoSlot
                }</span>
        }
        <span class="cov0" title="0">return conns, nil</span>
}

func (c *clusterClient) resultcachefn(
        ctx context.Context, results *valkeyresults, retries *connretrycache, mu *sync.Mutex, cc conn, cIndexes []int, commands []CacheableTTL, resps []ValkeyResult, attempts int,
) (clean bool) <span class="cov0" title="0">{
        clean = true
        for i, resp := range resps </span><span class="cov0" title="0">{
                clean = clean &amp;&amp; resp.NonValkeyError() == nil
                ii := cIndexes[i]
                cm := commands[i]
                results.s[ii] = resp
                addr, mode := c.shouldRefreshRetry(resp.Error(), ctx)
                if mode != RedirectNone </span><span class="cov0" title="0">{
                        nc := cc
                        retryDelay := time.Duration(-1)
                        if mode == RedirectRetry </span><span class="cov0" title="0">{
                                if !c.retry </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">retryDelay = c.retryHandler.RetryDelay(attempts, Completed(cm.Cmd), resp.Error())</span>
                        } else<span class="cov0" title="0"> {
                                nc = c.redirectOrNew(addr, cc, cm.Cmd.Slot(), mode)
                        }</span>
                        <span class="cov0" title="0">mu.Lock()
                        if mode != RedirectRetry </span><span class="cov0" title="0">{
                                retries.Redirects++
                        }</span>
                        <span class="cov0" title="0">if mode == RedirectRetry &amp;&amp; retryDelay &gt;= 0 </span><span class="cov0" title="0">{
                                retries.RetryDelay = max(retries.RetryDelay, retryDelay)
                        }</span>
                        <span class="cov0" title="0">nr := retries.m[nc]
                        if nr == nil </span><span class="cov0" title="0">{
                                nr = retrycachep.Get(0, len(commands))
                                retries.m[nc] = nr
                        }</span>
                        <span class="cov0" title="0">if mode == RedirectAsk </span><span class="cov0" title="0">{
                                nr.aIndexes = append(nr.aIndexes, ii)
                                nr.cAskings = append(nr.cAskings, cm)
                        }</span> else<span class="cov0" title="0"> {
                                nr.cIndexes = append(nr.cIndexes, ii)
                                nr.commands = append(nr.commands, cm)
                        }</span>
                        <span class="cov0" title="0">mu.Unlock()</span>
                }
        }
        <span class="cov0" title="0">return clean</span>
}

func (c *clusterClient) doretrycache(
        ctx context.Context, cc conn, results *valkeyresults, retries *connretrycache, re *retrycache, mu *sync.Mutex, wg *sync.WaitGroup, attempts int,
) <span class="cov0" title="0">{
        clean := true
        if len(re.commands) != 0 </span><span class="cov0" title="0">{
                resps := cc.DoMultiCache(ctx, re.commands...)
                if c.hasLftm </span><span class="cov0" title="0">{
                        var ml []CacheableTTL
                </span>recover:
                        <span class="cov0" title="0">ml = ml[:0]
                        for i, resp := range resps.s </span><span class="cov0" title="0">{
                                if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                        ml = re.commands[i:]
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                                rs := cc.DoMultiCache(ctx, ml...).s
                                resps.s = append(resps.s[:len(resps.s)-len(rs)], rs...)
                                goto recover</span>
                        }
                }
                <span class="cov0" title="0">clean = c.resultcachefn(ctx, results, retries, mu, cc, re.cIndexes, re.commands, resps.s, attempts)
                resultsp.Put(resps)</span>
        }
        <span class="cov0" title="0">if len(re.cAskings) != 0 </span><span class="cov0" title="0">{
                resps := c.askingMultiCache(cc, ctx, re.cAskings)
                clean = c.resultcachefn(ctx, results, retries, mu, cc, re.aIndexes, re.cAskings, resps.s, attempts) &amp;&amp; clean
                resultsp.Put(resps)
        }</span>
        <span class="cov0" title="0">if clean </span><span class="cov0" title="0">{
                retrycachep.Put(re)
        }</span>
        <span class="cov0" title="0">wg.Done()</span>
}

func (c *clusterClient) DoMultiCache(ctx context.Context, multi ...CacheableTTL) []ValkeyResult <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">retries, err := c.pickMultiCache(ctx, multi)
        if err != nil </span><span class="cov0" title="0">{
                return fillErrs(len(multi), err)
        }</span>
        <span class="cov0" title="0">defer connretrycachep.Put(retries)

        var wg sync.WaitGroup
        var mu sync.Mutex

        results := resultsp.Get(len(multi), len(multi))

        attempts := 1

</span>retry:
        <span class="cov0" title="0">retries.RetryDelay = -1 // Assume no retry. Because a client retry flag can be set to false.

        var cc1 conn
        var re1 *retrycache
        wg.Add(len(retries.m))
        mu.Lock()
        for cc, re := range retries.m </span><span class="cov0" title="0">{
                delete(retries.m, cc)
                cc1 = cc
                re1 = re
                break</span>
        }
        <span class="cov0" title="0">for cc, re := range retries.m </span><span class="cov0" title="0">{
                delete(retries.m, cc)
                go c.doretrycache(ctx, cc, results, retries, re, &amp;mu, &amp;wg, attempts)
        }</span>
        <span class="cov0" title="0">mu.Unlock()
        c.doretrycache(ctx, cc1, results, retries, re1, &amp;mu, &amp;wg, attempts)
        wg.Wait()

        if len(retries.m) != 0 </span><span class="cov0" title="0">{
                if retries.Redirects &gt; 0 </span><span class="cov0" title="0">{
                        retries.Redirects = 0
                        goto retry</span>
                }
                <span class="cov0" title="0">if retries.RetryDelay &gt;= 0 </span><span class="cov0" title="0">{
                        c.retryHandler.WaitForRetry(ctx, retries.RetryDelay)
                        attempts++
                        goto retry</span>
                }
        }

        <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                if err := results.s[i].NonValkeyError(); err == nil || err == ErrDoCacheAborted </span><span class="cov0" title="0">{
                        cmds.PutCacheable(cmd.Cmd)
                }</span>
        }
        <span class="cov0" title="0">return results.s</span>
}

func (c *clusterClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">cc, err := c.pick(ctx, subscribe.Slot(), c.toReplica(subscribe))
        if err != nil </span><span class="cov0" title="0">{
                goto ret</span>
        }
        <span class="cov0" title="0">err = cc.Receive(ctx, subscribe, fn)
        if err == errConnExpired </span><span class="cov0" title="0">{
                goto retry</span>
        }
        <span class="cov0" title="0">if _, mode := c.shouldRefreshRetry(err, ctx); c.retry &amp;&amp; mode != RedirectNone </span><span class="cov0" title="0">{
                shouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, subscribe, err)
                if shouldRetry </span><span class="cov0" title="0">{
                        attempts++
                        goto retry</span>
                }
        }
ret:
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                cmds.PutCompleted(subscribe)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *clusterClient) DoStream(ctx context.Context, cmd Completed) ValkeyResultStream <span class="cov0" title="0">{
        cc, err := c.pick(ctx, cmd.Slot(), c.toReplica(cmd))
        if err != nil </span><span class="cov0" title="0">{
                return ValkeyResultStream{e: err}
        }</span>
        <span class="cov0" title="0">ret := cc.DoStream(ctx, cmd)
        cmds.PutCompleted(cmd)
        return ret</span>
}

func (c *clusterClient) DoMultiStream(ctx context.Context, multi ...Completed) MultiValkeyResultStream <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return ValkeyResultStream{e: io.EOF}
        }</span>
        <span class="cov0" title="0">slot := multi[0].Slot()
        repl := c.toReplica(multi[0])
        for i := 1; i &lt; len(multi); i++ </span><span class="cov0" title="0">{
                if s := multi[i].Slot(); s != cmds.InitSlot </span><span class="cov0" title="0">{
                        if slot == cmds.InitSlot </span><span class="cov0" title="0">{
                                slot = s
                        }</span> else<span class="cov0" title="0"> if slot != s </span><span class="cov0" title="0">{
                                panic("DoMultiStream across multiple slots is not supported")</span>
                        }
                }
                <span class="cov0" title="0">repl = repl &amp;&amp; c.toReplica(multi[i])</span>
        }
        <span class="cov0" title="0">cc, err := c.pick(ctx, slot, repl)
        if err != nil </span><span class="cov0" title="0">{
                return ValkeyResultStream{e: err}
        }</span>
        <span class="cov0" title="0">ret := cc.DoMultiStream(ctx, multi...)
        for _, cmd := range multi </span><span class="cov0" title="0">{
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func (c *clusterClient) Dedicated(fn func(DedicatedClient) error) (err error) <span class="cov0" title="0">{
        dcc := &amp;dedicatedClusterClient{cmd: c.cmd, client: c, slot: cmds.NoSlot, retry: c.retry, retryHandler: c.retryHandler}
        err = fn(dcc)
        dcc.release()
        return err
}</span>

func (c *clusterClient) Dedicate() (DedicatedClient, func()) <span class="cov0" title="0">{
        dcc := &amp;dedicatedClusterClient{cmd: c.cmd, client: c, slot: cmds.NoSlot, retry: c.retry, retryHandler: c.retryHandler}
        return dcc, dcc.release
}</span>

func (c *clusterClient) Nodes() map[string]Client <span class="cov0" title="0">{
        c.mu.RLock()
        _nodes := make(map[string]Client, len(c.conns))
        disableCache := c.opt != nil &amp;&amp; c.opt.DisableCache
        for addr, cc := range c.conns </span><span class="cov0" title="0">{
                if !cc.hidden </span><span class="cov0" title="0">{
                        _nodes[addr] = newSingleClientWithConn(cc.conn, c.cmd, c.retry, disableCache, c.retryHandler, false)
                }</span>
        }
        <span class="cov0" title="0">c.mu.RUnlock()
        return _nodes</span>
}

func (c *clusterClient) Mode() ClientMode <span class="cov0" title="0">{
        return ClientModeCluster
}</span>

func (c *clusterClient) Close() <span class="cov0" title="0">{
        if atomic.CompareAndSwapUint32(&amp;c.stop, 0, 1) </span><span class="cov0" title="0">{
                close(c.stopCh)
        }</span>

        <span class="cov0" title="0">c.mu.RLock()
        for _, cc := range c.conns </span><span class="cov0" title="0">{
                go cc.conn.Close()
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()</span>
}

func (c *clusterClient) shouldRefreshRetry(err error, ctx context.Context) (addr string, mode RedirectMode) <span class="cov0" title="0">{
        if err != nil &amp;&amp; err != Nil &amp;&amp; err != ErrDoCacheAborted &amp;&amp; atomic.LoadUint32(&amp;c.stop) == 0 </span><span class="cov0" title="0">{
                if err, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                        if addr, ok = err.IsMoved(); ok </span><span class="cov0" title="0">{
                                mode = RedirectMove
                        }</span> else<span class="cov0" title="0"> if addr, ok = err.IsAsk(); ok </span><span class="cov0" title="0">{
                                mode = RedirectAsk
                        }</span> else<span class="cov0" title="0"> if err.IsClusterDown() || err.IsTryAgain() || err.IsLoading() </span><span class="cov0" title="0">{
                                mode = RedirectRetry
                        }</span>
                } else<span class="cov0" title="0"> if ctx.Err() == nil </span><span class="cov0" title="0">{
                        mode = RedirectRetry
                }</span>
                <span class="cov0" title="0">if mode != RedirectNone </span><span class="cov0" title="0">{
                        c.lazyRefresh()
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

type dedicatedClusterClient struct {
        conn         conn
        wire         wire
        retryHandler retryHandler
        client       *clusterClient
        pshks        *pshks
        mu           sync.Mutex
        cmd          Builder
        slot         uint16
        retry        bool
        mark         bool
}

func (c *dedicatedClusterClient) acquire(ctx context.Context, slot uint16) (wire wire, err error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.mark </span><span class="cov0" title="0">{
                return nil, ErrDedicatedClientRecycled
        }</span>
        <span class="cov0" title="0">if c.slot == cmds.NoSlot </span><span class="cov0" title="0">{
                c.slot = slot
        }</span> else<span class="cov0" title="0"> if c.slot != slot &amp;&amp; slot != cmds.InitSlot </span><span class="cov0" title="0">{
                panic(panicMsgCxSlot)</span>
        }
        <span class="cov0" title="0">if c.wire != nil </span><span class="cov0" title="0">{
                return c.wire, nil
        }</span>
        <span class="cov0" title="0">if c.conn, err = c.client.pick(ctx, c.slot, false); err != nil </span><span class="cov0" title="0">{
                if p := c.pshks; p != nil </span><span class="cov0" title="0">{
                        c.pshks = nil
                        p.close &lt;- err
                        close(p.close)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">c.wire = c.conn.Acquire(ctx)
        if p := c.pshks; p != nil </span><span class="cov0" title="0">{
                c.pshks = nil
                ch := c.wire.SetPubSubHooks(p.hooks)
                go func(ch &lt;-chan error) </span><span class="cov0" title="0">{
                        for e := range ch </span><span class="cov0" title="0">{
                                p.close &lt;- e
                        }</span>
                        <span class="cov0" title="0">close(p.close)</span>
                }(ch)
        }
        <span class="cov0" title="0">return c.wire, nil</span>
}

func (c *dedicatedClusterClient) release() <span class="cov0" title="0">{
        c.mu.Lock()
        if !c.mark </span><span class="cov0" title="0">{
                if p := c.pshks; p != nil </span><span class="cov0" title="0">{
                        c.pshks = nil
                        close(p.close)
                }</span>
                <span class="cov0" title="0">if c.wire != nil </span><span class="cov0" title="0">{
                        c.conn.Store(c.wire)
                }</span>
        }
        <span class="cov0" title="0">c.mark = true
        c.mu.Unlock()</span>
}

func (c *dedicatedClusterClient) B() Builder <span class="cov0" title="0">{
        return c.cmd
}</span>

func (c *dedicatedClusterClient) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">if w, err := c.acquire(ctx, cmd.Slot()); err != nil </span><span class="cov0" title="0">{
                resp = newErrResult(err)
        }</span> else<span class="cov0" title="0"> {
                resp = w.Do(ctx, cmd)
                switch _, mode := c.client.shouldRefreshRetry(resp.Error(), ctx); mode </span>{
                case RedirectRetry:<span class="cov0" title="0">
                        if c.retry &amp;&amp; cmd.IsReadOnly() &amp;&amp; w.Error() == nil </span><span class="cov0" title="0">{
                                shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                        ctx, attempts, cmd, resp.Error(),
                                )
                                if shouldRetry </span><span class="cov0" title="0">{
                                        attempts++
                                        goto retry</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">if resp.NonValkeyError() == nil </span><span class="cov0" title="0">{
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (c *dedicatedClusterClient) DoMulti(ctx context.Context, multi ...Completed) (resp []ValkeyResult) <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">slot := chooseSlot(multi)
        if slot == cmds.NoSlot </span><span class="cov0" title="0">{
                panic(panicMsgCxSlot)</span>
        }
        <span class="cov0" title="0">retryable := c.retry
        if retryable </span><span class="cov0" title="0">{
                retryable = allReadOnly(multi)
        }</span>
        <span class="cov0" title="0">attempts := 1
</span>retry:
        <span class="cov0" title="0">if w, err := c.acquire(ctx, slot); err == nil </span><span class="cov0" title="0">{
                resp = w.DoMulti(ctx, multi...).s
                for i, r := range resp </span><span class="cov0" title="0">{
                        _, mode := c.client.shouldRefreshRetry(r.Error(), ctx)
                        if mode == RedirectRetry &amp;&amp; retryable &amp;&amp; w.Error() == nil </span><span class="cov0" title="0">{
                                shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                        ctx, attempts, multi[i], r.Error(),
                                )
                                if shouldRetry </span><span class="cov0" title="0">{
                                        attempts++
                                        goto retry</span>
                                }
                        }
                        <span class="cov0" title="0">if mode != RedirectNone </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                resp = resultsp.Get(len(multi), len(multi)).s
                for i := range resp </span><span class="cov0" title="0">{
                        resp[i] = newErrResult(err)
                }</span>
        }
        <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                if resp[i].NonValkeyError() == nil </span><span class="cov0" title="0">{
                        cmds.PutCompleted(cmd)
                }</span>
        }
        <span class="cov0" title="0">return resp</span>
}

func (c *dedicatedClusterClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) <span class="cov0" title="0">{
        var (
                w        wire
                attempts = 1
        )
</span>retry:
        <span class="cov0" title="0">if w, err = c.acquire(ctx, subscribe.Slot()); err == nil </span><span class="cov0" title="0">{
                err = w.Receive(ctx, subscribe, fn)
                if _, mode := c.client.shouldRefreshRetry(err, ctx); c.retry &amp;&amp; mode == RedirectRetry &amp;&amp; w.Error() == nil </span><span class="cov0" title="0">{
                        shouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, subscribe, err)
                        if shouldRetry </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                cmds.PutCompleted(subscribe)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *dedicatedClusterClient) SetPubSubHooks(hooks PubSubHooks) &lt;-chan error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.mark </span><span class="cov0" title="0">{
                ch := make(chan error, 1)
                ch &lt;- ErrDedicatedClientRecycled
                return ch
        }</span>
        <span class="cov0" title="0">if p := c.pshks; p != nil </span><span class="cov0" title="0">{
                c.pshks = nil
                close(p.close)
        }</span>
        <span class="cov0" title="0">if c.wire != nil </span><span class="cov0" title="0">{
                return c.wire.SetPubSubHooks(hooks)
        }</span>
        <span class="cov0" title="0">if hooks.isZero() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ch := make(chan error, 1)
        c.pshks = &amp;pshks{hooks: hooks, close: ch}
        return ch</span>
}

func (c *dedicatedClusterClient) Close() <span class="cov0" title="0">{
        c.mu.Lock()
        if p := c.pshks; p != nil </span><span class="cov0" title="0">{
                c.pshks = nil
                p.close &lt;- ErrClosing
                close(p.close)
        }</span>
        <span class="cov0" title="0">if c.wire != nil </span><span class="cov0" title="0">{
                c.wire.Close()
        }</span>
        <span class="cov0" title="0">c.mu.Unlock()
        c.release()</span>
}

type RedirectMode int

const (
        RedirectNone RedirectMode = iota
        RedirectMove
        RedirectAsk
        RedirectRetry

        panicMsgCxSlot = "cross slot command in Dedicated is prohibited"
        panicMixCxSlot = "Mixing no-slot and cross slot commands in DoMulti is prohibited"
)
</pre>
		
		<pre class="file" id="file5" style="display: none">package valkey

import (
        "context"
        "errors"
        "iter"
        "time"

        intl "github.com/valkey-io/valkey-go/internal/cmds"
)

// MGetCache is a helper that consults the client-side caches with multiple keys by grouping keys within the same slot into multiple GETs
func MGetCache(client Client, ctx context.Context, ttl time.Duration, keys []string) (ret map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return make(map[string]ValkeyMessage), nil
        }</span>
        <span class="cov0" title="0">if isCacheDisabled(client) </span><span class="cov0" title="0">{
                return MGet(client, ctx, keys)
        }</span>
        <span class="cov0" title="0">cmds := mgetcachecmdsp.Get(len(keys), len(keys))
        defer mgetcachecmdsp.Put(cmds)
        for i := range cmds.s </span><span class="cov0" title="0">{
                cmds.s[i] = CT(client.B().Get().Key(keys[i]).Cache(), ttl)
        }</span>
        <span class="cov0" title="0">return doMultiCache(client, ctx, cmds.s, keys)</span>
}

func isCacheDisabled(client Client) bool <span class="cov0" title="0">{
        switch c := client.(type) </span>{
        case *singleClient:<span class="cov0" title="0">
                return c.DisableCache</span>
        case *standalone:<span class="cov0" title="0">
                return c.primary.DisableCache</span>
        case *sentinelClient:<span class="cov0" title="0">
                return c.mOpt != nil &amp;&amp; c.mOpt.DisableCache</span>
        case *clusterClient:<span class="cov0" title="0">
                return c.opt != nil &amp;&amp; c.opt.DisableCache</span>
        }
        <span class="cov0" title="0">return false</span>
}

// MGet is a helper that consults the valkey directly with multiple keys by grouping keys within the same slot into MGET or multiple GETs
func MGet(client Client, ctx context.Context, keys []string) (ret map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return make(map[string]ValkeyMessage), nil
        }</span>

        <span class="cov0" title="0">switch client.(type) </span>{
        case *singleClient, *standalone, *sentinelClient:<span class="cov0" title="0">
                return clientMGet(client, ctx, client.B().Mget().Key(keys...).Build(), keys)</span>
        }

        <span class="cov0" title="0">cmds := mgetcmdsp.Get(len(keys), len(keys))
        defer mgetcmdsp.Put(cmds)
        for i := range cmds.s </span><span class="cov0" title="0">{
                cmds.s[i] = client.B().Get().Key(keys[i]).Build()
        }</span>
        <span class="cov0" title="0">return doMultiGet(client, ctx, cmds.s, keys)</span>
}

// MSet is a helper that consults the valkey directly with multiple keys by grouping keys within the same slot into MSETs or multiple SETs
func MSet(client Client, ctx context.Context, kvs map[string]string) map[string]error <span class="cov0" title="0">{
        if len(kvs) == 0 </span><span class="cov0" title="0">{
                return make(map[string]error)
        }</span>

        <span class="cov0" title="0">switch client.(type) </span>{
        case *singleClient, *standalone, *sentinelClient:<span class="cov0" title="0">
                return clientMSet(client, ctx, "MSET", kvs, make(map[string]error, len(kvs)))</span>
        }

        <span class="cov0" title="0">cmds := mgetcmdsp.Get(0, len(kvs))
        defer mgetcmdsp.Put(cmds)
        for k, v := range kvs </span><span class="cov0" title="0">{
                cmds.s = append(cmds.s, client.B().Set().Key(k).Value(v).Build().Pin())
        }</span>
        <span class="cov0" title="0">return doMultiSet(client, ctx, cmds.s)</span>
}

// MDel is a helper that consults the valkey directly with multiple keys by grouping keys within the same slot into DELs
func MDel(client Client, ctx context.Context, keys []string) map[string]error <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return make(map[string]error)
        }</span>

        <span class="cov0" title="0">switch client.(type) </span>{
        case *singleClient, *standalone, *sentinelClient:<span class="cov0" title="0">
                return clientMDel(client, ctx, keys)</span>
        }

        <span class="cov0" title="0">cmds := mgetcmdsp.Get(len(keys), len(keys))
        defer mgetcmdsp.Put(cmds)
        for i, k := range keys </span><span class="cov0" title="0">{
                cmds.s[i] = client.B().Del().Key(k).Build().Pin()
        }</span>
        <span class="cov0" title="0">return doMultiSet(client, ctx, cmds.s)</span>
}

// MSetNX is a helper that consults the valkey directly with multiple keys by grouping keys within the same slot into MSETNXs or multiple SETNXs
func MSetNX(client Client, ctx context.Context, kvs map[string]string) map[string]error <span class="cov0" title="0">{
        if len(kvs) == 0 </span><span class="cov0" title="0">{
                return make(map[string]error)
        }</span>

        <span class="cov0" title="0">switch client.(type) </span>{
        case *singleClient, *standalone, *sentinelClient:<span class="cov0" title="0">
                return clientMSet(client, ctx, "MSETNX", kvs, make(map[string]error, len(kvs)))</span>
        }

        <span class="cov0" title="0">cmds := mgetcmdsp.Get(0, len(kvs))
        defer mgetcmdsp.Put(cmds)
        for k, v := range kvs </span><span class="cov0" title="0">{
                cmds.s = append(cmds.s, client.B().Set().Key(k).Value(v).Nx().Build().Pin())
        }</span>
        <span class="cov0" title="0">return doMultiSet(client, ctx, cmds.s)</span>
}

// JsonMGetCache is a helper that consults the client-side caches with multiple keys by grouping keys within the same slot into multiple JSON.GETs
func JsonMGetCache(client Client, ctx context.Context, ttl time.Duration, keys []string, path string) (ret map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return make(map[string]ValkeyMessage), nil
        }</span>
        <span class="cov0" title="0">cmds := mgetcachecmdsp.Get(len(keys), len(keys))
        defer mgetcachecmdsp.Put(cmds)
        for i := range cmds.s </span><span class="cov0" title="0">{
                cmds.s[i] = CT(client.B().JsonGet().Key(keys[i]).Path(path).Cache(), ttl)
        }</span>
        <span class="cov0" title="0">return doMultiCache(client, ctx, cmds.s, keys)</span>
}

// JsonMGet is a helper that consults valkey directly with multiple keys by grouping keys within the same slot into JSON.MGETs or multiple JSON.GETs
func JsonMGet(client Client, ctx context.Context, keys []string, path string) (ret map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return make(map[string]ValkeyMessage), nil
        }</span>

        <span class="cov0" title="0">switch client.(type) </span>{
        case *singleClient, *standalone, *sentinelClient:<span class="cov0" title="0">
                return clientMGet(client, ctx, client.B().JsonMget().Key(keys...).Path(path).Build(), keys)</span>
        }

        <span class="cov0" title="0">cmds := mgetcmdsp.Get(len(keys), len(keys))
        defer mgetcmdsp.Put(cmds)
        for i := range cmds.s </span><span class="cov0" title="0">{
                cmds.s[i] = client.B().JsonGet().Key(keys[i]).Path(path).Build()
        }</span>
        <span class="cov0" title="0">return doMultiGet(client, ctx, cmds.s, keys)</span>
}

// JsonMSet is a helper that consults valkey directly with multiple keys by grouping keys within the same slot into JSON.MSETs or multiple JSON.SETs
func JsonMSet(client Client, ctx context.Context, kvs map[string]string, path string) map[string]error <span class="cov0" title="0">{
        if len(kvs) == 0 </span><span class="cov0" title="0">{
                return make(map[string]error)
        }</span>

        <span class="cov0" title="0">switch client.(type) </span>{
        case *singleClient, *standalone, *sentinelClient:<span class="cov0" title="0">
                return clientJSONMSet(client, ctx, kvs, path, make(map[string]error, len(kvs)))</span>
        }

        <span class="cov0" title="0">cmds := mgetcmdsp.Get(0, len(kvs))
        defer mgetcmdsp.Put(cmds)
        for k, v := range kvs </span><span class="cov0" title="0">{
                cmds.s = append(cmds.s, client.B().JsonSet().Key(k).Path(path).Value(v).Build().Pin())
        }</span>
        <span class="cov0" title="0">return doMultiSet(client, ctx, cmds.s)</span>
}

// DecodeSliceOfJSON is a helper that struct-scans each ValkeyMessage into dest, which must be a slice of the pointer.
func DecodeSliceOfJSON[T any](result ValkeyResult, dest *[]T) error <span class="cov0" title="0">{
        values, err := result.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ts := make([]T, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                var t T
                if err = v.DecodeJSON(&amp;t); err != nil </span><span class="cov0" title="0">{
                        if IsValkeyNil(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">ts[i] = t</span>
        }
        <span class="cov0" title="0">*dest = ts
        return nil</span>
}

func clientMGet(client Client, ctx context.Context, cmd Completed, keys []string) (ret map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        arr, err := client.Do(ctx, cmd).ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return arrayToKV(make(map[string]ValkeyMessage, len(keys)), arr, keys), nil</span>
}

func clientMSet(client Client, ctx context.Context, mset string, kvs map[string]string, ret map[string]error) map[string]error <span class="cov0" title="0">{
        cmd := client.B().Arbitrary(mset)
        for k, v := range kvs </span><span class="cov0" title="0">{
                cmd = cmd.Args(k, v)
        }</span>
        <span class="cov0" title="0">ok, err := client.Do(ctx, cmd.Build()).AsBool()
        if err == nil &amp;&amp; !ok </span><span class="cov0" title="0">{
                err = ErrMSetNXNotSet
        }</span>
        <span class="cov0" title="0">for k := range kvs </span><span class="cov0" title="0">{
                ret[k] = err
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func clientJSONMSet(client Client, ctx context.Context, kvs map[string]string, path string, ret map[string]error) map[string]error <span class="cov0" title="0">{
        cmd := intl.JsonMsetTripletValue(client.B().JsonMset())
        for k, v := range kvs </span><span class="cov0" title="0">{
                cmd = cmd.Key(k).Path(path).Value(v)
        }</span>
        <span class="cov0" title="0">err := client.Do(ctx, cmd.Build()).Error()
        for k := range kvs </span><span class="cov0" title="0">{
                ret[k] = err
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func clientMDel(client Client, ctx context.Context, keys []string) map[string]error <span class="cov0" title="0">{
        err := client.Do(ctx, client.B().Del().Key(keys...).Build()).Error()
        ret := make(map[string]error, len(keys))
        for _, k := range keys </span><span class="cov0" title="0">{
                ret[k] = err
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func doMultiCache(cc Client, ctx context.Context, cmds []CacheableTTL, keys []string) (ret map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        ret = make(map[string]ValkeyMessage, len(keys))
        resps := cc.DoMultiCache(ctx, cmds...)
        defer resultsp.Put(&amp;valkeyresults{s: resps})
        for i, resp := range resps </span><span class="cov0" title="0">{
                if err := resp.NonValkeyError(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">ret[keys[i]] = resp.val</span>
        }
        <span class="cov0" title="0">return ret, nil</span>
}

func doMultiGet(cc Client, ctx context.Context, cmds []Completed, keys []string) (ret map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        ret = make(map[string]ValkeyMessage, len(keys))
        resps := cc.DoMulti(ctx, cmds...)
        defer resultsp.Put(&amp;valkeyresults{s: resps})
        for i, resp := range resps </span><span class="cov0" title="0">{
                if err := resp.NonValkeyError(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">ret[keys[i]] = resp.val</span>
        }
        <span class="cov0" title="0">return ret, nil</span>
}

func doMultiSet(cc Client, ctx context.Context, cmds []Completed) (ret map[string]error) <span class="cov0" title="0">{
        ret = make(map[string]error, len(cmds))
        resps := cc.DoMulti(ctx, cmds...)
        for i, resp := range resps </span><span class="cov0" title="0">{
                if ret[cmds[i].Commands()[1]] = resp.Error(); resp.NonValkeyError() == nil </span><span class="cov0" title="0">{
                        intl.PutCompletedForce(cmds[i])
                }</span>
        }
        <span class="cov0" title="0">resultsp.Put(&amp;valkeyresults{s: resps})
        return ret</span>
}

func arrayToKV(m map[string]ValkeyMessage, arr []ValkeyMessage, keys []string) map[string]ValkeyMessage <span class="cov0" title="0">{
        for i, resp := range arr </span><span class="cov0" title="0">{
                m[keys[i]] = resp
        }</span>
        <span class="cov0" title="0">return m</span>
}

// ErrMSetNXNotSet is used in the MSetNX helper when the underlying MSETNX response is 0.
// Ref: https://redis.io/commands/msetnx/
var ErrMSetNXNotSet = errors.New("MSETNX: no key was set")

type Scanner struct {
        next func(cursor uint64) (ScanEntry, error)
        err  error
}

func NewScanner(next func(cursor uint64) (ScanEntry, error)) *Scanner <span class="cov0" title="0">{
        return &amp;Scanner{next: next}
}</span>

func (s *Scanner) scan() iter.Seq[[]string] <span class="cov0" title="0">{
        return func(yield func([]string) bool) </span><span class="cov0" title="0">{
                var e ScanEntry
                for e, s.err = s.next(0); s.err == nil &amp;&amp; yield(e.Elements) &amp;&amp; e.Cursor != 0; </span><span class="cov0" title="0">{
                        e, s.err = s.next(e.Cursor)
                }</span>
        }
}

func (s *Scanner) Iter() iter.Seq[string] <span class="cov0" title="0">{
        return func(yield func(string) bool) </span><span class="cov0" title="0">{
                for vs := range s.scan() </span><span class="cov0" title="0">{
                        for i := 0; i &lt; len(vs) &amp;&amp; yield(vs[i]); i++ </span>{<span class="cov0" title="0">
                        }</span>
                }
        }
}

func (s *Scanner) Iter2() iter.Seq2[string, string] <span class="cov0" title="0">{
        return func(yield func(string, string) bool) </span><span class="cov0" title="0">{
                for vs := range s.scan() </span><span class="cov0" title="0">{
                        for i := 0; i+1 &lt; len(vs) &amp;&amp; yield(vs[i], vs[i+1]); i += 2 </span>{<span class="cov0" title="0">
                        }</span>
                }
        }
}

func (s *Scanner) Err() error <span class="cov0" title="0">{
        return s.err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package valkey

import (
        "container/list"
        "context"
        "sync"
        "sync/atomic"
        "time"
        "unsafe"

        "github.com/valkey-io/valkey-go/internal/cmds"
)

const (
        entrySize    = int(unsafe.Sizeof(cacheEntry{})) + int(unsafe.Sizeof(&amp;cacheEntry{}))
        keyCacheSize = int(unsafe.Sizeof(keyCache{})) + int(unsafe.Sizeof(&amp;keyCache{}))
        elementSize  = int(unsafe.Sizeof(list.Element{})) + int(unsafe.Sizeof(&amp;list.Element{}))
        stringSSize  = int(unsafe.Sizeof(""))

        entryBaseSize = (keyCacheSize + entrySize + elementSize + stringSSize*2) * 3 / 2
        entryMinSize  = entryBaseSize + messageStructSize

        moveThreshold = uint32(1024 - 1)
)

type cacheEntry struct {
        err  error
        ch   chan struct{}
        kc   *keyCache
        cmd  string
        val  ValkeyMessage
        size int
}

func (e *cacheEntry) Wait(ctx context.Context) (ValkeyMessage, error) <span class="cov0" title="0">{
        if ch := ctx.Done(); ch == nil </span><span class="cov0" title="0">{
                &lt;-e.ch
        }</span> else<span class="cov0" title="0"> {
                select </span>{
                case &lt;-ch:<span class="cov0" title="0">
                        return ValkeyMessage{}, ctx.Err()</span>
                case &lt;-e.ch:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov0" title="0">return e.val, e.err</span>
}

type keyCache struct {
        cache map[string]*list.Element
        key   string
        hits  uint32
        miss  uint32
}

var _ CacheStore = (*lru)(nil)

type lru struct {
        store map[string]*keyCache
        list  *list.List
        mu    sync.RWMutex
        size  int
        max   int
}

func newLRU(opt CacheStoreOption) CacheStore <span class="cov8" title="1">{
        return &amp;lru{
                max:   opt.CacheSizeEachConn,
                store: make(map[string]*keyCache),
                list:  list.New(),
        }
}</span>

func (c *lru) Flight(key, cmd string, ttl time.Duration, now time.Time) (v ValkeyMessage, ce CacheEntry) <span class="cov0" title="0">{
        var ok bool
        var kc *keyCache
        var ele, back *list.Element
        var e *cacheEntry

        c.mu.RLock()
        if kc, ok = c.store[key]; ok </span><span class="cov0" title="0">{
                if ele = kc.cache[cmd]; ele != nil </span><span class="cov0" title="0">{
                        e = ele.Value.(*cacheEntry)
                        v = e.val
                        back = c.list.Back()
                }</span>
        }
        <span class="cov0" title="0">c.mu.RUnlock()

        if e != nil &amp;&amp; (v.typ == 0 || v.relativePTTL(now) &gt; 0) </span><span class="cov0" title="0">{
                hits := atomic.AddUint32(&amp;kc.hits, 1)
                if ele != back &amp;&amp; hits&amp;moveThreshold == 0 </span><span class="cov0" title="0">{
                        c.mu.Lock()
                        if c.list != nil </span><span class="cov0" title="0">{
                                c.list.MoveToBack(ele)
                        }</span>
                        <span class="cov0" title="0">c.mu.Unlock()</span>
                }
                <span class="cov0" title="0">return v, e</span>
        }

        <span class="cov0" title="0">v = ValkeyMessage{}
        e = nil

        c.mu.Lock()
        if kc, ok = c.store[key]; !ok </span><span class="cov0" title="0">{
                if c.store == nil </span><span class="cov0" title="0">{
                        goto ret</span>
                }
                <span class="cov0" title="0">kc = &amp;keyCache{cache: make(map[string]*list.Element, 1), key: key}
                c.store[key] = kc</span>
        }
        <span class="cov0" title="0">if ele = kc.cache[cmd]; ele != nil </span><span class="cov0" title="0">{
                if e = ele.Value.(*cacheEntry); e.val.typ == 0 || e.val.relativePTTL(now) &gt; 0 </span><span class="cov0" title="0">{
                        atomic.AddUint32(&amp;kc.hits, 1)
                        v = e.val
                        c.list.MoveToBack(ele)
                        ce = e
                        goto ret</span>
                } else<span class="cov0" title="0"> {
                        c.list.Remove(ele)
                        c.size -= e.size
                }</span>
        }
        <span class="cov0" title="0">atomic.AddUint32(&amp;kc.miss, 1)
        v.setExpireAt(now.Add(ttl).UnixMilli())
        kc.cache[cmd] = c.list.PushBack(&amp;cacheEntry{cmd: cmd, kc: kc, val: v, ch: make(chan struct{})})
</span>ret:
        <span class="cov0" title="0">c.mu.Unlock()
        return v, ce</span>
}

func (c *lru) Flights(now time.Time, multi []CacheableTTL, results []ValkeyResult, entries map[int]CacheEntry) (missed []int) <span class="cov0" title="0">{
        var moves []*list.Element

        c.mu.RLock()
        for i, ct := range multi </span><span class="cov0" title="0">{
                key, cmd := cmds.CacheKey(ct.Cmd)
                if kc, ok := c.store[key]; ok </span><span class="cov0" title="0">{
                        if ele := kc.cache[cmd]; ele != nil </span><span class="cov0" title="0">{
                                e := ele.Value.(*cacheEntry)
                                v := e.val
                                if v.typ == 0 </span><span class="cov0" title="0">{
                                        entries[i] = e
                                }</span> else<span class="cov0" title="0"> if v.relativePTTL(now) &gt; 0 </span><span class="cov0" title="0">{
                                        results[i] = newResult(v, nil)
                                }</span> else<span class="cov0" title="0"> {
                                        goto miss1</span>
                                }
                                <span class="cov0" title="0">if atomic.AddUint32(&amp;kc.hits, 1)&amp;moveThreshold == 0 </span><span class="cov0" title="0">{
                                        if moves == nil </span><span class="cov0" title="0">{
                                                moves = make([]*list.Element, 0, len(multi))
                                        }</span>
                                        <span class="cov0" title="0">moves = append(moves, ele)</span>
                                }
                                <span class="cov0" title="0">continue</span>
                        }
                }
        miss1:
                <span class="cov0" title="0">if missed == nil </span><span class="cov0" title="0">{
                        missed = make([]int, 0, len(multi))
                }</span>
                <span class="cov0" title="0">missed = append(missed, i)</span>
        }
        <span class="cov0" title="0">c.mu.RUnlock()

        if len(moves) &gt; 0 </span><span class="cov0" title="0">{
                c.mu.Lock()
                if c.list != nil </span><span class="cov0" title="0">{
                        for _, ele := range moves </span><span class="cov0" title="0">{
                                c.list.MoveToBack(ele)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }

        <span class="cov0" title="0">if len(missed) == 0 </span><span class="cov0" title="0">{
                return missed
        }</span>

        <span class="cov0" title="0">j := 0
        c.mu.Lock()
        if c.store == nil </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return missed
        }</span>
        <span class="cov0" title="0">for _, i := range missed </span><span class="cov0" title="0">{
                key, cmd := cmds.CacheKey(multi[i].Cmd)
                kc, ok := c.store[key]
                if !ok </span><span class="cov0" title="0">{
                        kc = &amp;keyCache{cache: make(map[string]*list.Element, 1), key: key}
                        c.store[key] = kc
                }</span>
                <span class="cov0" title="0">if ele := kc.cache[cmd]; ele != nil </span><span class="cov0" title="0">{
                        e := ele.Value.(*cacheEntry)
                        v := e.val
                        if v.typ == 0 </span><span class="cov0" title="0">{
                                entries[i] = e
                        }</span> else<span class="cov0" title="0"> if v.relativePTTL(now) &gt; 0 </span><span class="cov0" title="0">{
                                results[i] = newResult(v, nil)
                        }</span> else<span class="cov0" title="0"> {
                                c.list.Remove(ele)
                                c.size -= e.size
                                goto miss2</span>
                        }
                        <span class="cov0" title="0">atomic.AddUint32(&amp;kc.hits, 1)
                        c.list.MoveToBack(ele)
                        continue</span>
                }
        miss2:
                <span class="cov0" title="0">atomic.AddUint32(&amp;kc.miss, 1)
                v := ValkeyMessage{}
                v.setExpireAt(now.Add(multi[i].TTL).UnixMilli())
                kc.cache[cmd] = c.list.PushBack(&amp;cacheEntry{cmd: cmd, kc: kc, val: v, ch: make(chan struct{})})
                missed[j] = i
                j++</span>
        }
        <span class="cov0" title="0">c.mu.Unlock()
        return missed[:j]</span>
}

func (c *lru) Update(key, cmd string, value ValkeyMessage) (pxat int64) <span class="cov0" title="0">{
        var ch chan struct{}
        c.mu.Lock()
        if kc, ok := c.store[key]; ok </span><span class="cov0" title="0">{
                if ele := kc.cache[cmd]; ele != nil </span><span class="cov0" title="0">{
                        if e := ele.Value.(*cacheEntry); e.val.typ == 0 </span><span class="cov0" title="0">{
                                pxat = value.getExpireAt()
                                cpttl := e.val.getExpireAt()
                                if cpttl &lt; pxat || pxat == 0 </span><span class="cov0" title="0">{
                                        // server side ttl should only shorten client side ttl
                                        pxat = cpttl
                                        value.setExpireAt(pxat)
                                }</span>
                                <span class="cov0" title="0">e.val = value
                                e.size = entryBaseSize + 2*(len(key)+len(cmd)) + value.approximateSize()
                                c.size += e.size
                                ch = e.ch</span>
                        }

                        <span class="cov0" title="0">ele = c.list.Front()
                        for c.size &gt; c.max &amp;&amp; ele != nil </span><span class="cov0" title="0">{
                                if e := ele.Value.(*cacheEntry); e.val.typ != 0 </span><span class="cov0" title="0">{ // do not delete pending entries
                                        kc := e.kc
                                        if delete(kc.cache, e.cmd); len(kc.cache) == 0 </span><span class="cov0" title="0">{
                                                delete(c.store, kc.key)
                                        }</span>
                                        <span class="cov0" title="0">c.list.Remove(ele)
                                        c.size -= e.size</span>
                                }
                                <span class="cov0" title="0">ele = ele.Next()</span>
                        }
                }
        }
        <span class="cov0" title="0">c.mu.Unlock()
        if ch != nil </span><span class="cov0" title="0">{
                close(ch)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (c *lru) Cancel(key, cmd string, err error) <span class="cov0" title="0">{
        var ch chan struct{}
        c.mu.Lock()
        if kc, ok := c.store[key]; ok </span><span class="cov0" title="0">{
                if ele := kc.cache[cmd]; ele != nil </span><span class="cov0" title="0">{
                        if e := ele.Value.(*cacheEntry); e.val.typ == 0 </span><span class="cov0" title="0">{
                                e.err = err
                                ch = e.ch
                                if delete(kc.cache, cmd); len(kc.cache) == 0 </span><span class="cov0" title="0">{
                                        delete(c.store, key)
                                }</span>
                                <span class="cov0" title="0">c.list.Remove(ele)</span>
                        }
                }
        }
        <span class="cov0" title="0">c.mu.Unlock()
        if ch != nil </span><span class="cov0" title="0">{
                close(ch)
        }</span>
}

func (c *lru) GetTTL(key, cmd string) (ttl time.Duration) <span class="cov0" title="0">{
        c.mu.Lock()
        if kc, ok := c.store[key]; ok &amp;&amp; kc.cache[cmd] != nil </span><span class="cov0" title="0">{
                ttl = time.Duration(kc.cache[cmd].Value.(*cacheEntry).val.relativePTTL(time.Now())) * time.Millisecond
        }</span>
        <span class="cov0" title="0">if ttl &lt;= 0 </span><span class="cov0" title="0">{
                ttl = -2
        }</span>
        <span class="cov0" title="0">c.mu.Unlock()
        return</span>
}

func (c *lru) purge(key string, kc *keyCache) <span class="cov0" title="0">{
        if kc != nil </span><span class="cov0" title="0">{
                for cmd, ele := range kc.cache </span><span class="cov0" title="0">{
                        if ele != nil </span><span class="cov0" title="0">{
                                e := ele.Value.(*cacheEntry)
                                if e.val.typ == 0 </span><span class="cov0" title="0">{ // do not delete pending entries
                                        continue</span>
                                }
                                <span class="cov0" title="0">c.list.Remove(ele)
                                c.size -= e.size</span>
                        }
                        <span class="cov0" title="0">if delete(kc.cache, cmd); len(kc.cache) == 0 </span><span class="cov0" title="0">{
                                delete(c.store, key)
                        }</span>
                }
        }
}

func (c *lru) Delete(keys []ValkeyMessage) <span class="cov0" title="0">{
        c.mu.Lock()
        if keys == nil </span><span class="cov0" title="0">{
                for key, kc := range c.store </span><span class="cov0" title="0">{
                        c.purge(key, kc)
                }</span>
        } else<span class="cov0" title="0"> {
                for _, k := range keys </span><span class="cov0" title="0">{
                        c.purge(k.string(), c.store[k.string()])
                }</span>
        }
        <span class="cov0" title="0">c.mu.Unlock()</span>
}

func (c *lru) Close(err error) <span class="cov8" title="1">{
        c.mu.Lock()
        for _, kc := range c.store </span><span class="cov0" title="0">{
                for _, ele := range kc.cache </span><span class="cov0" title="0">{
                        if ele != nil </span><span class="cov0" title="0">{
                                if e := ele.Value.(*cacheEntry); e.val.typ == 0 </span><span class="cov0" title="0">{
                                        e.err = err
                                        close(e.ch)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">c.store = nil
        c.list = nil
        c.mu.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package valkey

import (
        "context"
        "crypto/sha1"
        "encoding/hex"
        "runtime"
        "sync/atomic"

        "github.com/valkey-io/valkey-go/internal/util"
)

// NewLuaScript creates a Lua instance whose Lua.Exec uses EVALSHA and EVAL.
func NewLuaScript(script string) *Lua <span class="cov0" title="0">{
        return newLuaScript(script, false, false)
}</span>

// NewLuaScriptReadOnly creates a Lua instance whose Lua.Exec uses EVALSHA_RO and EVAL_RO.
func NewLuaScriptReadOnly(script string) *Lua <span class="cov0" title="0">{
        return newLuaScript(script, true, false)
}</span>

// NewLuaScriptNoSha creates a Lua instance whose Lua.Exec uses EVAL.
// Sha1 is not calculated, SCRIPT LOAD is not used, no EVALSHA is used.
// The main motivation is to be FIPS compliant, also avoid the tiny chance of SHA-1 collisions.
// This comes with a performance cost as the script is sent to a server every time.
func NewLuaScriptNoSha(script string) *Lua <span class="cov0" title="0">{
        return newLuaScript(script, false, true)
}</span>

// NewLuaScriptReadOnlyNoSha creates a Lua instance whose Lua.Exec uses EVAL_RO.
// Sha1 is not calculated, SCRIPT LOAD is not used, no EVALSHA_RO is used.
// The main motivation is to be FIPS compliant, also avoid the tiny chance of SHA-1 collisions.
// This comes with a performance cost as the script is sent to a server every time.
func NewLuaScriptReadOnlyNoSha(script string) *Lua <span class="cov0" title="0">{
        return newLuaScript(script, true, true)
}</span>

func newLuaScript(script string, readonly bool, noSha1 bool) *Lua <span class="cov0" title="0">{
        var sha1Hex string
        if !noSha1 </span><span class="cov0" title="0">{
                // It's important to avoid calling sha1 methods since Go will panic in FIPS mode.
                sum := sha1.Sum([]byte(script))
                sha1Hex = hex.EncodeToString(sum[:])
        }</span>
        <span class="cov0" title="0">return &amp;Lua{
                script:   script,
                sha1:     sha1Hex,
                maxp:     runtime.GOMAXPROCS(0),
                readonly: readonly,
                nosha1:   noSha1,
        }</span>
}

// Lua represents a valkey lua script. It should be created from the NewLuaScript() or NewLuaScriptReadOnly().
type Lua struct {
        script   string
        sha1     string
        maxp     int
        readonly bool
        nosha1   bool
}

// Exec the script to the given Client.
// It will first try with the EVALSHA/EVALSHA_RO and then EVAL/EVAL_RO if the first try failed.
// If Lua is initialized with disabled SHA1, it will use EVAL/EVAL_RO without the EVALSHA/EVALSHA_RO attempt.
// Cross-slot keys are prohibited if the Client is a cluster client.
func (s *Lua) Exec(ctx context.Context, c Client, keys, args []string) (resp ValkeyResult) <span class="cov0" title="0">{
        var isNoScript bool
        if !s.nosha1 </span><span class="cov0" title="0">{
                if s.readonly </span><span class="cov0" title="0">{
                        resp = c.Do(ctx, c.B().EvalshaRo().Sha1(s.sha1).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())
                }</span> else<span class="cov0" title="0"> {
                        resp = c.Do(ctx, c.B().Evalsha().Sha1(s.sha1).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())
                }</span>
                <span class="cov0" title="0">err, isErr := IsValkeyErr(resp.Error())
                isNoScript = isErr &amp;&amp; err.IsNoScript()</span>
        }
        <span class="cov0" title="0">if s.nosha1 || isNoScript </span><span class="cov0" title="0">{
                if s.readonly </span><span class="cov0" title="0">{
                        resp = c.Do(ctx, c.B().EvalRo().Script(s.script).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())
                }</span> else<span class="cov0" title="0"> {
                        resp = c.Do(ctx, c.B().Eval().Script(s.script).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())
                }</span>
        }
        <span class="cov0" title="0">return resp</span>
}

// LuaExec is a single execution unit of Lua.ExecMulti.
type LuaExec struct {
        Keys []string
        Args []string
}

// ExecMulti exec the script multiple times by the provided LuaExec to the given Client.
// It will first try SCRIPT LOAD the script to all valkey nodes and then exec it with the EVALSHA/EVALSHA_RO.
// If Lua is initialized with disabled SHA1, it will use EVAL/EVAL_RO and no script loading.
// Cross-slot keys within the single LuaExec are prohibited if the Client is a cluster client.
func (s *Lua) ExecMulti(ctx context.Context, c Client, multi ...LuaExec) (resp []ValkeyResult) <span class="cov0" title="0">{
        if !s.nosha1 </span><span class="cov0" title="0">{
                var e atomic.Value
                util.ParallelVals(s.maxp, c.Nodes(), func(n Client) </span><span class="cov0" title="0">{
                        if err := n.Do(ctx, n.B().ScriptLoad().Script(s.script).Build()).Error(); err != nil </span><span class="cov0" title="0">{
                                e.CompareAndSwap(nil, &amp;errs{error: err})
                        }</span>
                })
                <span class="cov0" title="0">if err := e.Load(); err != nil </span><span class="cov0" title="0">{
                        resp = make([]ValkeyResult, len(multi))
                        for i := 0; i &lt; len(resp); i++ </span><span class="cov0" title="0">{
                                resp[i] = newErrResult(err.(*errs).error)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
        <span class="cov0" title="0">cmds := make(Commands, 0, len(multi))
        for _, m := range multi </span><span class="cov0" title="0">{
                if !s.nosha1 </span><span class="cov0" title="0">{
                        if s.readonly </span><span class="cov0" title="0">{
                                cmds = append(cmds, c.B().EvalshaRo().Sha1(s.sha1).Numkeys(int64(len(m.Keys))).Key(m.Keys...).Arg(m.Args...).Build())
                        }</span> else<span class="cov0" title="0"> {
                                cmds = append(cmds, c.B().Evalsha().Sha1(s.sha1).Numkeys(int64(len(m.Keys))).Key(m.Keys...).Arg(m.Args...).Build())
                        }</span>
                } else<span class="cov0" title="0"> {
                        if s.readonly </span><span class="cov0" title="0">{
                                cmds = append(cmds, c.B().EvalRo().Script(s.script).Numkeys(int64(len(m.Keys))).Key(m.Keys...).Arg(m.Args...).Build())
                        }</span> else<span class="cov0" title="0"> {
                                cmds = append(cmds, c.B().Eval().Script(s.script).Numkeys(int64(len(m.Keys))).Key(m.Keys...).Arg(m.Args...).Build())
                        }</span>
                }
        }
        <span class="cov0" title="0">return c.DoMulti(ctx, cmds...)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package valkey

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "strconv"
        "strings"
        "time"
        "unsafe"

        "github.com/valkey-io/valkey-go/internal/util"
)

const messageStructSize = int(unsafe.Sizeof(ValkeyMessage{}))

// Nil represents a Valkey Nil message
var Nil = &amp;ValkeyError{typ: typeNull}

// ErrParse is a parse error that occurs when a Valkey message cannot be parsed correctly.
var errParse = errors.New("valkey: parse error")

// IsValkeyNil is a handy method to check if the error is a valkey nil response.
// All valkey nil responses returned as an error.
func IsValkeyNil(err error) bool <span class="cov0" title="0">{
        return err == Nil
}</span>

// IsParseErr checks if the error is a parse error
func IsParseErr(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, errParse)
}</span>

// IsValkeyBusyGroup checks if it is a valkey BUSYGROUP message.
func IsValkeyBusyGroup(err error) bool <span class="cov0" title="0">{
        if ret, yes := IsValkeyErr(err); yes </span><span class="cov0" title="0">{
                return ret.IsBusyGroup()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsValkeyErr is a handy method to check if the error is a valkey ERR response.
func IsValkeyErr(err error) (ret *ValkeyError, ok bool) <span class="cov8" title="1">{
        ret, ok = err.(*ValkeyError)
        return ret, ok &amp;&amp; ret != Nil
}</span>

// ValkeyError is an error response or a nil message from the valkey instance
type ValkeyError ValkeyMessage

// string retrieves the contained string of the ValkeyError
func (m *ValkeyError) string() string <span class="cov8" title="1">{
        if m.bytes == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return unsafe.String(m.bytes, m.intlen)</span>
}

func (r *ValkeyError) Error() string <span class="cov8" title="1">{
        if r.IsNil() </span><span class="cov0" title="0">{
                return "valkey nil message"
        }</span>
        <span class="cov8" title="1">return r.string()</span>
}

// IsNil checks if it is a valkey nil message.
func (r *ValkeyError) IsNil() bool <span class="cov8" title="1">{
        return r.typ == typeNull
}</span>

// IsMoved checks if it is a valkey MOVED message and returns the moved address.
func (r *ValkeyError) IsMoved() (addr string, ok bool) <span class="cov0" title="0">{
        if ok = strings.HasPrefix(r.string(), "MOVED"); ok </span><span class="cov0" title="0">{
                addr = fixIPv6HostPort(strings.Split(r.string(), " ")[2])
        }</span>
        <span class="cov0" title="0">return</span>
}

// IsAsk checks if it is a valkey ASK message and returns ask address.
func (r *ValkeyError) IsAsk() (addr string, ok bool) <span class="cov0" title="0">{
        if ok = strings.HasPrefix(r.string(), "ASK"); ok </span><span class="cov0" title="0">{
                addr = fixIPv6HostPort(strings.Split(r.string(), " ")[2])
        }</span>
        <span class="cov0" title="0">return</span>
}

// IsRedirect checks if it is a valkey REDIRECT message and returns redirect address.
func (r *ValkeyError) IsRedirect() (addr string, ok bool) <span class="cov8" title="1">{
        if ok = strings.HasPrefix(r.string(), "REDIRECT"); ok </span><span class="cov8" title="1">{
                addr = fixIPv6HostPort(strings.Split(r.string(), " ")[1])
        }</span>
        <span class="cov8" title="1">return</span>
}

func fixIPv6HostPort(addr string) string <span class="cov8" title="1">{
        if strings.IndexByte(addr, '.') &lt; 0 &amp;&amp; len(addr) &gt; 0 &amp;&amp; addr[0] != '[' </span><span class="cov0" title="0">{ // skip ipv4 and enclosed ipv6
                if i := strings.LastIndexByte(addr, ':'); i &gt;= 0 </span><span class="cov0" title="0">{
                        return net.JoinHostPort(addr[:i], addr[i+1:])
                }</span>
        }
        <span class="cov8" title="1">return addr</span>
}

// IsTryAgain checks if it is a valkey TRYAGAIN message and returns ask address.
func (r *ValkeyError) IsTryAgain() bool <span class="cov0" title="0">{
        return strings.HasPrefix(r.string(), "TRYAGAIN")
}</span>

// IsLoading checks if it is a valkey LOADING message
func (r *ValkeyError) IsLoading() bool <span class="cov0" title="0">{
        return strings.HasPrefix(r.string(), "LOADING")
}</span>

// IsClusterDown checks if it is a valkey CLUSTERDOWN message and returns ask address.
func (r *ValkeyError) IsClusterDown() bool <span class="cov0" title="0">{
        return strings.HasPrefix(r.string(), "CLUSTERDOWN")
}</span>

// IsNoScript checks if it is a valkey NOSCRIPT message.
func (r *ValkeyError) IsNoScript() bool <span class="cov0" title="0">{
        return strings.HasPrefix(r.string(), "NOSCRIPT")
}</span>

// IsBusyGroup checks if it is a valkey BUSYGROUP message.
func (r *ValkeyError) IsBusyGroup() bool <span class="cov0" title="0">{
        return strings.HasPrefix(r.string(), "BUSYGROUP")
}</span>

func newResult(val ValkeyMessage, err error) ValkeyResult <span class="cov8" title="1">{
        return ValkeyResult{val: val, err: err}
}</span>

func newErrResult(err error) ValkeyResult <span class="cov8" title="1">{
        return ValkeyResult{err: err}
}</span>

// ValkeyResult is the return struct from Client.Do or Client.DoCache
// it contains either a valkey response or an underlying error (ex. network timeout).
type ValkeyResult struct {
        err error
        val ValkeyMessage
}

// NonValkeyError can be used to check if there is an underlying error (ex. network timeout).
func (r ValkeyResult) NonValkeyError() error <span class="cov8" title="1">{
        return r.err
}</span>

// Error returns either underlying error or valkey error or nil
func (r ValkeyResult) Error() (err error) <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov8" title="1">{
                err = r.err
        }</span> else<span class="cov8" title="1"> {
                err = r.val.Error()
        }</span>
        <span class="cov8" title="1">return</span>
}

// ToMessage retrieves the ValkeyMessage
func (r ValkeyResult) ToMessage() (v ValkeyMessage, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                err = r.val.Error()
        }</span>
        <span class="cov0" title="0">return r.val, err</span>
}

// ToInt64 delegates to ValkeyMessage.ToInt64
func (r ValkeyResult) ToInt64() (v int64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.ToInt64()
        }</span>
        <span class="cov0" title="0">return</span>
}

// ToBool delegates to ValkeyMessage.ToBool
func (r ValkeyResult) ToBool() (v bool, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.ToBool()
        }</span>
        <span class="cov0" title="0">return</span>
}

// ToFloat64 delegates to ValkeyMessage.ToFloat64
func (r ValkeyResult) ToFloat64() (v float64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.ToFloat64()
        }</span>
        <span class="cov0" title="0">return</span>
}

// ToString delegates to ValkeyMessage.ToString
func (r ValkeyResult) ToString() (v string, err error) <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov8" title="1"> {
                v, err = r.val.ToString()
        }</span>
        <span class="cov8" title="1">return</span>
}

// AsReader delegates to ValkeyMessage.AsReader
func (r ValkeyResult) AsReader() (v io.Reader, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsReader()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsBytes delegates to ValkeyMessage.AsBytes
func (r ValkeyResult) AsBytes() (v []byte, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsBytes()
        }</span>
        <span class="cov0" title="0">return</span>
}

// DecodeJSON delegates to ValkeyMessage.DecodeJSON
func (r ValkeyResult) DecodeJSON(v any) (err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                err = r.val.DecodeJSON(v)
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsInt64 delegates to ValkeyMessage.AsInt64
func (r ValkeyResult) AsInt64() (v int64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsInt64()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsUint64 delegates to ValkeyMessage.AsUint64
func (r ValkeyResult) AsUint64() (v uint64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsUint64()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsBool delegates to ValkeyMessage.AsBool
func (r ValkeyResult) AsBool() (v bool, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsBool()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsFloat64 delegates to ValkeyMessage.AsFloat64
func (r ValkeyResult) AsFloat64() (v float64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsFloat64()
        }</span>
        <span class="cov0" title="0">return</span>
}

// ToArray delegates to ValkeyMessage.ToArray
func (r ValkeyResult) ToArray() (v []ValkeyMessage, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.ToArray()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsStrSlice delegates to ValkeyMessage.AsStrSlice
func (r ValkeyResult) AsStrSlice() (v []string, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsStrSlice()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsIntSlice delegates to ValkeyMessage.AsIntSlice
func (r ValkeyResult) AsIntSlice() (v []int64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsIntSlice()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsFloatSlice delegates to ValkeyMessage.AsFloatSlice
func (r ValkeyResult) AsFloatSlice() (v []float64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsFloatSlice()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsBoolSlice delegates to ValkeyMessage.AsBoolSlice
func (r ValkeyResult) AsBoolSlice() (v []bool, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsBoolSlice()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsXRangeEntry delegates to ValkeyMessage.AsXRangeEntry
func (r ValkeyResult) AsXRangeEntry() (v XRangeEntry, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsXRangeEntry()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsXRange delegates to ValkeyMessage.AsXRange
func (r ValkeyResult) AsXRange() (v []XRangeEntry, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsXRange()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsZScore delegates to ValkeyMessage.AsZScore
func (r ValkeyResult) AsZScore() (v ZScore, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsZScore()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsZScores delegates to ValkeyMessage.AsZScores
func (r ValkeyResult) AsZScores() (v []ZScore, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsZScores()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsXRead delegates to ValkeyMessage.AsXRead
func (r ValkeyResult) AsXRead() (v map[string][]XRangeEntry, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsXRead()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsXRangeSlice delegates to ValkeyMessage.AsXRangeSlice
func (r ValkeyResult) AsXRangeSlice() (v XRangeSlice, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsXRangeSlice()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsXRangeSlices delegates to ValkeyMessage.AsXRangeSlices
func (r ValkeyResult) AsXRangeSlices() (v []XRangeSlice, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsXRangeSlices()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsXReadSlices delegates to ValkeyMessage.AsXReadSlices
func (r ValkeyResult) AsXReadSlices() (v map[string][]XRangeSlice, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsXReadSlices()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (r ValkeyResult) AsLMPop() (v KeyValues, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsLMPop()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (r ValkeyResult) AsZMPop() (v KeyZScores, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsZMPop()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (r ValkeyResult) AsFtSearch() (total int64, docs []FtSearchDoc, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                total, docs, err = r.val.AsFtSearch()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (r ValkeyResult) AsFtAggregate() (total int64, docs []map[string]string, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                total, docs, err = r.val.AsFtAggregate()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (r ValkeyResult) AsFtAggregateCursor() (cursor, total int64, docs []map[string]string, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                cursor, total, docs, err = r.val.AsFtAggregateCursor()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (r ValkeyResult) AsGeosearch() (locations []GeoLocation, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                locations, err = r.val.AsGeosearch()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsMap delegates to ValkeyMessage.AsMap
func (r ValkeyResult) AsMap() (v map[string]ValkeyMessage, err error) <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov8" title="1"> {
                v, err = r.val.AsMap()
        }</span>
        <span class="cov8" title="1">return</span>
}

// AsStrMap delegates to ValkeyMessage.AsStrMap
func (r ValkeyResult) AsStrMap() (v map[string]string, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsStrMap()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsIntMap delegates to ValkeyMessage.AsIntMap
func (r ValkeyResult) AsIntMap() (v map[string]int64, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsIntMap()
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsScanEntry delegates to ValkeyMessage.AsScanEntry.
func (r ValkeyResult) AsScanEntry() (v ScanEntry, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.AsScanEntry()
        }</span>
        <span class="cov0" title="0">return</span>
}

// ToMap delegates to ValkeyMessage.ToMap
func (r ValkeyResult) ToMap() (v map[string]ValkeyMessage, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.ToMap()
        }</span>
        <span class="cov0" title="0">return</span>
}

// ToAny delegates to ValkeyMessage.ToAny
func (r ValkeyResult) ToAny() (v any, err error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                err = r.err
        }</span> else<span class="cov0" title="0"> {
                v, err = r.val.ToAny()
        }</span>
        <span class="cov0" title="0">return</span>
}

// IsCacheHit delegates to ValkeyMessage.IsCacheHit
func (r ValkeyResult) IsCacheHit() bool <span class="cov0" title="0">{
        return r.val.IsCacheHit()
}</span>

// CacheTTL delegates to ValkeyMessage.CacheTTL
func (r ValkeyResult) CacheTTL() int64 <span class="cov0" title="0">{
        return r.val.CacheTTL()
}</span>

// CachePTTL delegates to ValkeyMessage.CachePTTL
func (r ValkeyResult) CachePTTL() int64 <span class="cov0" title="0">{
        return r.val.CachePTTL()
}</span>

// CachePXAT delegates to ValkeyMessage.CachePXAT
func (r ValkeyResult) CachePXAT() int64 <span class="cov0" title="0">{
        return r.val.CachePXAT()
}</span>

// String returns human-readable representation of ValkeyResult
func (r *ValkeyResult) String() string <span class="cov0" title="0">{
        v, _ := (*prettyValkeyResult)(r).MarshalJSON()
        return string(v)
}</span>

type prettyValkeyResult ValkeyResult

// MarshalJSON implements json.Marshaler interface
func (r *prettyValkeyResult) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type PrettyValkeyResult struct {
                Message *prettyValkeyMessage `json:"Message,omitempty"`
                Error   string               `json:"Error,omitempty"`
        }
        obj := PrettyValkeyResult{}
        if r.err != nil </span><span class="cov0" title="0">{
                obj.Error = r.err.Error()
        }</span> else<span class="cov0" title="0"> {
                obj.Message = (*prettyValkeyMessage)(&amp;r.val)
        }</span>
        <span class="cov0" title="0">return json.Marshal(obj)</span>
}

// ValkeyMessage is a valkey response message, it may be a nil response
type ValkeyMessage struct {
        attrs *ValkeyMessage
        bytes *byte
        array *ValkeyMessage

        // intlen is used for a simple number or
        // in conjunction with an array or bytes to store the length of array or string
        intlen int64
        typ    byte
        ttl    [7]byte
}

func (m *ValkeyMessage) string() string <span class="cov8" title="1">{
        if m.bytes == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return unsafe.String(m.bytes, m.intlen)</span>
}

func (m *ValkeyMessage) values() []ValkeyMessage <span class="cov8" title="1">{
        if m.array == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return unsafe.Slice(m.array, m.intlen)</span>
}

func (m *ValkeyMessage) setString(s string) <span class="cov8" title="1">{
        m.bytes = unsafe.StringData(s)
        m.intlen = int64(len(s))
}</span>

func (m *ValkeyMessage) setValues(values []ValkeyMessage) <span class="cov0" title="0">{
        m.array = unsafe.SliceData(values)
        m.intlen = int64(len(values))
}</span>

func (m *ValkeyMessage) cachesize() int <span class="cov0" title="0">{
        n := 9 // typ (1) + length (8) TODO: can we use VarInt instead of fixed 8 bytes for length?
        switch m.typ </span>{
        case typeInteger, typeNull, typeBool:<span class="cov0" title="0"></span>
        case typeArray, typeMap, typeSet:<span class="cov0" title="0">
                for _, val := range m.values() </span><span class="cov0" title="0">{
                        n += val.cachesize()
                }</span>
        default:<span class="cov0" title="0">
                n += len(m.string())</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *ValkeyMessage) serialize(o *bytes.Buffer) <span class="cov0" title="0">{
        var buf [8]byte // TODO: can we use VarInt instead of fixed 8 bytes for length?
        o.WriteByte(m.typ)
        switch m.typ </span>{
        case typeInteger, typeNull, typeBool:<span class="cov0" title="0">
                binary.BigEndian.PutUint64(buf[:], uint64(m.intlen))
                o.Write(buf[:])</span>
        case typeArray, typeMap, typeSet:<span class="cov0" title="0">
                binary.BigEndian.PutUint64(buf[:], uint64(len(m.values())))
                o.Write(buf[:])
                for _, val := range m.values() </span><span class="cov0" title="0">{
                        val.serialize(o)
                }</span>
        default:<span class="cov0" title="0">
                binary.BigEndian.PutUint64(buf[:], uint64(len(m.string())))
                o.Write(buf[:])
                o.WriteString(m.string())</span>
        }
}

var ErrCacheUnmarshal = errors.New("cache unmarshal error")

func (m *ValkeyMessage) unmarshalView(c int64, buf []byte) (int64, error) <span class="cov0" title="0">{
        var err error
        if int64(len(buf)) &lt; c+9 </span><span class="cov0" title="0">{
                return 0, ErrCacheUnmarshal
        }</span>
        <span class="cov0" title="0">m.typ = buf[c]
        c += 1
        size := int64(binary.BigEndian.Uint64(buf[c : c+8]))
        c += 8 // TODO: can we use VarInt instead of fixed 8 bytes for length?
        switch m.typ </span>{
        case typeInteger, typeNull, typeBool:<span class="cov0" title="0">
                m.intlen = size</span>
        case typeArray, typeMap, typeSet:<span class="cov0" title="0">
                m.setValues(make([]ValkeyMessage, size))
                for i := range m.values() </span><span class="cov0" title="0">{
                        if c, err = m.values()[i].unmarshalView(c, buf); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        default:<span class="cov0" title="0">
                if int64(len(buf)) &lt; c+size </span><span class="cov0" title="0">{
                        return 0, ErrCacheUnmarshal
                }</span>
                <span class="cov0" title="0">m.setString(BinaryString(buf[c : c+size]))
                c += size</span>
        }
        <span class="cov0" title="0">return c, err</span>
}

// CacheSize returns the buffer size needed by the CacheMarshal.
func (m *ValkeyMessage) CacheSize() int <span class="cov0" title="0">{
        return m.cachesize() + 7 // 7 for ttl
}</span>

// CacheMarshal writes serialized ValkeyMessage to the provided buffer.
// If the provided buffer is nil, CacheMarshal will allocate one.
// Note that an output format is not compatible with different client versions.
func (m *ValkeyMessage) CacheMarshal(buf []byte) []byte <span class="cov0" title="0">{
        if buf == nil </span><span class="cov0" title="0">{
                buf = make([]byte, 0, m.CacheSize())
        }</span>
        <span class="cov0" title="0">o := bytes.NewBuffer(buf)
        o.Write(m.ttl[:7])
        m.serialize(o)
        return o.Bytes()</span>
}

// CacheUnmarshalView construct the ValkeyMessage from the buffer produced by CacheMarshal.
// Note that the buffer can't be reused after CacheUnmarshalView since it uses unsafe.String on top of the buffer.
func (m *ValkeyMessage) CacheUnmarshalView(buf []byte) error <span class="cov0" title="0">{
        if len(buf) &lt; 7 </span><span class="cov0" title="0">{
                return ErrCacheUnmarshal
        }</span>
        <span class="cov0" title="0">copy(m.ttl[:7], buf[:7])
        if _, err := m.unmarshalView(7, buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">m.attrs = cacheMark
        return nil</span>
}

// IsNil check if the message is a valkey nil response
func (m *ValkeyMessage) IsNil() bool <span class="cov0" title="0">{
        return m.typ == typeNull
}</span>

// IsInt64 check if the message is a valkey RESP3 int response
func (m *ValkeyMessage) IsInt64() bool <span class="cov0" title="0">{
        return m.typ == typeInteger
}</span>

// IsFloat64 check if the message is a valkey RESP3 double response
func (m *ValkeyMessage) IsFloat64() bool <span class="cov0" title="0">{
        return m.typ == typeFloat
}</span>

// IsString check if the message is a valkey string response
func (m *ValkeyMessage) IsString() bool <span class="cov8" title="1">{
        return m.typ == typeBlobString || m.typ == typeSimpleString
}</span>

// IsBool check if the message is a valkey RESP3 bool response
func (m *ValkeyMessage) IsBool() bool <span class="cov0" title="0">{
        return m.typ == typeBool
}</span>

// IsArray check if the message is a valkey array response
func (m *ValkeyMessage) IsArray() bool <span class="cov0" title="0">{
        return m.typ == typeArray || m.typ == typeSet
}</span>

// IsMap check if the message is a valkey RESP3 map response
func (m *ValkeyMessage) IsMap() bool <span class="cov8" title="1">{
        return m.typ == typeMap
}</span>

// Error check if the message is a valkey error response, including nil response
func (m *ValkeyMessage) Error() error <span class="cov8" title="1">{
        if m.typ == typeNull </span><span class="cov0" title="0">{
                return Nil
        }</span>
        <span class="cov8" title="1">if m.typ == typeSimpleErr || m.typ == typeBlobErr </span><span class="cov8" title="1">{
                // kvrocks: https://github.com/redis/rueidis/issues/152#issuecomment-1333923750
                mm := *m
                mm.setString(strings.TrimPrefix(m.string(), "ERR "))
                return (*ValkeyError)(&amp;mm)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ToString check if the message is a valkey string response and return it
func (m *ValkeyMessage) ToString() (val string, err error) <span class="cov8" title="1">{
        if m.IsString() </span><span class="cov8" title="1">{
                return m.string(), nil
        }</span>
        <span class="cov0" title="0">if m.IsInt64() || m.array != nil </span><span class="cov0" title="0">{
                typ := m.typ
                return "", fmt.Errorf("%w: valkey message type %s is not a string", errParse, typeNames[typ])
        }</span>
        <span class="cov0" title="0">return m.string(), m.Error()</span>
}

// AsReader check if the message is a valkey string response and wrap it with the strings.NewReader
func (m *ValkeyMessage) AsReader() (reader io.Reader, err error) <span class="cov0" title="0">{
        str, err := m.ToString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return strings.NewReader(str), nil</span>
}

// AsBytes check if the message is a valkey string response and return it as an immutable []byte
func (m *ValkeyMessage) AsBytes() (bs []byte, err error) <span class="cov0" title="0">{
        str, err := m.ToString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return unsafe.Slice(unsafe.StringData(str), len(str)), nil</span>
}

// DecodeJSON check if the message is a valkey string response and treat it as JSON, then unmarshal it into the provided value
func (m *ValkeyMessage) DecodeJSON(v any) (err error) <span class="cov0" title="0">{
        b, err := m.AsBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(b, v)</span>
}

// AsInt64 check if the message is a valkey string response and parse it as int64
func (m *ValkeyMessage) AsInt64() (val int64, err error) <span class="cov0" title="0">{
        if m.IsInt64() </span><span class="cov0" title="0">{
                return m.intlen, nil
        }</span>
        <span class="cov0" title="0">v, err := m.ToString()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.ParseInt(v, 10, 64)</span>
}

// AsUint64 check if the message is a valkey string response and parse it as uint64
func (m *ValkeyMessage) AsUint64() (val uint64, err error) <span class="cov0" title="0">{
        if m.IsInt64() </span><span class="cov0" title="0">{
                return uint64(m.intlen), nil
        }</span>
        <span class="cov0" title="0">v, err := m.ToString()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.ParseUint(v, 10, 64)</span>
}

// AsBool checks if the message is a non-nil response and parses it as bool
func (m *ValkeyMessage) AsBool() (val bool, err error) <span class="cov0" title="0">{
        if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch m.typ </span>{
        case typeBlobString, typeSimpleString:<span class="cov0" title="0">
                val = m.string() == "OK"
                return</span>
        case typeInteger:<span class="cov0" title="0">
                val = m.intlen != 0
                return</span>
        case typeBool:<span class="cov0" title="0">
                val = m.intlen == 1
                return</span>
        default:<span class="cov0" title="0">
                typ := m.typ
                return false, fmt.Errorf("%w: valkey message type %s is not a int, string or bool", errParse, typeNames[typ])</span>
        }
}

// AsFloat64 check if the message is a valkey string response and parse it as float64
func (m *ValkeyMessage) AsFloat64() (val float64, err error) <span class="cov0" title="0">{
        if m.IsFloat64() </span><span class="cov0" title="0">{
                return util.ToFloat64(m.string())
        }</span>
        <span class="cov0" title="0">v, err := m.ToString()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return util.ToFloat64(v)</span>
}

// ToInt64 check if the message is a valkey RESP3 int response and return it
func (m *ValkeyMessage) ToInt64() (val int64, err error) <span class="cov0" title="0">{
        if m.IsInt64() </span><span class="cov0" title="0">{
                return m.intlen, nil
        }</span>
        <span class="cov0" title="0">if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return 0, fmt.Errorf("%w: valkey message type %s is not a RESP3 int64", errParse, typeNames[typ])</span>
}

// ToBool check if the message is a valkey RESP3 bool response and return it
func (m *ValkeyMessage) ToBool() (val bool, err error) <span class="cov0" title="0">{
        if m.IsBool() </span><span class="cov0" title="0">{
                return m.intlen == 1, nil
        }</span>
        <span class="cov0" title="0">if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return false, fmt.Errorf("%w: valkey message type %s is not a RESP3 bool", errParse, typeNames[typ])</span>
}

// ToFloat64 check if the message is a valkey RESP3 double response and return it
func (m *ValkeyMessage) ToFloat64() (val float64, err error) <span class="cov0" title="0">{
        if m.IsFloat64() </span><span class="cov0" title="0">{
                return util.ToFloat64(m.string())
        }</span>
        <span class="cov0" title="0">if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return 0, fmt.Errorf("%w: valkey message type %s is not a RESP3 float64", errParse, typeNames[typ])</span>
}

// ToArray check if the message is a valkey array/set response and return it
func (m *ValkeyMessage) ToArray() ([]ValkeyMessage, error) <span class="cov0" title="0">{
        if m.IsArray() </span><span class="cov0" title="0">{
                return m.values(), nil
        }</span>
        <span class="cov0" title="0">if err := m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a array", errParse, typeNames[typ])</span>
}

// AsStrSlice check if the message is a valkey array/set response and convert to []string.
// valkey nil element and other non-string elements will be present as zero.
func (m *ValkeyMessage) AsStrSlice() ([]string, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s := make([]string, 0, len(values))
        for _, v := range values </span><span class="cov0" title="0">{
                s = append(s, v.string())
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}

// AsIntSlice check if the message is a valkey array/set response and convert to []int64.
// valkey nil element and other non-integer elements will be present as zero.
func (m *ValkeyMessage) AsIntSlice() ([]int64, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s := make([]int64, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                if len(v.string()) != 0 </span><span class="cov0" title="0">{
                        if s[i], err = strconv.ParseInt(v.string(), 10, 64); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        s[i] = v.intlen
                }</span>
        }
        <span class="cov0" title="0">return s, nil</span>
}

// AsFloatSlice check if the message is a valkey array/set response and convert to []float64.
// valkey nil element and other non-float elements will be present as zero.
func (m *ValkeyMessage) AsFloatSlice() ([]float64, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s := make([]float64, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                if len(v.string()) != 0 </span><span class="cov0" title="0">{
                        if s[i], err = util.ToFloat64(v.string()); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        s[i] = float64(v.intlen)
                }</span>
        }
        <span class="cov0" title="0">return s, nil</span>
}

// AsBoolSlice checks if the message is a valkey array/set response and converts it to []bool.
// Valkey nil elements and other non-boolean elements will be represented as false.
func (m *ValkeyMessage) AsBoolSlice() ([]bool, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s := make([]bool, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                s[i], _ = v.AsBool() // Ignore error, non-boolean values will be false
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}

// XRangeEntry is the element type of both XRANGE and XREVRANGE command response array
type XRangeEntry struct {
        FieldValues map[string]string
        ID          string
}

// AsXRangeEntry check if the message is a valkey array/set response of length 2 and convert to XRangeEntry
func (m *ValkeyMessage) AsXRangeEntry() (XRangeEntry, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return XRangeEntry{}, err
        }</span>
        <span class="cov0" title="0">if len(values) != 2 </span><span class="cov0" title="0">{
                return XRangeEntry{}, fmt.Errorf("got %d, wanted 2", len(values))
        }</span>
        <span class="cov0" title="0">id, err := values[0].ToString()
        if err != nil </span><span class="cov0" title="0">{
                return XRangeEntry{}, err
        }</span>
        <span class="cov0" title="0">fieldValues, err := values[1].AsStrMap()
        if err != nil </span><span class="cov0" title="0">{
                if IsValkeyNil(err) </span><span class="cov0" title="0">{
                        return XRangeEntry{ID: id, FieldValues: nil}, nil
                }</span>
                <span class="cov0" title="0">return XRangeEntry{}, err</span>
        }
        <span class="cov0" title="0">return XRangeEntry{
                ID:          id,
                FieldValues: fieldValues,
        }, nil</span>
}

// AsXRange check if the message is a valkey array/set response and convert to []XRangeEntry
func (m *ValkeyMessage) AsXRange() ([]XRangeEntry, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">msgs := make([]XRangeEntry, 0, len(values))
        for _, v := range values </span><span class="cov0" title="0">{
                msg, err := v.AsXRangeEntry()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">msgs = append(msgs, msg)</span>
        }
        <span class="cov0" title="0">return msgs, nil</span>
}

// AsXRead converts XREAD/XREADGRUOP response to map[string][]XRangeEntry
func (m *ValkeyMessage) AsXRead() (ret map[string][]XRangeEntry, err error) <span class="cov0" title="0">{
        if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if m.IsMap() </span><span class="cov0" title="0">{
                ret = make(map[string][]XRangeEntry, len(m.values())/2)
                for i := 0; i &lt; len(m.values()); i += 2 </span><span class="cov0" title="0">{
                        if ret[m.values()[i].string()], err = m.values()[i+1].AsXRange(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        }
        <span class="cov0" title="0">if m.IsArray() </span><span class="cov0" title="0">{
                ret = make(map[string][]XRangeEntry, len(m.values()))
                for _, v := range m.values() </span><span class="cov0" title="0">{
                        if !v.IsArray() || len(v.values()) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("got %d, wanted 2", len(v.values()))
                        }</span>
                        <span class="cov0" title="0">if ret[v.values()[0].string()], err = v.values()[1].AsXRange(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a map/array/set", errParse, typeNames[typ])</span>
}

// New slice-based structures that preserve order and duplicates
type XRangeSlice struct {
        ID          string
        FieldValues []XRangeFieldValue
}

type XRangeFieldValue struct {
        Field string
        Value string
}

// AsXRangeSlice converts a ValkeyMessage to XRangeSlice (preserves order and duplicates)
func (m *ValkeyMessage) AsXRangeSlice() (XRangeSlice, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return XRangeSlice{}, err
        }</span>
        <span class="cov0" title="0">if len(values) != 2 </span><span class="cov0" title="0">{
                return XRangeSlice{}, fmt.Errorf("got %d, wanted 2", len(values))
        }</span>
        <span class="cov0" title="0">id, err := values[0].ToString()
        if err != nil </span><span class="cov0" title="0">{
                return XRangeSlice{}, err
        }</span>
        // Handle the field-values array
        <span class="cov0" title="0">fieldArray, err := values[1].ToArray()
        if err != nil </span><span class="cov0" title="0">{
                if IsValkeyNil(err) </span><span class="cov0" title="0">{
                        return XRangeSlice{ID: id, FieldValues: nil}, nil
                }</span>
                <span class="cov0" title="0">return XRangeSlice{}, err</span>
        }
        // Convert pairs to slice (preserving order)
        <span class="cov0" title="0">fieldValues := make([]XRangeFieldValue, 0, len(fieldArray)/2)
        for i := 0; i &lt; cap(fieldValues); i++ </span><span class="cov0" title="0">{
                field := fieldArray[i*2].string()
                value := fieldArray[i*2+1].string()
                fieldValues = append(fieldValues, XRangeFieldValue{
                        Field: field,
                        Value: value,
                })
        }</span>
        <span class="cov0" title="0">return XRangeSlice{
                ID:          id,
                FieldValues: fieldValues,
        }, nil</span>
}

// AsXRangeSlices converts multiple XRange entries to slice format
func (m *ValkeyMessage) AsXRangeSlices() ([]XRangeSlice, error) <span class="cov0" title="0">{
        values, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">msgs := make([]XRangeSlice, 0, len(values))
        for _, v := range values </span><span class="cov0" title="0">{
                msg, err := v.AsXRangeSlice()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">msgs = append(msgs, msg)</span>
        }
        <span class="cov0" title="0">return msgs, nil</span>
}

// AsXReadSlices converts XREAD/XREADGROUP response to use slice format
func (m *ValkeyMessage) AsXReadSlices() (map[string][]XRangeSlice, error) <span class="cov0" title="0">{
        if err := m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var ret map[string][]XRangeSlice
        var err error
        if m.IsMap() </span><span class="cov0" title="0">{
                ret = make(map[string][]XRangeSlice, len(m.values())/2)
                for i := 0; i &lt; len(m.values()); i += 2 </span><span class="cov0" title="0">{
                        if ret[m.values()[i].string()], err = m.values()[i+1].AsXRangeSlices(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        }
        <span class="cov0" title="0">if m.IsArray() </span><span class="cov0" title="0">{
                ret = make(map[string][]XRangeSlice, len(m.values()))
                for _, v := range m.values() </span><span class="cov0" title="0">{
                        if !v.IsArray() || len(v.values()) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("got %d, wanted 2", len(v.values()))
                        }</span>
                        <span class="cov0" title="0">if ret[v.values()[0].string()], err = v.values()[1].AsXRangeSlices(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a map/array/set", errParse, typeNames[typ])</span>
}

// ZScore is the element type of ZRANGE WITHSCORES, ZDIFF WITHSCORES and ZPOPMAX command response
type ZScore struct {
        Member string
        Score  float64
}

func toZScore(values []ValkeyMessage) (s ZScore, err error) <span class="cov0" title="0">{
        if len(values) == 2 </span><span class="cov0" title="0">{
                if s.Member, err = values[0].ToString(); err == nil </span><span class="cov0" title="0">{
                        s.Score, err = values[1].AsFloat64()
                }</span>
                <span class="cov0" title="0">return s, err</span>
        }
        <span class="cov0" title="0">return ZScore{}, fmt.Errorf("valkey message is not a map/array/set or its length is not 2")</span>
}

// AsZScore converts ZPOPMAX and ZPOPMIN command with count 1 response to a single ZScore
func (m *ValkeyMessage) AsZScore() (s ZScore, err error) <span class="cov0" title="0">{
        arr, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov0" title="0">return toZScore(arr)</span>
}

// AsZScores converts ZRANGE WITHSCORES, ZDIFF WITHSCORES and ZPOPMAX/ZPOPMIN command with count &gt; 1 responses to []ZScore
func (m *ValkeyMessage) AsZScores() ([]ZScore, error) <span class="cov0" title="0">{
        arr, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(arr) &gt; 0 &amp;&amp; arr[0].IsArray() </span><span class="cov0" title="0">{
                scores := make([]ZScore, len(arr))
                for i, v := range arr </span><span class="cov0" title="0">{
                        if scores[i], err = toZScore(v.values()); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">return scores, nil</span>
        }
        <span class="cov0" title="0">scores := make([]ZScore, len(arr)/2)
        for i := 0; i &lt; len(scores); i++ </span><span class="cov0" title="0">{
                j := i * 2
                if scores[i], err = toZScore(arr[j : j+2]); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return scores, nil</span>
}

// ScanEntry is the element type of both SCAN, SSCAN, HSCAN and ZSCAN command response.
type ScanEntry struct {
        Elements []string
        Cursor   uint64
}

// AsScanEntry check if the message is a valkey array/set response of length 2 and convert to ScanEntry.
func (m *ValkeyMessage) AsScanEntry() (e ScanEntry, err error) <span class="cov0" title="0">{
        msgs, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return ScanEntry{}, err
        }</span>
        <span class="cov0" title="0">if len(msgs) &gt;= 2 </span><span class="cov0" title="0">{
                if e.Cursor, err = msgs[0].AsUint64(); err == nil </span><span class="cov0" title="0">{
                        e.Elements, err = msgs[1].AsStrSlice()
                }</span>
                <span class="cov0" title="0">return e, err</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return ScanEntry{}, fmt.Errorf("%w: valkey message type %s is not a scan response or its length is not at least 2", errParse, typeNames[typ])</span>
}

// AsMap check if the message is a valkey array/set response and convert to map[string]ValkeyMessage
func (m *ValkeyMessage) AsMap() (map[string]ValkeyMessage, error) <span class="cov8" title="1">{
        if err := m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if (m.IsMap() || m.IsArray()) &amp;&amp; len(m.values())%2 == 0 </span><span class="cov8" title="1">{
                return toMap(m.values())
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a map/array/set or its length is not even", errParse, typeNames[typ])</span>
}

// AsStrMap check if the message is a valkey map/array/set response and convert to map[string]string.
// valkey nil element and other non-string elements will be present as zero.
func (m *ValkeyMessage) AsStrMap() (map[string]string, error) <span class="cov0" title="0">{
        if err := m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if (m.IsMap() || m.IsArray()) &amp;&amp; len(m.values())%2 == 0 </span><span class="cov0" title="0">{
                r := make(map[string]string, len(m.values())/2)
                for i := 0; i &lt; len(m.values()); i += 2 </span><span class="cov0" title="0">{
                        k := m.values()[i]
                        v := m.values()[i+1]
                        r[k.string()] = v.string()
                }</span>
                <span class="cov0" title="0">return r, nil</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a map/array/set or its length is not even", errParse, typeNames[typ])</span>
}

// AsIntMap check if the message is a valkey map/array/set response and convert to map[string]int64.
// valkey nil element and other non-integer elements will be present as zero.
func (m *ValkeyMessage) AsIntMap() (map[string]int64, error) <span class="cov0" title="0">{
        if err := m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if (m.IsMap() || m.IsArray()) &amp;&amp; len(m.values())%2 == 0 </span><span class="cov0" title="0">{
                var err error
                r := make(map[string]int64, len(m.values())/2)
                for i := 0; i &lt; len(m.values()); i += 2 </span><span class="cov0" title="0">{
                        k := m.values()[i]
                        v := m.values()[i+1]
                        if k.typ == typeBlobString || k.typ == typeSimpleString </span><span class="cov0" title="0">{
                                if len(v.string()) != 0 </span><span class="cov0" title="0">{
                                        if r[k.string()], err = strconv.ParseInt(v.string(), 0, 64); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                } else<span class="cov0" title="0"> if v.typ == typeInteger || v.typ == typeNull </span><span class="cov0" title="0">{
                                        r[k.string()] = v.intlen
                                }</span>
                        }
                }
                <span class="cov0" title="0">return r, nil</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a map/array/set or its length is not even", errParse, typeNames[typ])</span>
}

type KeyValues struct {
        Key    string
        Values []string
}

func (m *ValkeyMessage) AsLMPop() (kvs KeyValues, err error) <span class="cov0" title="0">{
        if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return KeyValues{}, err
        }</span>
        <span class="cov0" title="0">if len(m.values()) &gt;= 2 </span><span class="cov0" title="0">{
                kvs.Key = m.values()[0].string()
                kvs.Values, err = m.values()[1].AsStrSlice()
                return
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return KeyValues{}, fmt.Errorf("%w: valkey message type %s is not a LMPOP response", errParse, typeNames[typ])</span>
}

type KeyZScores struct {
        Key    string
        Values []ZScore
}

func (m *ValkeyMessage) AsZMPop() (kvs KeyZScores, err error) <span class="cov0" title="0">{
        if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return KeyZScores{}, err
        }</span>
        <span class="cov0" title="0">if len(m.values()) &gt;= 2 </span><span class="cov0" title="0">{
                kvs.Key = m.values()[0].string()
                kvs.Values, err = m.values()[1].AsZScores()
                return
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return KeyZScores{}, fmt.Errorf("%w: valkey message type %s is not a ZMPOP response", errParse, typeNames[typ])</span>
}

type FtSearchDoc struct {
        Doc   map[string]string
        Key   string
        Score float64
}

func (m *ValkeyMessage) AsFtSearch() (total int64, docs []FtSearchDoc, err error) <span class="cov0" title="0">{
        if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov0" title="0">if m.IsMap() </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(m.values()); i += 2 </span><span class="cov0" title="0">{
                        switch m.values()[i].string() </span>{
                        case "total_results":<span class="cov0" title="0">
                                total = m.values()[i+1].intlen</span>
                        case "results":<span class="cov0" title="0">
                                records := m.values()[i+1].values()
                                docs = make([]FtSearchDoc, len(records))
                                for d, record := range records </span><span class="cov0" title="0">{
                                        for j := 0; j &lt; len(record.values()); j += 2 </span><span class="cov0" title="0">{
                                                switch record.values()[j].string() </span>{
                                                case "id":<span class="cov0" title="0">
                                                        docs[d].Key = record.values()[j+1].string()</span>
                                                case "extra_attributes":<span class="cov0" title="0">
                                                        docs[d].Doc, _ = record.values()[j+1].AsStrMap()</span>
                                                case "score":<span class="cov0" title="0">
                                                        docs[d].Score, _ = strconv.ParseFloat(record.values()[j+1].string(), 64)</span>
                                                }
                                        }
                                }
                        case "error":<span class="cov0" title="0">
                                for _, e := range m.values()[i+1].values() </span><span class="cov0" title="0">{
                                        e := e
                                        return 0, nil, (*ValkeyError)(&amp;e)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if len(m.values()) &gt; 0 </span><span class="cov0" title="0">{
                total = m.values()[0].intlen
                wscore := false
                wattrs := false
                offset := 1
                if len(m.values()) &gt; 2 </span><span class="cov0" title="0">{
                        if m.values()[2].string() == "" </span><span class="cov0" title="0">{
                                wattrs = true
                                offset++
                        }</span> else<span class="cov0" title="0"> {
                                _, err1 := strconv.ParseFloat(m.values()[1].string(), 64)
                                _, err2 := strconv.ParseFloat(m.values()[2].string(), 64)
                                wscore = err1 != nil &amp;&amp; err2 == nil
                                offset++
                        }</span>
                }
                <span class="cov0" title="0">if len(m.values()) &gt; 3 &amp;&amp; m.values()[3].string() == "" </span><span class="cov0" title="0">{
                        wattrs = true
                        offset++
                }</span>
                <span class="cov0" title="0">docs = make([]FtSearchDoc, 0, (len(m.values())-1)/offset)
                for i := 1; i &lt; len(m.values()); i++ </span><span class="cov0" title="0">{
                        doc := FtSearchDoc{Key: m.values()[i].string()}
                        if wscore </span><span class="cov0" title="0">{
                                i++
                                doc.Score, _ = strconv.ParseFloat(m.values()[i].string(), 64)
                        }</span>
                        <span class="cov0" title="0">if wattrs </span><span class="cov0" title="0">{
                                i++
                                doc.Doc, _ = m.values()[i].AsStrMap()
                        }</span>
                        <span class="cov0" title="0">docs = append(docs, doc)</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return 0, nil, fmt.Errorf("%w: valkey message type %s is not a FT.SEARCH response", errParse, typeNames[typ])</span>
}

func (m *ValkeyMessage) AsFtAggregate() (total int64, docs []map[string]string, err error) <span class="cov0" title="0">{
        if err = m.Error(); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov0" title="0">if m.IsMap() </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(m.values()); i += 2 </span><span class="cov0" title="0">{
                        switch m.values()[i].string() </span>{
                        case "total_results":<span class="cov0" title="0">
                                total = m.values()[i+1].intlen</span>
                        case "results":<span class="cov0" title="0">
                                records := m.values()[i+1].values()
                                docs = make([]map[string]string, len(records))
                                for d, record := range records </span><span class="cov0" title="0">{
                                        for j := 0; j &lt; len(record.values()); j += 2 </span><span class="cov0" title="0">{
                                                switch record.values()[j].string() </span>{
                                                case "extra_attributes":<span class="cov0" title="0">
                                                        docs[d], _ = record.values()[j+1].AsStrMap()</span>
                                                }
                                        }
                                }
                        case "error":<span class="cov0" title="0">
                                for _, e := range m.values()[i+1].values() </span><span class="cov0" title="0">{
                                        e := e
                                        return 0, nil, (*ValkeyError)(&amp;e)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if len(m.values()) &gt; 0 </span><span class="cov0" title="0">{
                total = m.values()[0].intlen
                docs = make([]map[string]string, len(m.values())-1)
                for d, record := range m.values()[1:] </span><span class="cov0" title="0">{
                        docs[d], _ = record.AsStrMap()
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return 0, nil, fmt.Errorf("%w: valkey message type %s is not a FT.AGGREGATE response", errParse, typeNames[typ])</span>
}

func (m *ValkeyMessage) AsFtAggregateCursor() (cursor, total int64, docs []map[string]string, err error) <span class="cov0" title="0">{
        if m.IsArray() &amp;&amp; len(m.values()) == 2 &amp;&amp; (m.values()[0].IsArray() || m.values()[0].IsMap()) </span><span class="cov0" title="0">{
                total, docs, err = m.values()[0].AsFtAggregate()
                cursor = m.values()[1].intlen
        }</span> else<span class="cov0" title="0"> {
                total, docs, err = m.AsFtAggregate()
        }</span>
        <span class="cov0" title="0">return</span>
}

type GeoLocation struct {
        Name                      string
        Longitude, Latitude, Dist float64
        GeoHash                   int64
}

func (m *ValkeyMessage) AsGeosearch() ([]GeoLocation, error) <span class="cov0" title="0">{
        arr, err := m.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">geoLocations := make([]GeoLocation, 0, len(arr))
        for _, v := range arr </span><span class="cov0" title="0">{
                var loc GeoLocation
                if v.IsString() </span><span class="cov0" title="0">{
                        loc.Name = v.string()
                }</span> else<span class="cov0" title="0"> {
                        info := v.values()
                        var i int

                        //name
                        loc.Name = info[i].string()
                        i++
                        //distance
                        if i &lt; len(info) &amp;&amp; info[i].string() != "" </span><span class="cov0" title="0">{
                                loc.Dist, err = util.ToFloat64(info[i].string())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">i++</span>
                        }
                        //hash
                        <span class="cov0" title="0">if i &lt; len(info) &amp;&amp; info[i].IsInt64() </span><span class="cov0" title="0">{
                                loc.GeoHash = info[i].intlen
                                i++
                        }</span>
                        //coordinates
                        <span class="cov0" title="0">if i &lt; len(info) &amp;&amp; info[i].array != nil </span><span class="cov0" title="0">{
                                cord := info[i].values()
                                if len(cord) &lt; 2 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("got %d, expected 2", len(info))
                                }</span>
                                <span class="cov0" title="0">loc.Longitude, _ = cord[0].AsFloat64()
                                loc.Latitude, _ = cord[1].AsFloat64()</span>
                        }
                }
                <span class="cov0" title="0">geoLocations = append(geoLocations, loc)</span>
        }
        <span class="cov0" title="0">return geoLocations, nil</span>
}

// ToMap check if the message is a valkey RESP3 map response and return it
func (m *ValkeyMessage) ToMap() (map[string]ValkeyMessage, error) <span class="cov0" title="0">{
        if m.IsMap() </span><span class="cov0" title="0">{
                return toMap(m.values())
        }</span>
        <span class="cov0" title="0">if err := m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a RESP3 map", errParse, typeNames[typ])</span>
}

// ToAny turns the message into go any value
func (m *ValkeyMessage) ToAny() (any, error) <span class="cov0" title="0">{
        if err := m.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch m.typ </span>{
        case typeFloat:<span class="cov0" title="0">
                return util.ToFloat64(m.string())</span>
        case typeBlobString, typeSimpleString, typeVerbatimString, typeBigNumber:<span class="cov0" title="0">
                return m.string(), nil</span>
        case typeBool:<span class="cov0" title="0">
                return m.intlen == 1, nil</span>
        case typeInteger:<span class="cov0" title="0">
                return m.intlen, nil</span>
        case typeMap:<span class="cov0" title="0">
                vs := make(map[string]any, len(m.values())/2)
                for i := 0; i &lt; len(m.values()); i += 2 </span><span class="cov0" title="0">{
                        if v, err := m.values()[i+1].ToAny(); err != nil &amp;&amp; !IsValkeyNil(err) </span><span class="cov0" title="0">{
                                vs[m.values()[i].string()] = err
                        }</span> else<span class="cov0" title="0"> {
                                vs[m.values()[i].string()] = v
                        }</span>
                }
                <span class="cov0" title="0">return vs, nil</span>
        case typeSet, typeArray:<span class="cov0" title="0">
                vs := make([]any, len(m.values()))
                for i := 0; i &lt; len(m.values()); i++ </span><span class="cov0" title="0">{
                        if v, err := m.values()[i].ToAny(); err != nil &amp;&amp; !IsValkeyNil(err) </span><span class="cov0" title="0">{
                                vs[i] = err
                        }</span> else<span class="cov0" title="0"> {
                                vs[i] = v
                        }</span>
                }
                <span class="cov0" title="0">return vs, nil</span>
        }
        <span class="cov0" title="0">typ := m.typ
        return nil, fmt.Errorf("%w: valkey message type %s is not a supported in ToAny", errParse, typeNames[typ])</span>
}

// IsCacheHit check if the message is from the client side cache
func (m *ValkeyMessage) IsCacheHit() bool <span class="cov0" title="0">{
        return m.attrs == cacheMark
}</span>

// CacheTTL returns the remaining TTL in seconds of client side cache
func (m *ValkeyMessage) CacheTTL() (ttl int64) <span class="cov0" title="0">{
        milli := m.CachePTTL()
        if milli &gt; 0 </span><span class="cov0" title="0">{
                if ttl = milli / 1000; milli &gt; ttl*1000 </span><span class="cov0" title="0">{
                        ttl++
                }</span>
                <span class="cov0" title="0">return ttl</span>
        }
        <span class="cov0" title="0">return milli</span>
}

// CachePTTL returns the remaining PTTL in seconds of client side cache
func (m *ValkeyMessage) CachePTTL() int64 <span class="cov0" title="0">{
        milli := m.getExpireAt()
        if milli == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if milli = milli - time.Now().UnixMilli(); milli &lt; 0 </span><span class="cov0" title="0">{
                milli = 0
        }</span>
        <span class="cov0" title="0">return milli</span>
}

// CachePXAT returns the remaining PXAT in seconds of client side cache
func (m *ValkeyMessage) CachePXAT() int64 <span class="cov0" title="0">{
        milli := m.getExpireAt()
        if milli == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">return milli</span>
}

func (m *ValkeyMessage) relativePTTL(now time.Time) int64 <span class="cov0" title="0">{
        return m.getExpireAt() - now.UnixMilli()
}</span>

func (m *ValkeyMessage) getExpireAt() int64 <span class="cov0" title="0">{
        return int64(m.ttl[0]) | int64(m.ttl[1])&lt;&lt;8 | int64(m.ttl[2])&lt;&lt;16 | int64(m.ttl[3])&lt;&lt;24 |
                int64(m.ttl[4])&lt;&lt;32 | int64(m.ttl[5])&lt;&lt;40 | int64(m.ttl[6])&lt;&lt;48
}</span>

func (m *ValkeyMessage) setExpireAt(pttl int64) <span class="cov0" title="0">{
        m.ttl[0] = byte(pttl)
        m.ttl[1] = byte(pttl &gt;&gt; 8)
        m.ttl[2] = byte(pttl &gt;&gt; 16)
        m.ttl[3] = byte(pttl &gt;&gt; 24)
        m.ttl[4] = byte(pttl &gt;&gt; 32)
        m.ttl[5] = byte(pttl &gt;&gt; 40)
        m.ttl[6] = byte(pttl &gt;&gt; 48)
}</span>

func toMap(values []ValkeyMessage) (map[string]ValkeyMessage, error) <span class="cov8" title="1">{
        r := make(map[string]ValkeyMessage, len(values)/2)
        for i := 0; i &lt; len(values); i += 2 </span><span class="cov8" title="1">{
                if values[i].typ == typeBlobString || values[i].typ == typeSimpleString </span><span class="cov8" title="1">{
                        r[values[i].string()] = values[i+1]
                        continue</span>
                }
                <span class="cov0" title="0">typ := values[i].typ
                return nil, fmt.Errorf("%w: valkey message type %s as map key is not supported", errParse, typeNames[typ])</span>
        }
        <span class="cov8" title="1">return r, nil</span>
}

func (m *ValkeyMessage) approximateSize() (s int) <span class="cov0" title="0">{
        s += messageStructSize
        s += len(m.string())
        for _, v := range m.values() </span><span class="cov0" title="0">{
                s += v.approximateSize()
        }</span>
        <span class="cov0" title="0">return</span>
}

// String returns the human-readable representation of ValkeyMessage
func (m *ValkeyMessage) String() string <span class="cov0" title="0">{
        v, _ := (*prettyValkeyMessage)(m).MarshalJSON()
        return string(v)
}</span>

type prettyValkeyMessage ValkeyMessage

func (m *prettyValkeyMessage) string() string <span class="cov0" title="0">{
        if m.bytes == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return unsafe.String(m.bytes, m.intlen)</span>
}

func (m *prettyValkeyMessage) values() []ValkeyMessage <span class="cov0" title="0">{
        if m.array == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return unsafe.Slice(m.array, m.intlen)</span>
}

// MarshalJSON implements json.Marshaler interface
func (m *prettyValkeyMessage) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type PrettyValkeyMessage struct {
                Value any    `json:"Value,omitempty"`
                Type  string `json:"Type,omitempty"`
                Error string `json:"Error,omitempty"`
                Ttl   string `json:"TTL,omitempty"`
        }
        org := (*ValkeyMessage)(m)
        strType, ok := typeNames[m.typ]
        if !ok </span><span class="cov0" title="0">{
                strType = "unknown"
        }</span>
        <span class="cov0" title="0">obj := PrettyValkeyMessage{Type: strType}
        if m.ttl != [7]byte{} </span><span class="cov0" title="0">{
                obj.Ttl = time.UnixMilli(org.CachePXAT()).UTC().String()
        }</span>
        <span class="cov0" title="0">if err := org.Error(); err != nil </span><span class="cov0" title="0">{
                obj.Error = err.Error()
        }</span>
        <span class="cov0" title="0">switch m.typ </span>{
        case typeFloat, typeBlobString, typeSimpleString, typeVerbatimString, typeBigNumber:<span class="cov0" title="0">
                obj.Value = m.string()</span>
        case typeBool:<span class="cov0" title="0">
                obj.Value = m.intlen == 1</span>
        case typeInteger:<span class="cov0" title="0">
                obj.Value = m.intlen</span>
        case typeMap, typeSet, typeArray:<span class="cov0" title="0">
                values := make([]prettyValkeyMessage, len(m.values()))
                for i, value := range m.values() </span><span class="cov0" title="0">{
                        values[i] = prettyValkeyMessage(value)
                }</span>
                <span class="cov0" title="0">obj.Value = values</span>
        }
        <span class="cov0" title="0">return json.Marshal(obj)</span>
}

func slicemsg(typ byte, values []ValkeyMessage) ValkeyMessage <span class="cov8" title="1">{
        return ValkeyMessage{
                typ:    typ,
                array:  unsafe.SliceData(values),
                intlen: int64(len(values)),
        }
}</span>

func strmsg(typ byte, value string) ValkeyMessage <span class="cov8" title="1">{
        return ValkeyMessage{
                typ:    typ,
                bytes:  unsafe.StringData(value),
                intlen: int64(len(value)),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package valkey

import (
        "context"
        "net"
        "runtime"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/valkey-io/valkey-go/internal/cmds"
        "github.com/valkey-io/valkey-go/internal/util"
)

type connFn func(dst string, opt *ClientOption) conn
type dialFn func(ctx context.Context, dst string, opt *ClientOption) (net.Conn, error)
type wireFn func(ctx context.Context) wire

type singleconnect struct {
        w wire
        e error
        g sync.WaitGroup
}

type conn interface {
        Do(ctx context.Context, cmd Completed) ValkeyResult
        DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) ValkeyResult
        DoMulti(ctx context.Context, multi ...Completed) *valkeyresults
        DoMultiCache(ctx context.Context, multi ...CacheableTTL) *valkeyresults
        Receive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error
        DoStream(ctx context.Context, cmd Completed) ValkeyResultStream
        DoMultiStream(ctx context.Context, multi ...Completed) MultiValkeyResultStream
        Info() map[string]ValkeyMessage
        Version() int
        AZ() string
        Error() error
        Close()
        Dial() error
        Override(conn)
        Acquire(ctx context.Context) wire
        Store(w wire)
        Addr() string
        SetOnCloseHook(func(error))
        OptInCmd() cmds.Completed
}

var _ conn = (*mux)(nil)

type muxwire struct {
        wire atomic.Value
        sc   *singleconnect
        mu   sync.Mutex
}

type mux struct {
        init     wire
        dead     wire
        clhks    atomic.Value
        dpool    *pool
        spool    *pool
        wireFn   wireFn
        dst      string
        muxwires []muxwire
        maxp     int
        maxm     int

        usePool bool
        optIn   bool
}

func makeMux(dst string, option *ClientOption, dialFn dialFn) *mux <span class="cov8" title="1">{
        dead := deadFn()
        connFn := func(ctx context.Context) (net.Conn, error) </span><span class="cov8" title="1">{
                return dialFn(ctx, dst, option)
        }</span>
        <span class="cov8" title="1">wireFn := func(pipeFn pipeFn) func(context.Context) wire </span><span class="cov8" title="1">{
                return func(ctx context.Context) (w wire) </span><span class="cov8" title="1">{
                        w, err := pipeFn(ctx, connFn, option)
                        if err != nil </span><span class="cov0" title="0">{
                                dead.error.Store(&amp;errs{error: err})
                                w = dead
                        }</span>
                        <span class="cov8" title="1">return w</span>
                }
        }
        <span class="cov8" title="1">return newMux(dst, option, (*pipe)(nil), dead, wireFn(newPipe), wireFn(newPipeNoBg))</span>
}

func newMux(dst string, option *ClientOption, init, dead wire, wireFn wireFn, wireNoBgFn wireFn) *mux <span class="cov8" title="1">{
        var multiplex int
        if option.PipelineMultiplex &gt;= 0 </span><span class="cov8" title="1">{
                multiplex = 1 &lt;&lt; option.PipelineMultiplex
        }</span> else<span class="cov0" title="0"> {
                multiplex = 1
        }</span>
        <span class="cov8" title="1">m := &amp;mux{dst: dst, init: init, dead: dead, wireFn: wireFn,
                muxwires: make([]muxwire, multiplex),
                maxp:     runtime.GOMAXPROCS(0),
                maxm:     option.BlockingPipeline,

                usePool: option.DisableAutoPipelining,
                optIn:   isOptIn(option.ClientTrackingOptions),
        }
        m.clhks.Store(emptyclhks)
        for i := 0; i &lt; len(m.muxwires); i++ </span><span class="cov8" title="1">{
                m.muxwires[i].wire.Store(init)
        }</span>

        <span class="cov8" title="1">m.dpool = newPool(option.BlockingPoolSize, dead, option.BlockingPoolCleanup, option.BlockingPoolMinSize, wireFn)
        m.spool = newPool(option.BlockingPoolSize, dead, option.BlockingPoolCleanup, option.BlockingPoolMinSize, wireNoBgFn)
        return m</span>
}

func isOptIn(opts []string) bool <span class="cov8" title="1">{
        for _, opt := range opts </span><span class="cov0" title="0">{
                if opt := strings.ToUpper(opt); opt == "BCAST" || opt == "OPTOUT" </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (m *mux) OptInCmd() cmds.Completed <span class="cov0" title="0">{
        if m.optIn </span><span class="cov0" title="0">{
                return cmds.OptInCmd
        }</span>
        <span class="cov0" title="0">return cmds.OptInNopCmd</span>
}

func (m *mux) SetOnCloseHook(fn func(error)) <span class="cov0" title="0">{
        m.clhks.Store(fn)
}</span>

func (m *mux) setCloseHookOnWire(i uint16, w wire) <span class="cov8" title="1">{
        if w != m.dead &amp;&amp; w != m.init </span><span class="cov8" title="1">{
                w.SetOnCloseHook(func(err error) </span><span class="cov8" title="1">{
                        if err != ErrClosing </span><span class="cov8" title="1">{
                                if m.muxwires[i].wire.CompareAndSwap(w, m.init) </span><span class="cov0" title="0">{
                                        m.clhks.Load().(func(error))(err)
                                }</span>
                        }
                })
        }
}

func (m *mux) Override(cc conn) <span class="cov0" title="0">{
        if m2, ok := cc.(*mux); ok </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(m.muxwires) &amp;&amp; i &lt; len(m2.muxwires); i++ </span><span class="cov0" title="0">{
                        w := m2.muxwires[i].wire.Load().(wire)
                        m.setCloseHookOnWire(uint16(i), w) // bind the new m to the old w
                        m.muxwires[i].wire.CompareAndSwap(m.init, w)
                }</span>
        }
}

func (m *mux) _pipe(ctx context.Context, i uint16) (w wire, err error) <span class="cov8" title="1">{
        if w = m.muxwires[i].wire.Load().(wire); w != m.init </span><span class="cov0" title="0">{
                return w, nil
        }</span>

        <span class="cov8" title="1">m.muxwires[i].mu.Lock()
        sc := m.muxwires[i].sc
        if m.muxwires[i].sc == nil </span><span class="cov8" title="1">{
                m.muxwires[i].sc = &amp;singleconnect{}
                m.muxwires[i].sc.g.Add(1)
        }</span>
        <span class="cov8" title="1">m.muxwires[i].mu.Unlock()

        if sc != nil </span><span class="cov0" title="0">{
                sc.g.Wait()
                return sc.w, sc.e
        }</span>

        <span class="cov8" title="1">if w = m.muxwires[i].wire.Load().(wire); w == m.init </span><span class="cov8" title="1">{
                if w = m.wireFn(ctx); w != m.dead </span><span class="cov8" title="1">{
                        m.setCloseHookOnWire(i, w)
                        m.muxwires[i].wire.Store(w)
                }</span> else<span class="cov0" title="0"> {
                        if err = w.Error(); err != ErrClosing </span><span class="cov0" title="0">{
                                m.clhks.Load().(func(error))(err)
                        }</span>
                }
        }

        <span class="cov8" title="1">m.muxwires[i].mu.Lock()
        sc = m.muxwires[i].sc
        m.muxwires[i].sc = nil
        m.muxwires[i].mu.Unlock()

        sc.w = w
        sc.e = err
        sc.g.Done()

        return w, err</span>
}

func (m *mux) pipe(ctx context.Context, i uint16) wire <span class="cov0" title="0">{
        w, _ := m._pipe(ctx, i)
        return w // this should never be nil
}</span>

func (m *mux) Dial() error <span class="cov8" title="1">{
        _, err := m._pipe(context.Background(), 0)
        return err
}</span>

func (m *mux) Info() map[string]ValkeyMessage <span class="cov0" title="0">{
        return m.pipe(context.Background(), 0).Info()
}</span>

func (m *mux) Version() int <span class="cov0" title="0">{
        return m.pipe(context.Background(), 0).Version()
}</span>

func (m *mux) AZ() string <span class="cov0" title="0">{
        return m.pipe(context.Background(), 0).AZ()
}</span>

func (m *mux) Error() error <span class="cov0" title="0">{
        return m.pipe(context.Background(), 0).Error()
}</span>

func (m *mux) DoStream(ctx context.Context, cmd Completed) ValkeyResultStream <span class="cov0" title="0">{
        wire := m.spool.Acquire(ctx)
        return wire.DoStream(ctx, m.spool, cmd)
}</span>

func (m *mux) DoMultiStream(ctx context.Context, multi ...Completed) MultiValkeyResultStream <span class="cov0" title="0">{
        wire := m.spool.Acquire(ctx)
        return wire.DoMultiStream(ctx, m.spool, multi...)
}</span>

func (m *mux) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        if m.usePool &amp;&amp; !cmd.IsPipe() </span><span class="cov0" title="0">{
                resp = m.blocking(m.spool, ctx, cmd)
        }</span> else<span class="cov0" title="0"> if cmd.IsBlock() </span><span class="cov0" title="0">{
                resp = m.blocking(m.dpool, ctx, cmd)
        }</span> else<span class="cov0" title="0"> {
                resp = m.pipeline(ctx, cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (m *mux) DoMulti(ctx context.Context, multi ...Completed) (resp *valkeyresults) <span class="cov0" title="0">{
        for _, cmd := range multi </span><span class="cov0" title="0">{
                if cmd.IsPipe() </span><span class="cov0" title="0">{
                        return m.pipelineMulti(ctx, multi)
                }</span>
                <span class="cov0" title="0">if cmd.IsBlock() </span><span class="cov0" title="0">{
                        cmds.ToBlock(&amp;multi[0]) // mark the first cmd as blocked if one of them is blocked to shortcut later check.
                        goto block</span>
                }
        }
        <span class="cov0" title="0">if m.usePool || (len(multi) &gt;= m.maxm &amp;&amp; m.maxm &gt; 0) </span><span class="cov0" title="0">{
                goto block</span> // use a dedicated connection if the pipeline is too large
        }
        <span class="cov0" title="0">return m.pipelineMulti(ctx, multi)
</span>block:
        <span class="cov0" title="0">if m.usePool </span><span class="cov0" title="0">{
                return m.blockingMulti(m.spool, ctx, multi)
        }</span>
        <span class="cov0" title="0">return m.blockingMulti(m.dpool, ctx, multi)</span>
}

func (m *mux) blocking(pool *pool, ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        wire := pool.Acquire(ctx)
        resp = wire.Do(ctx, cmd)
        if resp.NonValkeyError() != nil </span><span class="cov0" title="0">{ // abort the wire if blocking command return early (ex. context.DeadlineExceeded)
                wire.Close()
        }</span>
        <span class="cov0" title="0">pool.Store(wire)
        return resp</span>
}

func (m *mux) blockingMulti(pool *pool, ctx context.Context, cmd []Completed) (resp *valkeyresults) <span class="cov0" title="0">{
        wire := pool.Acquire(ctx)
        resp = wire.DoMulti(ctx, cmd...)
        for _, res := range resp.s </span><span class="cov0" title="0">{
                if res.NonValkeyError() != nil </span><span class="cov0" title="0">{ // abort the wire if blocking command return early (ex. context.DeadlineExceeded)
                        wire.Close()
                        break</span>
                }
        }
        <span class="cov0" title="0">pool.Store(wire)
        return resp</span>
}

func (m *mux) pipeline(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        slot := slotfn(len(m.muxwires), cmd.Slot(), cmd.NoReply())
        wire := m.pipe(ctx, slot)
        if resp = wire.Do(ctx, cmd); isBroken(resp.NonValkeyError(), wire) </span><span class="cov0" title="0">{
                m.muxwires[slot].wire.CompareAndSwap(wire, m.init)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (m *mux) pipelineMulti(ctx context.Context, cmd []Completed) (resp *valkeyresults) <span class="cov0" title="0">{
        slot := slotfn(len(m.muxwires), cmd[0].Slot(), cmd[0].NoReply())
        wire := m.pipe(ctx, slot)
        resp = wire.DoMulti(ctx, cmd...)
        for _, r := range resp.s </span><span class="cov0" title="0">{
                if isBroken(r.NonValkeyError(), wire) </span><span class="cov0" title="0">{
                        m.muxwires[slot].wire.CompareAndSwap(wire, m.init)
                        return resp
                }</span>
        }
        <span class="cov0" title="0">return resp</span>
}

func (m *mux) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) ValkeyResult <span class="cov0" title="0">{
        slot := cmd.Slot() &amp; uint16(len(m.muxwires)-1)
        wire := m.pipe(ctx, slot)
        resp := wire.DoCache(ctx, cmd, ttl)
        if isBroken(resp.NonValkeyError(), wire) </span><span class="cov0" title="0">{
                m.muxwires[slot].wire.CompareAndSwap(wire, m.init)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (m *mux) DoMultiCache(ctx context.Context, multi ...CacheableTTL) (results *valkeyresults) <span class="cov0" title="0">{
        var slots *muxslots
        var mask = uint16(len(m.muxwires) - 1)

        if mask == 0 </span><span class="cov0" title="0">{
                return m.doMultiCache(ctx, 0, multi)
        }</span>

        <span class="cov0" title="0">slots = muxslotsp.Get(len(m.muxwires), len(m.muxwires))
        for _, cmd := range multi </span><span class="cov0" title="0">{
                slots.s[cmd.Cmd.Slot()&amp;mask]++
        }</span>

        <span class="cov0" title="0">if slots.LessThen(2) </span><span class="cov0" title="0">{
                return m.doMultiCache(ctx, multi[0].Cmd.Slot()&amp;mask, multi)
        }</span>

        <span class="cov0" title="0">batches := batchcachemaps.Get(len(m.muxwires), len(m.muxwires))
        for slot, count := range slots.s </span><span class="cov0" title="0">{
                if count &gt; 0 </span><span class="cov0" title="0">{
                        batches.m[uint16(slot)] = batchcachep.Get(0, count)
                }</span>
        }
        <span class="cov0" title="0">muxslotsp.Put(slots)

        for i, cmd := range multi </span><span class="cov0" title="0">{
                batch := batches.m[cmd.Cmd.Slot()&amp;mask]
                batch.commands = append(batch.commands, cmd)
                batch.cIndexes = append(batch.cIndexes, i)
        }</span>

        <span class="cov0" title="0">results = resultsp.Get(len(multi), len(multi))
        util.ParallelKeys(m.maxp, batches.m, func(slot uint16) </span><span class="cov0" title="0">{
                batch := batches.m[slot]
                resp := m.doMultiCache(ctx, slot, batch.commands)
                for i, r := range resp.s </span><span class="cov0" title="0">{
                        results.s[batch.cIndexes[i]] = r
                }</span>
                <span class="cov0" title="0">resultsp.Put(resp)</span>
        })

        <span class="cov0" title="0">for _, batch := range batches.m </span><span class="cov0" title="0">{
                batchcachep.Put(batch)
        }</span>
        <span class="cov0" title="0">batchcachemaps.Put(batches)

        return results</span>
}

func (m *mux) doMultiCache(ctx context.Context, slot uint16, multi []CacheableTTL) (resps *valkeyresults) <span class="cov0" title="0">{
        wire := m.pipe(ctx, slot)
        resps = wire.DoMultiCache(ctx, multi...)
        for _, r := range resps.s </span><span class="cov0" title="0">{
                if isBroken(r.NonValkeyError(), wire) </span><span class="cov0" title="0">{
                        m.muxwires[slot].wire.CompareAndSwap(wire, m.init)
                        return resps
                }</span>
        }
        <span class="cov0" title="0">return resps</span>
}

func (m *mux) Receive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error <span class="cov0" title="0">{
        slot := slotfn(len(m.muxwires), subscribe.Slot(), subscribe.NoReply())
        wire := m.pipe(ctx, slot)
        err := wire.Receive(ctx, subscribe, fn)
        if isBroken(err, wire) </span><span class="cov0" title="0">{
                m.muxwires[slot].wire.CompareAndSwap(wire, m.init)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (m *mux) Acquire(ctx context.Context) wire <span class="cov0" title="0">{
        return m.dpool.Acquire(ctx)
}</span>

func (m *mux) Store(w wire) <span class="cov0" title="0">{
        w.SetPubSubHooks(PubSubHooks{})
        w.CleanSubscriptions()
        m.dpool.Store(w)
}</span>

func (m *mux) Close() <span class="cov8" title="1">{
        for i := 0; i &lt; len(m.muxwires); i++ </span><span class="cov8" title="1">{
                if prev := m.muxwires[i].wire.Swap(m.dead).(wire); prev != m.init &amp;&amp; prev != m.dead </span><span class="cov8" title="1">{
                        prev.Close()
                }</span>
        }
        <span class="cov8" title="1">m.dpool.Close()
        m.spool.Close()</span>
}

func (m *mux) Addr() string <span class="cov0" title="0">{
        return m.dst
}</span>

func isBroken(err error, w wire) bool <span class="cov0" title="0">{
        return err != nil &amp;&amp; err != ErrClosing &amp;&amp; w.Error() != nil
}</span>

func slotfn(n int, ks uint16, noreply bool) uint16 <span class="cov0" title="0">{
        if n == 1 || ks == cmds.NoSlot || noreply </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return uint16(util.FastRand(n))</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package valkey

import (
        "bufio"
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "io"
        "net"
        "os"
        "regexp"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/valkey-io/valkey-go/internal/cmds"
)

const LibName = "valkey"
const LibVer = "1.0.63"

var noHello = regexp.MustCompile("unknown command .?(HELLO|hello).?")

// See https://github.com/redis/rueidis/pull/691
func isUnsubReply(msg *ValkeyMessage) bool <span class="cov0" title="0">{
        // ex. NOPERM User limited-user has no permissions to run the 'ping' command
        // ex. LOADING server is loading the dataset in memory
        // ex. BUSY
        if msg.typ == '-' &amp;&amp; (strings.HasPrefix(msg.string(), "LOADING") || strings.HasPrefix(msg.string(), "BUSY") || strings.Contains(msg.string(), "'ping'")) </span><span class="cov0" title="0">{
                msg.typ = '+'
                msg.setString("PONG")
                return true
        }</span>
        <span class="cov0" title="0">return msg.string() == "PONG" || (len(msg.values()) != 0 &amp;&amp; msg.values()[0].string() == "pong")</span>
}

type wire interface {
        Do(ctx context.Context, cmd Completed) ValkeyResult
        DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) ValkeyResult
        DoMulti(ctx context.Context, multi ...Completed) *valkeyresults
        DoMultiCache(ctx context.Context, multi ...CacheableTTL) *valkeyresults
        Receive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error
        DoStream(ctx context.Context, pool *pool, cmd Completed) ValkeyResultStream
        DoMultiStream(ctx context.Context, pool *pool, multi ...Completed) MultiValkeyResultStream
        Info() map[string]ValkeyMessage
        Version() int
        AZ() string
        Error() error
        Close()

        CleanSubscriptions()
        SetPubSubHooks(hooks PubSubHooks) &lt;-chan error
        SetOnCloseHook(fn func(error))
        StopTimer() bool
        ResetTimer() bool
}

var _ wire = (*pipe)(nil)

type pipe struct {
        conn            net.Conn
        clhks           atomic.Value // closed hook, invoked after the conn is closed
        queue           queue
        cache           CacheStore
        pshks           atomic.Pointer[pshks] // pubsub hook, registered by the SetPubSubHooks
        error           atomic.Pointer[errs]
        r               *bufio.Reader
        w               *bufio.Writer
        close           chan struct{}
        onInvalidations func([]ValkeyMessage)
        ssubs           *subs // pubsub smessage subscriptions
        nsubs           *subs // pubsub  message subscriptions
        psubs           *subs // pubsub pmessage subscriptions
        r2p             *r2p
        pingTimer       *time.Timer // timer for background ping
        lftmTimer       *time.Timer // lifetime timer
        info            map[string]ValkeyMessage
        timeout         time.Duration
        pinggap         time.Duration
        maxFlushDelay   time.Duration
        lftm            time.Duration // lifetime
        wrCounter       atomic.Uint64
        version         int32
        blcksig         int32
        state           int32
        bgState         int32
        r2ps            bool // identify this pipe is used for resp2 pubsub or not
        noNoDelay       bool
        optIn           bool
}

type pipeFn func(ctx context.Context, connFn func(ctx context.Context) (net.Conn, error), option *ClientOption) (p *pipe, err error)

func newPipe(ctx context.Context, connFn func(ctx context.Context) (net.Conn, error), option *ClientOption) (p *pipe, err error) <span class="cov8" title="1">{
        return _newPipe(ctx, connFn, option, false, false)
}</span>

func newPipeNoBg(ctx context.Context, connFn func(context.Context) (net.Conn, error), option *ClientOption) (p *pipe, err error) <span class="cov0" title="0">{
        return _newPipe(ctx, connFn, option, false, true)
}</span>

func _newPipe(ctx context.Context, connFn func(context.Context) (net.Conn, error), option *ClientOption, r2ps, nobg bool) (p *pipe, err error) <span class="cov8" title="1">{
        conn, err := connFn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p = &amp;pipe{
                conn: conn,
                r:    bufio.NewReaderSize(conn, option.ReadBufferEachConn),
                w:    bufio.NewWriterSize(conn, option.WriteBufferEachConn),

                timeout:       option.ConnWriteTimeout,
                pinggap:       option.Dialer.KeepAlive,
                maxFlushDelay: option.MaxFlushDelay,
                noNoDelay:     option.DisableTCPNoDelay,

                r2ps:  r2ps,
                optIn: isOptIn(option.ClientTrackingOptions),
        }
        if !nobg </span><span class="cov8" title="1">{
                p.queue = newRing(option.RingScaleEachConn)
                p.nsubs = newSubs()
                p.psubs = newSubs()
                p.ssubs = newSubs()
                p.close = make(chan struct{})
        }</span>
        <span class="cov8" title="1">if !nobg &amp;&amp; !option.DisableCache </span><span class="cov8" title="1">{
                cacheStoreFn := option.NewCacheStoreFn
                if cacheStoreFn == nil </span><span class="cov8" title="1">{
                        cacheStoreFn = newLRU
                }</span>
                <span class="cov8" title="1">p.cache = cacheStoreFn(CacheStoreOption{CacheSizeEachConn: option.CacheSizeEachConn})</span>
        }
        <span class="cov8" title="1">p.pshks.Store(emptypshks)
        p.clhks.Store(emptyclhks)

        username := option.Username
        password := option.Password
        if option.AuthCredentialsFn != nil </span><span class="cov0" title="0">{
                authCredentialsContext := AuthCredentialsContext{
                        Address: conn.RemoteAddr(),
                }
                authCredentials, err := option.AuthCredentialsFn(authCredentialsContext)
                if err != nil </span><span class="cov0" title="0">{
                        p.Close()
                        return nil, err
                }</span>
                <span class="cov0" title="0">username = authCredentials.Username
                password = authCredentials.Password</span>
        }

        <span class="cov8" title="1">helloCmd := []string{"HELLO", "3"}
        if password != "" &amp;&amp; username == "" </span><span class="cov0" title="0">{
                helloCmd = append(helloCmd, "AUTH", "default", password)
        }</span> else<span class="cov8" title="1"> if username != "" </span><span class="cov0" title="0">{
                helloCmd = append(helloCmd, "AUTH", username, password)
        }</span>
        <span class="cov8" title="1">if option.ClientName != "" </span><span class="cov0" title="0">{
                helloCmd = append(helloCmd, "SETNAME", option.ClientName)
        }</span>

        <span class="cov8" title="1">init := make([][]string, 0, 5)
        if option.ClientTrackingOptions == nil </span><span class="cov8" title="1">{
                init = append(init, helloCmd, []string{"CLIENT", "TRACKING", "ON", "OPTIN"})
        }</span> else<span class="cov0" title="0"> {
                init = append(init, helloCmd, append([]string{"CLIENT", "TRACKING", "ON"}, option.ClientTrackingOptions...))
        }</span>
        <span class="cov8" title="1">if option.DisableCache </span><span class="cov0" title="0">{
                init = init[:1]
        }</span>
        <span class="cov8" title="1">if option.SelectDB != 0 </span><span class="cov0" title="0">{
                init = append(init, []string{"SELECT", strconv.Itoa(option.SelectDB)})
        }</span>
        <span class="cov8" title="1">if option.ReplicaOnly &amp;&amp; option.Sentinel.MasterSet == "" </span><span class="cov8" title="1">{
                init = append(init, []string{"READONLY"})
        }</span>
        <span class="cov8" title="1">if option.ClientNoTouch </span><span class="cov0" title="0">{
                init = append(init, []string{"CLIENT", "NO-TOUCH", "ON"})
        }</span>
        <span class="cov8" title="1">if option.ClientNoEvict </span><span class="cov0" title="0">{
                init = append(init, []string{"CLIENT", "NO-EVICT", "ON"})
        }</span>
        <span class="cov8" title="1">if option.Standalone.EnableRedirect </span><span class="cov0" title="0">{
                init = append(init, []string{"CLIENT", "CAPA", "redirect"})
        }</span>

        <span class="cov8" title="1">addClientSetInfoCmds := true
        if len(option.ClientSetInfo) == 2 </span><span class="cov0" title="0">{
                init = append(init, []string{"CLIENT", "SETINFO", "LIB-NAME", option.ClientSetInfo[0]}, []string{"CLIENT", "SETINFO", "LIB-VER", option.ClientSetInfo[1]})
        }</span> else<span class="cov8" title="1"> if option.ClientSetInfo == nil </span><span class="cov8" title="1">{
                init = append(init, []string{"CLIENT", "SETINFO", "LIB-NAME", LibName}, []string{"CLIENT", "SETINFO", "LIB-VER", LibVer})
        }</span> else<span class="cov0" title="0"> {
                addClientSetInfoCmds = false
        }</span>

        <span class="cov8" title="1">timeout := option.Dialer.Timeout
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = DefaultDialTimeout
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        r2 := option.AlwaysRESP2
        if !r2 &amp;&amp; !r2ps </span><span class="cov8" title="1">{
                resp := p.DoMulti(ctx, cmds.NewMultiCompleted(init)...)
                defer resultsp.Put(resp)

                count := len(resp.s)
                if addClientSetInfoCmds </span><span class="cov8" title="1">{
                        // skip error checking on the last CLIENT SETINFO
                        count -= 2
                }</span>

                <span class="cov8" title="1">for i, r := range resp.s[:count] </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                p.info, err = r.AsMap()
                        }</span> else<span class="cov8" title="1"> {
                                err = r.Error()
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                if init[i][0] == "READONLY" </span><span class="cov8" title="1">{
                                        // ignore READONLY command error
                                        continue</span>
                                }
                                <span class="cov0" title="0">if re, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                        if !r2 &amp;&amp; noHello.MatchString(re.string()) </span><span class="cov0" title="0">{
                                                r2 = true
                                                continue</span>
                                        } else<span class="cov0" title="0"> if init[i][0] == "CLIENT" </span><span class="cov0" title="0">{
                                                err = fmt.Errorf("%s: %v\n%w", re.string(), init[i], ErrNoCache)
                                        }</span> else<span class="cov0" title="0"> if r2 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">p.Close()
                                return nil, err</span>
                        }
                }
        }
        <span class="cov8" title="1">if proto := p.info["proto"]; proto.intlen &lt; 3 </span><span class="cov0" title="0">{
                r2 = true
        }</span>
        <span class="cov8" title="1">if !r2 &amp;&amp; !r2ps </span><span class="cov8" title="1">{
                if ver, ok := p.info["version"]; ok </span><span class="cov0" title="0">{
                        if v := strings.Split(ver.string(), "."); len(v) != 0 </span><span class="cov0" title="0">{
                                vv, _ := strconv.ParseInt(v[0], 10, 32)
                                p.version = int32(vv)
                        }</span>
                }
                <span class="cov8" title="1">p.onInvalidations = option.OnInvalidations</span>
        } else<span class="cov0" title="0"> {
                if !option.DisableCache </span><span class="cov0" title="0">{
                        p.Close()
                        return nil, ErrNoCache
                }</span>
                <span class="cov0" title="0">init = init[:0]
                if password != "" &amp;&amp; username == "" </span><span class="cov0" title="0">{
                        init = append(init, []string{"AUTH", password})
                }</span> else<span class="cov0" title="0"> if username != "" </span><span class="cov0" title="0">{
                        init = append(init, []string{"AUTH", username, password})
                }</span>
                <span class="cov0" title="0">helloIndex := len(init)
                init = append(init, []string{"HELLO", "2"})
                if option.ClientName != "" </span><span class="cov0" title="0">{
                        init = append(init, []string{"CLIENT", "SETNAME", option.ClientName})
                }</span>
                <span class="cov0" title="0">if option.SelectDB != 0 </span><span class="cov0" title="0">{
                        init = append(init, []string{"SELECT", strconv.Itoa(option.SelectDB)})
                }</span>
                <span class="cov0" title="0">if option.ReplicaOnly &amp;&amp; option.Sentinel.MasterSet == "" </span><span class="cov0" title="0">{
                        init = append(init, []string{"READONLY"})
                }</span>
                <span class="cov0" title="0">if option.ClientNoTouch </span><span class="cov0" title="0">{
                        init = append(init, []string{"CLIENT", "NO-TOUCH", "ON"})
                }</span>
                <span class="cov0" title="0">if option.ClientNoEvict </span><span class="cov0" title="0">{
                        init = append(init, []string{"CLIENT", "NO-EVICT", "ON"})
                }</span>
                <span class="cov0" title="0">if option.Standalone.EnableRedirect </span><span class="cov0" title="0">{
                        init = append(init, []string{"CLIENT", "CAPA", "redirect"})
                }</span>

                <span class="cov0" title="0">addClientSetInfoCmds := true
                if len(option.ClientSetInfo) == 2 </span><span class="cov0" title="0">{
                        init = append(init, []string{"CLIENT", "SETINFO", "LIB-NAME", option.ClientSetInfo[0]}, []string{"CLIENT", "SETINFO", "LIB-VER", option.ClientSetInfo[1]})
                }</span> else<span class="cov0" title="0"> if option.ClientSetInfo == nil </span><span class="cov0" title="0">{
                        init = append(init, []string{"CLIENT", "SETINFO", "LIB-NAME", LibName}, []string{"CLIENT", "SETINFO", "LIB-VER", LibVer})
                }</span> else<span class="cov0" title="0"> {
                        addClientSetInfoCmds = false
                }</span>

                <span class="cov0" title="0">p.version = 5
                if len(init) != 0 </span><span class="cov0" title="0">{
                        resp := p.DoMulti(ctx, cmds.NewMultiCompleted(init)...)
                        defer resultsp.Put(resp)

                        count := len(resp.s)
                        if addClientSetInfoCmds </span><span class="cov0" title="0">{
                                // skip error checking on the last CLIENT SETINFO
                                count -= 2
                        }</span>

                        <span class="cov0" title="0">for i, r := range resp.s[:count] </span><span class="cov0" title="0">{
                                if init[i][0] == "READONLY" </span><span class="cov0" title="0">{
                                        // ignore READONLY command error
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err = r.Error(); err != nil </span><span class="cov0" title="0">{
                                        if re, ok := err.(*ValkeyError); ok &amp;&amp; noHello.MatchString(re.string()) </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">p.Close()
                                        return nil, err</span>
                                }
                                <span class="cov0" title="0">if i == helloIndex </span><span class="cov0" title="0">{
                                        p.info, err = r.AsMap()
                                }</span>
                        }
                }
                <span class="cov0" title="0">if !r2ps </span><span class="cov0" title="0">{
                        p.r2p = &amp;r2p{
                                f: func(ctx context.Context) (p *pipe, err error) </span><span class="cov0" title="0">{
                                        return _newPipe(ctx, connFn, option, true, nobg)
                                }</span>,
                        }
                }
        }
        <span class="cov8" title="1">if !nobg </span><span class="cov8" title="1">{
                if p.onInvalidations != nil || option.AlwaysPipelining </span><span class="cov0" title="0">{
                        p.background()
                }</span>
                <span class="cov8" title="1">if p.timeout &gt; 0 &amp;&amp; p.pinggap &gt; 0 </span><span class="cov8" title="1">{
                        p.backgroundPing()
                }</span>
        }
        <span class="cov8" title="1">if option.ConnLifetime &gt; 0 </span><span class="cov0" title="0">{
                p.lftm = option.ConnLifetime
                p.lftmTimer = time.AfterFunc(option.ConnLifetime, p.expired)
        }</span>
        <span class="cov8" title="1">return p, nil</span>
}

func (p *pipe) background() <span class="cov8" title="1">{
        if p.queue != nil </span><span class="cov8" title="1">{
                atomic.CompareAndSwapInt32(&amp;p.state, 0, 1)
                if atomic.CompareAndSwapInt32(&amp;p.bgState, 0, 1) </span><span class="cov8" title="1">{
                        go p._background()
                }</span>
        }
}

func (p *pipe) _exit(err error) <span class="cov8" title="1">{
        p.error.CompareAndSwap(nil, &amp;errs{error: err})
        atomic.CompareAndSwapInt32(&amp;p.state, 1, 2) // stop accepting new requests
        _ = p.conn.Close()                         // force both read &amp; write goroutine to exit
        p.StopTimer()
        p.clhks.Load().(func(error))(err)
}</span>

func disableNoDelay(conn net.Conn) <span class="cov0" title="0">{
        if c, ok := conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                conn = c.NetConn()
        }</span>
        <span class="cov0" title="0">if c, ok := conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                c.SetNoDelay(false)
        }</span>
}

func (p *pipe) _background() <span class="cov8" title="1">{
        p.conn.SetDeadline(time.Time{})
        if p.noNoDelay </span><span class="cov0" title="0">{
                disableNoDelay(p.conn)
        }</span>
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                p._exit(p._backgroundWrite())
                close(p.close)
        }</span>()
        <span class="cov8" title="1">{
                p._exit(p._backgroundRead())
                select </span>{
                case &lt;-p.close:<span class="cov0" title="0"></span>
                default:<span class="cov8" title="1">
                        p.incrWaits()
                        go func() </span><span class="cov8" title="1">{
                                &lt;-p.queue.PutOne(cmds.PingCmd) // avoid _backgroundWrite hanging at p.queue.WaitForWrite()
                                p.decrWaits()
                        }</span>()
                }
        }
        <span class="cov8" title="1">if p.pingTimer != nil </span><span class="cov8" title="1">{
                p.pingTimer.Stop()
        }</span>
        <span class="cov8" title="1">err := p.Error()
        p.nsubs.Close()
        p.psubs.Close()
        p.ssubs.Close()
        if old := p.pshks.Swap(emptypshks); old.close != nil </span><span class="cov0" title="0">{
                old.close &lt;- err
                close(old.close)
        }</span>

        <span class="cov8" title="1">var (
                resps []ValkeyResult
                ch    chan ValkeyResult
                cond  *sync.Cond
        )

        // clean up cache and free pending calls
        if p.cache != nil </span><span class="cov8" title="1">{
                p.cache.Close(ErrDoCacheAborted)
        }</span>
        <span class="cov8" title="1">if p.onInvalidations != nil </span><span class="cov0" title="0">{
                p.onInvalidations(nil)
        }</span>

        <span class="cov8" title="1">resp := newErrResult(err)
        for p.loadWaits() != 0 </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-p.close:<span class="cov8" title="1"> // p.queue.NextWriteCmd() can only be called after _backgroundWrite
                        _, _, _ = p.queue.NextWriteCmd()</span>
                default:<span class="cov8" title="1"></span>
                }
                <span class="cov8" title="1">if _, _, ch, resps, cond = p.queue.NextResultCh(); ch != nil </span><span class="cov8" title="1">{
                        for i := range resps </span><span class="cov0" title="0">{
                                resps[i] = resp
                        }</span>
                        <span class="cov8" title="1">ch &lt;- resp
                        cond.L.Unlock()
                        cond.Signal()</span>
                } else<span class="cov8" title="1"> {
                        cond.L.Unlock()
                        cond.Signal()
                        runtime.Gosched()
                }</span>
        }
        <span class="cov8" title="1">&lt;-p.close
        atomic.StoreInt32(&amp;p.state, 4)</span>
}

func (p *pipe) _backgroundWrite() (err error) <span class="cov8" title="1">{
        var (
                ones  = make([]Completed, 1)
                multi []Completed
                ch    chan ValkeyResult

                flushDelay = p.maxFlushDelay
                flushStart = time.Time{}
        )

        for err == nil </span><span class="cov8" title="1">{
                if ones[0], multi, ch = p.queue.NextWriteCmd(); ch == nil </span><span class="cov8" title="1">{
                        if flushDelay != 0 </span><span class="cov0" title="0">{
                                flushStart = time.Now()
                        }</span>
                        <span class="cov8" title="1">if p.w.Buffered() != 0 </span><span class="cov8" title="1">{
                                if err = p.w.Flush(); err != nil </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">ones[0], multi, ch = p.queue.WaitForWrite()
                        if flushDelay != 0 &amp;&amp; p.loadWaits() &gt; 1 </span><span class="cov0" title="0">{ // do not delay for sequential usage
                                // Blocking commands are executed in a dedicated client which is acquired from the pool.
                                // So, there is no sense to wait for other commands to be written.
                                // https://github.com/redis/rueidis/issues/379
                                var blocked bool
                                for i := 0; i &lt; len(multi) &amp;&amp; !blocked; i++ </span><span class="cov0" title="0">{
                                        blocked = multi[i].IsBlock()
                                }</span>
                                <span class="cov0" title="0">if !blocked </span><span class="cov0" title="0">{
                                        time.Sleep(flushDelay - time.Since(flushStart)) // ref: https://github.com/redis/rueidis/issues/156
                                }</span>
                        }
                }
                <span class="cov8" title="1">if ch != nil &amp;&amp; multi == nil </span><span class="cov8" title="1">{
                        multi = ones
                }</span>
                <span class="cov8" title="1">for _, cmd := range multi </span><span class="cov8" title="1">{
                        err = writeCmd(p.w, cmd.Commands())
                        if cmd.IsUnsub() </span><span class="cov0" title="0">{ // See https://github.com/redis/rueidis/pull/691
                                err = writeCmd(p.w, cmds.PingCmd.Commands())
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (p *pipe) _backgroundRead() (err error) <span class="cov8" title="1">{
        var (
                msg   ValkeyMessage
                cond  *sync.Cond
                ones  = make([]Completed, 1)
                multi []Completed
                resps []ValkeyResult
                ch    chan ValkeyResult
                ff    int // fulfilled count
                skip  int // skip the rest push messages
                ver   = p.version
                prply bool // push reply
                unsub bool // unsubscribe notification

                skipUnsubReply bool // if unsubscribe is replied

                r2ps = p.r2ps
        )

        defer func() </span><span class="cov8" title="1">{
                resp := newErrResult(err)
                if e := p.Error(); e == errConnExpired </span><span class="cov0" title="0">{
                        resp = newErrResult(e)
                }</span>
                <span class="cov8" title="1">if err != nil &amp;&amp; ff &lt; len(multi) </span><span class="cov0" title="0">{
                        for ; ff &lt; len(resps); ff++ </span><span class="cov0" title="0">{
                                resps[ff] = resp
                        }</span>
                        <span class="cov0" title="0">ch &lt;- resp
                        cond.L.Unlock()
                        cond.Signal()</span>
                }
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if msg, err = readNextMessage(p.r); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if msg.typ == '&gt;' || (r2ps &amp;&amp; len(msg.values()) != 0 &amp;&amp; msg.values()[0].string() != "pong") </span><span class="cov0" title="0">{
                        if prply, unsub = p.handlePush(msg.values()); !prply </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if skip &gt; 0 </span><span class="cov0" title="0">{
                                skip--
                                prply = false
                                unsub = false
                                continue</span>
                        }
                } else<span class="cov8" title="1"> if ver == 6 &amp;&amp; len(msg.values()) != 0 </span><span class="cov0" title="0">{
                        // This is a workaround for Redis 6's broken invalidation protocol: https://github.com/redis/redis/issues/8935
                        // When Redis 6 handles MULTI, MGET, or other multi-keys command,
                        // it will send invalidation messages immediately if it finds the keys are expired, thus causing the multi-keys command response to be broken.
                        // We fix this by fetching the next message and patching it back to the response.
                        i := 0
                        for j, v := range msg.values() </span><span class="cov0" title="0">{
                                if v.typ == '&gt;' </span><span class="cov0" title="0">{
                                        p.handlePush(v.values())
                                }</span> else<span class="cov0" title="0"> {
                                        if i != j </span><span class="cov0" title="0">{
                                                msg.values()[i] = v
                                        }</span>
                                        <span class="cov0" title="0">i++</span>
                                }
                        }
                        <span class="cov0" title="0">for ; i &lt; len(msg.values()); i++ </span><span class="cov0" title="0">{
                                if msg.values()[i], err = readNextMessage(p.r); err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov8" title="1">if ff == len(multi) </span><span class="cov8" title="1">{
                        ff = 0
                        ones[0], multi, ch, resps, cond = p.queue.NextResultCh() // ch should not be nil; otherwise, it must be a protocol bug
                        if ch == nil </span><span class="cov0" title="0">{
                                cond.L.Unlock()
                                // Valkey will send sunsubscribe notification proactively in the event of slot migration.
                                // We should ignore them and go fetch the next message.
                                // We also treat all the other unsubscribe notifications just like sunsubscribe,
                                // so that we don't need to track how many channels we have subscribed to deal with wildcard unsubscribe command
                                // See https://github.com/redis/rueidis/pull/691
                                if unsub </span><span class="cov0" title="0">{
                                        prply = false
                                        unsub = false
                                        continue</span>
                                }
                                <span class="cov0" title="0">if skipUnsubReply &amp;&amp; isUnsubReply(&amp;msg) </span><span class="cov0" title="0">{
                                        skipUnsubReply = false
                                        continue</span>
                                }
                                <span class="cov0" title="0">panic(protocolbug)</span>
                        }
                        <span class="cov8" title="1">if multi == nil </span><span class="cov8" title="1">{
                                multi = ones
                        }</span>
                } else<span class="cov0" title="0"> if ff &gt;= 4 &amp;&amp; len(msg.values()) &gt;= 2 &amp;&amp; multi[0].IsOptIn() </span><span class="cov0" title="0">{ // if unfulfilled multi commands are lead by opt-in and get a success response
                        now := time.Now()
                        if cacheable := Cacheable(multi[ff-1]); cacheable.IsMGet() </span><span class="cov0" title="0">{
                                cc := cmds.MGetCacheCmd(cacheable)
                                msgs := msg.values()[len(msg.values())-1].values()
                                for i, cp := range msgs </span><span class="cov0" title="0">{
                                        ck := cmds.MGetCacheKey(cacheable, i)
                                        cp.attrs = cacheMark
                                        if pttl := msg.values()[i].intlen; pttl &gt;= 0 </span><span class="cov0" title="0">{
                                                cp.setExpireAt(now.Add(time.Duration(pttl) * time.Millisecond).UnixMilli())
                                        }</span>
                                        <span class="cov0" title="0">msgs[i].setExpireAt(p.cache.Update(ck, cc, cp))</span>
                                }
                        } else<span class="cov0" title="0"> {
                                ck, cc := cmds.CacheKey(cacheable)
                                ci := len(msg.values()) - 1
                                cp := msg.values()[ci]
                                cp.attrs = cacheMark
                                if pttl := msg.values()[ci-1].intlen; pttl &gt;= 0 </span><span class="cov0" title="0">{
                                        cp.setExpireAt(now.Add(time.Duration(pttl) * time.Millisecond).UnixMilli())
                                }</span>
                                <span class="cov0" title="0">msg.values()[ci].setExpireAt(p.cache.Update(ck, cc, cp))</span>
                        }
                }
                <span class="cov8" title="1">if prply </span><span class="cov0" title="0">{
                        // Valkey will send sunsubscribe notification proactively in the event of slot migration.
                        // We should ignore them and go fetch the next message.
                        // We also treat all the other unsubscribe notifications just like sunsubscribe,
                        // so that we don't need to track how many channels we have subscribed to deal with wildcard unsubscribe command
                        // See https://github.com/redis/rueidis/pull/691
                        if unsub </span><span class="cov0" title="0">{
                                prply = false
                                unsub = false
                                continue</span>
                        }
                        <span class="cov0" title="0">prply = false
                        unsub = false
                        if !multi[ff].NoReply() </span><span class="cov0" title="0">{
                                panic(protocolbug)</span>
                        }
                        <span class="cov0" title="0">skip = len(multi[ff].Commands()) - 2
                        msg = ValkeyMessage{}</span> // override successful subscribe/unsubscribe response to empty
                } else<span class="cov8" title="1"> if multi[ff].NoReply() &amp;&amp; msg.string() == "QUEUED" </span><span class="cov0" title="0">{
                        panic(multiexecsub)</span>
                } else<span class="cov8" title="1"> if multi[ff].IsUnsub() &amp;&amp; !isUnsubReply(&amp;msg) </span><span class="cov0" title="0">{
                        // See https://github.com/redis/rueidis/pull/691
                        skipUnsubReply = true
                }</span> else<span class="cov8" title="1"> if skipUnsubReply </span><span class="cov0" title="0">{
                        // See https://github.com/redis/rueidis/pull/691
                        if !isUnsubReply(&amp;msg) </span><span class="cov0" title="0">{
                                panic(protocolbug)</span>
                        }
                        <span class="cov0" title="0">skipUnsubReply = false
                        continue</span>
                }
                <span class="cov8" title="1">resp := newResult(msg, err)
                if resps != nil </span><span class="cov0" title="0">{
                        resps[ff] = resp
                }</span>
                <span class="cov8" title="1">if ff++; ff == len(multi) </span><span class="cov8" title="1">{
                        ch &lt;- resp
                        cond.L.Unlock()
                        cond.Signal()
                }</span>
        }
}

func (p *pipe) backgroundPing() <span class="cov8" title="1">{
        var prev, recv int32

        prev = p.loadRecvs()
        p.pingTimer = time.AfterFunc(p.pinggap, func() </span><span class="cov0" title="0">{
                var err error
                recv = p.loadRecvs()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil &amp;&amp; p.Error() == nil </span><span class="cov0" title="0">{
                                prev = p.loadRecvs()
                                p.pingTimer.Reset(p.pinggap)
                        }</span>
                }()
                <span class="cov0" title="0">if recv != prev || atomic.LoadInt32(&amp;p.blcksig) != 0 || (atomic.LoadInt32(&amp;p.state) == 0 &amp;&amp; p.loadWaits() != 0) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">ch := make(chan error, 1)
                tm := time.NewTimer(p.timeout)
                go func() </span><span class="cov0" title="0">{ ch &lt;- p.Do(context.Background(), cmds.PingCmd).NonValkeyError() }</span>()
                <span class="cov0" title="0">select </span>{
                case &lt;-tm.C:<span class="cov0" title="0">
                        err = os.ErrDeadlineExceeded</span>
                case err = &lt;-ch:<span class="cov0" title="0">
                        tm.Stop()</span>
                }
                <span class="cov0" title="0">if err != nil &amp;&amp; atomic.LoadInt32(&amp;p.blcksig) != 0 </span><span class="cov0" title="0">{
                        err = nil
                }</span>
                <span class="cov0" title="0">if err != nil &amp;&amp; err != ErrClosing </span><span class="cov0" title="0">{
                        p._exit(err)
                }</span>
        })
}

func (p *pipe) handlePush(values []ValkeyMessage) (reply bool, unsubscribe bool) <span class="cov0" title="0">{
        if len(values) &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>
        // TODO: handle other push data
        // tracking-redir-broken
        // server-cpu-usage
        <span class="cov0" title="0">switch values[0].string() </span>{
        case "invalidate":<span class="cov0" title="0">
                if p.cache != nil </span><span class="cov0" title="0">{
                        if values[1].IsNil() </span><span class="cov0" title="0">{
                                p.cache.Delete(nil)
                        }</span> else<span class="cov0" title="0"> {
                                p.cache.Delete(values[1].values())
                        }</span>
                }
                <span class="cov0" title="0">if p.onInvalidations != nil </span><span class="cov0" title="0">{
                        if values[1].IsNil() </span><span class="cov0" title="0">{
                                p.onInvalidations(nil)
                        }</span> else<span class="cov0" title="0"> {
                                p.onInvalidations(values[1].values())
                        }</span>
                }
        case "message":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        m := PubSubMessage{Channel: values[1].string(), Message: values[2].string()}
                        p.nsubs.Publish(values[1].string(), m)
                        p.pshks.Load().hooks.OnMessage(m)
                }</span>
        case "pmessage":<span class="cov0" title="0">
                if len(values) &gt;= 4 </span><span class="cov0" title="0">{
                        m := PubSubMessage{Pattern: values[1].string(), Channel: values[2].string(), Message: values[3].string()}
                        p.psubs.Publish(values[1].string(), m)
                        p.pshks.Load().hooks.OnMessage(m)
                }</span>
        case "smessage":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        m := PubSubMessage{Channel: values[1].string(), Message: values[2].string()}
                        p.ssubs.Publish(values[1].string(), m)
                        p.pshks.Load().hooks.OnMessage(m)
                }</span>
        case "unsubscribe":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        s := PubSubSubscription{Kind: values[0].string(), Channel: values[1].string(), Count: values[2].intlen}
                        p.nsubs.Unsubscribe(s)
                        p.pshks.Load().hooks.OnSubscription(s)
                }</span>
                <span class="cov0" title="0">return true, true</span>
        case "punsubscribe":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        s := PubSubSubscription{Kind: values[0].string(), Channel: values[1].string(), Count: values[2].intlen}
                        p.psubs.Unsubscribe(s)
                        p.pshks.Load().hooks.OnSubscription(s)
                }</span>
                <span class="cov0" title="0">return true, true</span>
        case "sunsubscribe":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        s := PubSubSubscription{Kind: values[0].string(), Channel: values[1].string(), Count: values[2].intlen}
                        p.ssubs.Unsubscribe(s)
                        p.pshks.Load().hooks.OnSubscription(s)
                }</span>
                <span class="cov0" title="0">return true, true</span>
        case "subscribe":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        s := PubSubSubscription{Kind: values[0].string(), Channel: values[1].string(), Count: values[2].intlen}
                        p.nsubs.Confirm(s)
                        p.pshks.Load().hooks.OnSubscription(s)
                }</span>
                <span class="cov0" title="0">return true, false</span>
        case "psubscribe":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        s := PubSubSubscription{Kind: values[0].string(), Channel: values[1].string(), Count: values[2].intlen}
                        p.psubs.Confirm(s)
                        p.pshks.Load().hooks.OnSubscription(s)
                }</span>
                <span class="cov0" title="0">return true, false</span>
        case "ssubscribe":<span class="cov0" title="0">
                if len(values) &gt;= 3 </span><span class="cov0" title="0">{
                        s := PubSubSubscription{Kind: values[0].string(), Channel: values[1].string(), Count: values[2].intlen}
                        p.ssubs.Confirm(s)
                        p.pshks.Load().hooks.OnSubscription(s)
                }</span>
                <span class="cov0" title="0">return true, false</span>
        }
        <span class="cov0" title="0">return false, false</span>
}

type recvCtxKey int

const hookKey recvCtxKey = 0

// WithOnSubscriptionHook attaches a subscription confirmation hook to the provided
// context and returns a new context for the Receive method.
//
// The hook is invoked each time the server sends a subscribe or
// unsubscribe confirmation, allowing callers to observe the state of a Pub/Sub
// subscription during the lifetime of a Receive invocation.
//
// The hook may be called multiple times because the client can resubscribe after a
// reconnection. Therefore, the hook implementation must be safe to run more than once.
// Also, there should not be any blocking operations or another `client.Do()` in the hook
// since it runs in the same goroutine as the pipeline. Otherwise, the pipeline will be blocked.
func WithOnSubscriptionHook(ctx context.Context, hook func(PubSubSubscription)) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, hookKey, hook)
}</span>

func (p *pipe) Receive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error <span class="cov0" title="0">{
        if p.nsubs == nil || p.psubs == nil || p.ssubs == nil </span><span class="cov0" title="0">{
                return p.Error()
        }</span>

        <span class="cov0" title="0">if p.r2p != nil </span><span class="cov0" title="0">{
                return p.r2p.pipe(ctx).Receive(ctx, subscribe, fn)
        }</span>

        <span class="cov0" title="0">cmds.CompletedCS(subscribe).Verify()

        var sb *subs
        cmd, args := subscribe.Commands()[0], subscribe.Commands()[1:]

        switch cmd </span>{
        case "SUBSCRIBE":<span class="cov0" title="0">
                sb = p.nsubs</span>
        case "PSUBSCRIBE":<span class="cov0" title="0">
                sb = p.psubs</span>
        case "SSUBSCRIBE":<span class="cov0" title="0">
                sb = p.ssubs</span>
        default:<span class="cov0" title="0">
                panic(wrongreceive)</span>
        }

        <span class="cov0" title="0">var hook func(PubSubSubscription)
        if v := ctx.Value(hookKey); v != nil </span><span class="cov0" title="0">{
                hook = v.(func(PubSubSubscription))
        }</span>
        <span class="cov0" title="0">if ch, cancel := sb.Subscribe(args, hook); ch != nil </span><span class="cov0" title="0">{
                defer cancel()
                if err := p.Do(ctx, subscribe).Error(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if ctxCh := ctx.Done(); ctxCh == nil </span><span class="cov0" title="0">{
                        for msg := range ch </span><span class="cov0" title="0">{
                                fn(msg)
                        }</span>
                } else<span class="cov0" title="0"> {
                next:
                        select </span>{
                        case msg, ok := &lt;-ch:<span class="cov0" title="0">
                                if ok </span><span class="cov0" title="0">{
                                        fn(msg)
                                        goto next</span>
                                }
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                }
        }
        <span class="cov0" title="0">return p.Error()</span>
}

func (p *pipe) CleanSubscriptions() <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;p.blcksig) != 0 </span><span class="cov0" title="0">{
                p.Close()
        }</span> else<span class="cov0" title="0"> if atomic.LoadInt32(&amp;p.state) == 1 </span><span class="cov0" title="0">{
                if p.version &gt;= 7 </span><span class="cov0" title="0">{
                        p.DoMulti(context.Background(), cmds.UnsubscribeCmd, cmds.PUnsubscribeCmd, cmds.SUnsubscribeCmd, cmds.DiscardCmd)
                }</span> else<span class="cov0" title="0"> {
                        p.DoMulti(context.Background(), cmds.UnsubscribeCmd, cmds.PUnsubscribeCmd, cmds.DiscardCmd)
                }</span>
        }
}

func (p *pipe) SetPubSubHooks(hooks PubSubHooks) &lt;-chan error <span class="cov0" title="0">{
        if p.r2p != nil </span><span class="cov0" title="0">{
                return p.r2p.pipe(context.Background()).SetPubSubHooks(hooks)
        }</span>
        <span class="cov0" title="0">if hooks.isZero() </span><span class="cov0" title="0">{
                if old := p.pshks.Swap(emptypshks); old.close != nil </span><span class="cov0" title="0">{
                        close(old.close)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if hooks.OnMessage == nil </span><span class="cov0" title="0">{
                hooks.OnMessage = func(m PubSubMessage) </span>{<span class="cov0" title="0">}</span>
        }
        <span class="cov0" title="0">if hooks.OnSubscription == nil </span><span class="cov0" title="0">{
                hooks.OnSubscription = func(s PubSubSubscription) </span>{<span class="cov0" title="0">}</span>
        }
        <span class="cov0" title="0">ch := make(chan error, 1)
        if old := p.pshks.Swap(&amp;pshks{hooks: hooks, close: ch}); old.close != nil </span><span class="cov0" title="0">{
                close(old.close)
        }</span>
        <span class="cov0" title="0">if err := p.Error(); err != nil </span><span class="cov0" title="0">{
                if old := p.pshks.Swap(emptypshks); old.close != nil </span><span class="cov0" title="0">{
                        old.close &lt;- err
                        close(old.close)
                }</span>
        }
        <span class="cov0" title="0">if p.incrWaits() == 1 &amp;&amp; atomic.LoadInt32(&amp;p.state) == 0 </span><span class="cov0" title="0">{
                p.background()
        }</span>
        <span class="cov0" title="0">p.decrWaits()
        return ch</span>
}

func (p *pipe) SetOnCloseHook(fn func(error)) <span class="cov8" title="1">{
        p.clhks.Store(fn)
}</span>

func (p *pipe) Info() map[string]ValkeyMessage <span class="cov0" title="0">{
        return p.info
}</span>

func (p *pipe) Version() int <span class="cov0" title="0">{
        return int(p.version)
}</span>

func (p *pipe) AZ() string <span class="cov0" title="0">{
        infoAvailabilityZone := p.info["availability_zone"]
        return infoAvailabilityZone.string()
}</span>

func (p *pipe) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return newErrResult(err)
        }</span>

        <span class="cov0" title="0">cmds.CompletedCS(cmd).Verify()
        if cmd.IsBlock() </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;p.blcksig, 1)
                defer func() </span><span class="cov0" title="0">{
                        if resp.err == nil </span><span class="cov0" title="0">{
                                atomic.AddInt32(&amp;p.blcksig, -1)
                        }</span>
                }()
        }

        <span class="cov0" title="0">if cmd.NoReply() </span><span class="cov0" title="0">{
                if p.r2p != nil </span><span class="cov0" title="0">{
                        return p.r2p.pipe(ctx).Do(ctx, cmd)
                }</span>
        }
        <span class="cov0" title="0">waits := p.incrWaits() // if this is 1, and the background worker is not started, no need to queue
        state := atomic.LoadInt32(&amp;p.state)

        if state == 1 </span><span class="cov0" title="0">{
                goto queue</span>
        }

        <span class="cov0" title="0">if state == 0 </span><span class="cov0" title="0">{
                if waits != 1 </span><span class="cov0" title="0">{
                        goto queue</span>
                }
                <span class="cov0" title="0">if cmd.NoReply() </span><span class="cov0" title="0">{
                        p.background()
                        goto queue</span>
                }
                <span class="cov0" title="0">dl, ok := ctx.Deadline()
                if p.queue != nil &amp;&amp; !ok &amp;&amp; ctx.Done() != nil </span><span class="cov0" title="0">{
                        p.background()
                        goto queue</span>
                }
                <span class="cov0" title="0">resp = p.syncDo(dl, ok, cmd)</span>
        } else<span class="cov0" title="0"> {
                resp = newErrResult(p.Error())
        }</span>

        <span class="cov0" title="0">if left := p.decrWaitsAndIncrRecvs(); state == 0 &amp;&amp; left != 0 </span><span class="cov0" title="0">{
                p.background()
        }</span>
        <span class="cov0" title="0">return resp

</span>queue:
        <span class="cov0" title="0">ch := p.queue.PutOne(cmd)
        if ctxCh := ctx.Done(); ctxCh == nil </span><span class="cov0" title="0">{
                resp = &lt;-ch
        }</span> else<span class="cov0" title="0"> {
                select </span>{
                case resp = &lt;-ch:<span class="cov0" title="0"></span>
                case &lt;-ctxCh:<span class="cov0" title="0">
                        goto abort</span>
                }
        }
        <span class="cov0" title="0">p.decrWaitsAndIncrRecvs()
        return resp
</span>abort:
        <span class="cov0" title="0">go func(ch chan ValkeyResult) </span><span class="cov0" title="0">{
                &lt;-ch
                p.decrWaitsAndIncrRecvs()
        }</span>(ch)
        <span class="cov0" title="0">return newErrResult(ctx.Err())</span>
}

func (p *pipe) DoMulti(ctx context.Context, multi ...Completed) *valkeyresults <span class="cov8" title="1">{
        resp := resultsp.Get(len(multi), len(multi))
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(resp.s); i++ </span><span class="cov0" title="0">{
                        resp.s[i] = newErrResult(err)
                }</span>
                <span class="cov0" title="0">return resp</span>
        }

        <span class="cov8" title="1">cmds.CompletedCS(multi[0]).Verify()

        isOptIn := multi[0].IsOptIn() // len(multi) &gt; 0 should have already been checked by the upper layer
        noReply := 0

        for _, cmd := range multi </span><span class="cov8" title="1">{
                if cmd.NoReply() </span><span class="cov0" title="0">{
                        noReply++
                }</span>
        }

        <span class="cov8" title="1">if p.version &lt; 6 &amp;&amp; noReply != 0 </span><span class="cov0" title="0">{
                if noReply != len(multi) </span><span class="cov0" title="0">{
                        for i := 0; i &lt; len(resp.s); i++ </span><span class="cov0" title="0">{
                                resp.s[i] = newErrResult(ErrRESP2PubSubMixed)
                        }</span>
                        <span class="cov0" title="0">return resp</span>
                } else<span class="cov0" title="0"> if p.r2p != nil </span><span class="cov0" title="0">{
                        resultsp.Put(resp)
                        return p.r2p.pipe(ctx).DoMulti(ctx, multi...)
                }</span>
        }

        <span class="cov8" title="1">for _, cmd := range multi </span><span class="cov8" title="1">{
                if cmd.IsBlock() </span><span class="cov0" title="0">{
                        if noReply != 0 </span><span class="cov0" title="0">{
                                for i := 0; i &lt; len(resp.s); i++ </span><span class="cov0" title="0">{
                                        resp.s[i] = newErrResult(ErrBlockingPubSubMixed)
                                }</span>
                                <span class="cov0" title="0">return resp</span>
                        }
                        <span class="cov0" title="0">atomic.AddInt32(&amp;p.blcksig, 1)
                        defer func() </span><span class="cov0" title="0">{
                                for _, r := range resp.s </span><span class="cov0" title="0">{
                                        if r.err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                                <span class="cov0" title="0">atomic.AddInt32(&amp;p.blcksig, -1)</span>
                        }()
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov8" title="1">waits := p.incrWaits() // if this is 1, and the background worker is not started, no need to queue
        state := atomic.LoadInt32(&amp;p.state)

        if state == 1 </span><span class="cov0" title="0">{
                goto queue</span>
        }

        <span class="cov8" title="1">if state == 0 </span><span class="cov8" title="1">{
                if waits != 1 </span><span class="cov0" title="0">{
                        goto queue</span>
                }
                <span class="cov8" title="1">if isOptIn || noReply != 0 </span><span class="cov0" title="0">{
                        p.background()
                        goto queue</span>
                }
                <span class="cov8" title="1">dl, ok := ctx.Deadline()
                if p.queue != nil &amp;&amp; !ok &amp;&amp; ctx.Done() != nil </span><span class="cov0" title="0">{
                        p.background()
                        goto queue</span>
                }
                <span class="cov8" title="1">p.syncDoMulti(dl, ok, resp.s, multi)</span>
        } else<span class="cov0" title="0"> {
                err := newErrResult(p.Error())
                for i := 0; i &lt; len(resp.s); i++ </span><span class="cov0" title="0">{
                        resp.s[i] = err
                }</span>
        }
        <span class="cov8" title="1">if left := p.decrWaitsAndIncrRecvs(); state == 0 &amp;&amp; left != 0 </span><span class="cov0" title="0">{
                p.background()
        }</span>
        <span class="cov8" title="1">return resp

</span>queue:
        <span class="cov0" title="0">ch := p.queue.PutMulti(multi, resp.s)
        if ctxCh := ctx.Done(); ctxCh == nil </span><span class="cov0" title="0">{
                &lt;-ch
        }</span> else<span class="cov0" title="0"> {
                select </span>{
                case &lt;-ch:<span class="cov0" title="0"></span>
                case &lt;-ctxCh:<span class="cov0" title="0">
                        goto abort</span>
                }
        }
        <span class="cov0" title="0">p.decrWaitsAndIncrRecvs()
        return resp
</span>abort:
        <span class="cov0" title="0">go func(resp *valkeyresults, ch chan ValkeyResult) </span><span class="cov0" title="0">{
                &lt;-ch
                resultsp.Put(resp)
                p.decrWaitsAndIncrRecvs()
        }</span>(resp, ch)
        <span class="cov0" title="0">resp = resultsp.Get(len(multi), len(multi))
        err := newErrResult(ctx.Err())
        for i := 0; i &lt; len(resp.s); i++ </span><span class="cov0" title="0">{
                resp.s[i] = err
        }</span>
        <span class="cov0" title="0">return resp</span>
}

type MultiValkeyResultStream = ValkeyResultStream

type ValkeyResultStream struct {
        p *pool
        w *pipe
        e error
        n int
}

// HasNext can be used in a for loop condition to check if a further WriteTo call is needed.
func (s *ValkeyResultStream) HasNext() bool <span class="cov0" title="0">{
        return s.n &gt; 0 &amp;&amp; s.e == nil
}</span>

// Error returns the error happened when sending commands to valkey or reading response from valkey.
// Usually a user is not required to use this function because the error is also reported by the WriteTo.
func (s *ValkeyResultStream) Error() error <span class="cov0" title="0">{
        return s.e
}</span>

// WriteTo reads a valkey response from valkey and then write it to the given writer.
// This function is not thread-safe and should be called sequentially to read multiple responses.
// An io.EOF error will be reported if all responses are read.
func (s *ValkeyResultStream) WriteTo(w io.Writer) (n int64, err error) <span class="cov0" title="0">{
        if err = s.e; err == nil &amp;&amp; s.n &gt; 0 </span><span class="cov0" title="0">{
                var clean bool
                if n, err, clean = streamTo(s.w.r, w); !clean </span><span class="cov0" title="0">{
                        s.e = err // err must not be nil in case of !clean
                        s.n = 1
                }</span>
                <span class="cov0" title="0">if s.n--; s.n == 0 </span><span class="cov0" title="0">{
                        atomic.AddInt32(&amp;s.w.blcksig, -1)
                        s.w.decrWaits()
                        if s.e == nil </span><span class="cov0" title="0">{
                                s.e = io.EOF
                        }</span> else<span class="cov0" title="0"> {
                                s.w.Close()
                        }</span>
                        <span class="cov0" title="0">s.p.Store(s.w)</span>
                }
        }
        <span class="cov0" title="0">return n, err</span>
}

func (p *pipe) DoStream(ctx context.Context, pool *pool, cmd Completed) ValkeyResultStream <span class="cov0" title="0">{
        cmds.CompletedCS(cmd).Verify()

        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return ValkeyResultStream{e: err}
        }</span>

        <span class="cov0" title="0">state := atomic.LoadInt32(&amp;p.state)

        if state == 1 </span><span class="cov0" title="0">{
                panic("DoStream with auto pipelining is a bug")</span>
        }

        <span class="cov0" title="0">if state == 0 </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;p.blcksig, 1)
                waits := p.incrWaits()
                if waits != 1 </span><span class="cov0" title="0">{
                        panic("DoStream with racing is a bug")</span>
                }
                <span class="cov0" title="0">dl, ok := ctx.Deadline()
                if ok </span><span class="cov0" title="0">{
                        if p.timeout &gt; 0 &amp;&amp; !cmd.IsBlock() </span><span class="cov0" title="0">{
                                defaultDeadline := time.Now().Add(p.timeout)
                                if dl.After(defaultDeadline) </span><span class="cov0" title="0">{
                                        dl = defaultDeadline
                                }</span>
                        }
                        <span class="cov0" title="0">p.conn.SetDeadline(dl)</span>
                } else<span class="cov0" title="0"> if p.timeout &gt; 0 &amp;&amp; !cmd.IsBlock() </span><span class="cov0" title="0">{
                        p.conn.SetDeadline(time.Now().Add(p.timeout))
                }</span> else<span class="cov0" title="0"> {
                        p.conn.SetDeadline(time.Time{})
                }</span>
                <span class="cov0" title="0">_ = writeCmd(p.w, cmd.Commands())
                if err := p.w.Flush(); err != nil </span><span class="cov0" title="0">{
                        p.error.CompareAndSwap(nil, &amp;errs{error: err})
                        p.conn.Close()
                        p.background() // start the background worker to clean up goroutines
                }</span> else<span class="cov0" title="0"> {
                        return ValkeyResultStream{p: pool, w: p, n: 1}
                }</span>
        }
        <span class="cov0" title="0">atomic.AddInt32(&amp;p.blcksig, -1)
        p.decrWaits()
        pool.Store(p)
        return ValkeyResultStream{e: p.Error()}</span>
}

func (p *pipe) DoMultiStream(ctx context.Context, pool *pool, multi ...Completed) MultiValkeyResultStream <span class="cov0" title="0">{
        for _, cmd := range multi </span><span class="cov0" title="0">{
                cmds.CompletedCS(cmd).Verify()
        }</span>

        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return ValkeyResultStream{e: err}
        }</span>

        <span class="cov0" title="0">state := atomic.LoadInt32(&amp;p.state)

        if state == 1 </span><span class="cov0" title="0">{
                panic("DoMultiStream with auto pipelining is a bug")</span>
        }

        <span class="cov0" title="0">if state == 0 </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;p.blcksig, 1)
                waits := p.incrWaits()
                if waits != 1 </span><span class="cov0" title="0">{
                        panic("DoMultiStream with racing is a bug")</span>
                }
                <span class="cov0" title="0">dl, ok := ctx.Deadline()
                if ok </span><span class="cov0" title="0">{
                        if p.timeout &gt; 0 </span><span class="cov0" title="0">{
                                for _, cmd := range multi </span><span class="cov0" title="0">{
                                        if cmd.IsBlock() </span><span class="cov0" title="0">{
                                                p.conn.SetDeadline(dl)
                                                goto process</span>
                                        }
                                }
                                <span class="cov0" title="0">defaultDeadline := time.Now().Add(p.timeout)
                                if dl.After(defaultDeadline) </span><span class="cov0" title="0">{
                                        dl = defaultDeadline
                                }</span>
                        }
                        <span class="cov0" title="0">p.conn.SetDeadline(dl)</span>
                } else<span class="cov0" title="0"> if p.timeout &gt; 0 </span><span class="cov0" title="0">{
                        for _, cmd := range multi </span><span class="cov0" title="0">{
                                if cmd.IsBlock() </span><span class="cov0" title="0">{
                                        p.conn.SetDeadline(time.Time{})
                                        goto process</span>
                                }
                        }
                        <span class="cov0" title="0">p.conn.SetDeadline(time.Now().Add(p.timeout))</span>
                } else<span class="cov0" title="0"> {
                        p.conn.SetDeadline(time.Time{})
                }</span>
        <span class="cov0" title="0">process:
                for _, cmd := range multi </span><span class="cov0" title="0">{
                        _ = writeCmd(p.w, cmd.Commands())
                }</span>
                <span class="cov0" title="0">if err := p.w.Flush(); err != nil </span><span class="cov0" title="0">{
                        p.error.CompareAndSwap(nil, &amp;errs{error: err})
                        p.conn.Close()
                        p.background() // start the background worker to clean up goroutines
                }</span> else<span class="cov0" title="0"> {
                        return ValkeyResultStream{p: pool, w: p, n: len(multi)}
                }</span>
        }
        <span class="cov0" title="0">atomic.AddInt32(&amp;p.blcksig, -1)
        p.decrWaits()
        pool.Store(p)
        return ValkeyResultStream{e: p.Error()}</span>
}

func (p *pipe) syncDo(dl time.Time, dlOk bool, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        if dlOk </span><span class="cov0" title="0">{
                if p.timeout &gt; 0 &amp;&amp; !cmd.IsBlock() </span><span class="cov0" title="0">{
                        defaultDeadline := time.Now().Add(p.timeout)
                        if dl.After(defaultDeadline) </span><span class="cov0" title="0">{
                                dl = defaultDeadline
                                dlOk = false
                        }</span>
                }
                <span class="cov0" title="0">p.conn.SetDeadline(dl)</span>
        } else<span class="cov0" title="0"> if p.timeout &gt; 0 &amp;&amp; !cmd.IsBlock() </span><span class="cov0" title="0">{
                p.conn.SetDeadline(time.Now().Add(p.timeout))
        }</span> else<span class="cov0" title="0"> {
                p.conn.SetDeadline(time.Time{})
        }</span>

        <span class="cov0" title="0">var msg ValkeyMessage
        err := flushCmd(p.w, cmd.Commands())
        if err == nil </span><span class="cov0" title="0">{
                msg, err = syncRead(p.r)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if dlOk &amp;&amp; errors.Is(err, os.ErrDeadlineExceeded) </span><span class="cov0" title="0">{
                        err = context.DeadlineExceeded
                }</span>
                <span class="cov0" title="0">p.error.CompareAndSwap(nil, &amp;errs{error: err})
                p.conn.Close()
                p.background()</span> // start the background worker to clean up goroutines
        }
        <span class="cov0" title="0">return newResult(msg, err)</span>
}

func (p *pipe) syncDoMulti(dl time.Time, dlOk bool, resp []ValkeyResult, multi []Completed) <span class="cov8" title="1">{
        if dlOk </span><span class="cov8" title="1">{
                if p.timeout &gt; 0 </span><span class="cov8" title="1">{
                        for _, cmd := range multi </span><span class="cov8" title="1">{
                                if cmd.IsBlock() </span><span class="cov0" title="0">{
                                        p.conn.SetDeadline(dl)
                                        goto process</span>
                                }
                        }
                        <span class="cov8" title="1">defaultDeadline := time.Now().Add(p.timeout)
                        if dl.After(defaultDeadline) </span><span class="cov0" title="0">{
                                dl = defaultDeadline
                                dlOk = false
                        }</span>
                }
                <span class="cov8" title="1">p.conn.SetDeadline(dl)</span>
        } else<span class="cov0" title="0"> if p.timeout &gt; 0 </span><span class="cov0" title="0">{
                for _, cmd := range multi </span><span class="cov0" title="0">{
                        if cmd.IsBlock() </span><span class="cov0" title="0">{
                                p.conn.SetDeadline(time.Time{})
                                goto process</span>
                        }
                }
                <span class="cov0" title="0">p.conn.SetDeadline(time.Now().Add(p.timeout))</span>
        } else<span class="cov0" title="0"> {
                p.conn.SetDeadline(time.Time{})
        }</span>
process:
        <span class="cov8" title="1">var err error
        var msg ValkeyMessage
        for _, cmd := range multi </span><span class="cov8" title="1">{
                _ = writeCmd(p.w, cmd.Commands())
        }</span>
        <span class="cov8" title="1">if err = p.w.Flush(); err != nil </span><span class="cov0" title="0">{
                goto abort</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(resp); i++ </span><span class="cov8" title="1">{
                if msg, err = syncRead(p.r); err != nil </span><span class="cov0" title="0">{
                        goto abort</span>
                }
                <span class="cov8" title="1">resp[i] = newResult(msg, err)</span>
        }
        <span class="cov8" title="1">return
</span>abort:
        <span class="cov0" title="0">if dlOk &amp;&amp; errors.Is(err, os.ErrDeadlineExceeded) </span><span class="cov0" title="0">{
                err = context.DeadlineExceeded
        }</span>
        <span class="cov0" title="0">p.error.CompareAndSwap(nil, &amp;errs{error: err})
        p.conn.Close()
        p.background() // start the background worker to clean up goroutines
        for i := 0; i &lt; len(resp); i++ </span><span class="cov0" title="0">{
                resp[i] = newErrResult(err)
        }</span>
}

func syncRead(r *bufio.Reader) (m ValkeyMessage, err error) <span class="cov8" title="1">{
</span>next:
        <span class="cov8" title="1">if m, err = readNextMessage(r); err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>
        <span class="cov8" title="1">if m.typ == '&gt;' </span><span class="cov0" title="0">{
                goto next</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

func (p *pipe) optInCmd() cmds.Completed <span class="cov0" title="0">{
        if p.optIn </span><span class="cov0" title="0">{
                return cmds.OptInCmd
        }</span>
        <span class="cov0" title="0">return cmds.OptInNopCmd</span>
}

func (p *pipe) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) ValkeyResult <span class="cov0" title="0">{
        if p.cache == nil </span><span class="cov0" title="0">{
                return p.Do(ctx, Completed(cmd))
        }</span>

        <span class="cov0" title="0">cmds.CacheableCS(cmd).Verify()

        if cmd.IsMGet() </span><span class="cov0" title="0">{
                return p.doCacheMGet(ctx, cmd, ttl)
        }</span>
        <span class="cov0" title="0">ck, cc := cmds.CacheKey(cmd)
        now := time.Now()
        if v, entry := p.cache.Flight(ck, cc, ttl, now); v.typ != 0 </span><span class="cov0" title="0">{
                return newResult(v, nil)
        }</span> else<span class="cov0" title="0"> if entry != nil </span><span class="cov0" title="0">{
                return newResult(entry.Wait(ctx))
        }</span>
        <span class="cov0" title="0">resp := p.DoMulti(
                ctx,
                p.optInCmd(),
                cmds.MultiCmd,
                cmds.NewCompleted([]string{"PTTL", ck}),
                Completed(cmd),
                cmds.ExecCmd,
        )
        defer resultsp.Put(resp)
        exec, err := resp.s[4].ToArray()
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                        err = ErrDoCacheAborted
                        if preErr := resp.s[3].Error(); preErr != nil </span><span class="cov0" title="0">{ // if {cmd} get a ValkeyError
                                if _, ok := preErr.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                        err = preErr
                                }</span>
                        }
                }
                <span class="cov0" title="0">p.cache.Cancel(ck, cc, err)
                return newErrResult(err)</span>
        }
        <span class="cov0" title="0">return newResult(exec[1], nil)</span>
}

func (p *pipe) doCacheMGet(ctx context.Context, cmd Cacheable, ttl time.Duration) ValkeyResult <span class="cov0" title="0">{
        commands := cmd.Commands()
        keys := len(commands) - 1
        builder := cmds.NewBuilder(cmds.InitSlot)
        result := ValkeyResult{val: ValkeyMessage{typ: '*'}}
        mgetcc := cmds.MGetCacheCmd(cmd)
        if mgetcc[0] == 'J' </span><span class="cov0" title="0">{
                keys-- // the last one of JSON.MGET is a path, not a key
        }</span>
        <span class="cov0" title="0">entries := entriesp.Get(keys, keys)
        defer entriesp.Put(entries)
        var now = time.Now()
        var rewrite cmds.Arbitrary
        for i, key := range commands[1 : keys+1] </span><span class="cov0" title="0">{
                v, entry := p.cache.Flight(key, mgetcc, ttl, now)
                if v.typ != 0 </span><span class="cov0" title="0">{ // cache hit for one key
                        if len(result.val.values()) == 0 </span><span class="cov0" title="0">{
                                result.val.setValues(make([]ValkeyMessage, keys))

                        }</span>
                        <span class="cov0" title="0">result.val.values()[i] = v
                        continue</span>
                }
                <span class="cov0" title="0">if entry != nil </span><span class="cov0" title="0">{
                        entries.e[i] = entry // store entries for later entry.Wait() to avoid MGET deadlock each others.
                        continue</span>
                }
                <span class="cov0" title="0">if rewrite.IsZero() </span><span class="cov0" title="0">{
                        rewrite = builder.Arbitrary(commands[0])
                }</span>
                <span class="cov0" title="0">rewrite = rewrite.Args(key)</span>
        }

        <span class="cov0" title="0">var partial []ValkeyMessage
        if !rewrite.IsZero() </span><span class="cov0" title="0">{
                var rewritten Completed
                var keys int
                if mgetcc[0] == 'J' </span><span class="cov0" title="0">{ // rewrite JSON.MGET path
                        rewritten = rewrite.Args(commands[len(commands)-1]).MultiGet()
                        keys = len(rewritten.Commands()) - 2
                }</span> else<span class="cov0" title="0"> {
                        rewritten = rewrite.MultiGet()
                        keys = len(rewritten.Commands()) - 1
                }</span>

                <span class="cov0" title="0">multi := make([]Completed, 0, keys+4)
                multi = append(multi, p.optInCmd(), cmds.MultiCmd)
                for _, key := range rewritten.Commands()[1 : keys+1] </span><span class="cov0" title="0">{
                        multi = append(multi, builder.Pttl().Key(key).Build())
                }</span>
                <span class="cov0" title="0">multi = append(multi, rewritten, cmds.ExecCmd)

                resp := p.DoMulti(ctx, multi...)
                defer resultsp.Put(resp)
                exec, err := resp.s[len(multi)-1].ToArray()
                if err != nil </span><span class="cov0" title="0">{
                        if _, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                err = ErrDoCacheAborted
                                if preErr := resp.s[len(multi)-2].Error(); preErr != nil </span><span class="cov0" title="0">{ // if {rewritten} get a ValkeyError
                                        if _, ok := preErr.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                                err = preErr
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">for _, key := range rewritten.Commands()[1 : keys+1] </span><span class="cov0" title="0">{
                                p.cache.Cancel(key, mgetcc, err)
                        }</span>
                        <span class="cov0" title="0">return newErrResult(err)</span>
                }
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        for _, cmd := range multi[2 : len(multi)-1] </span><span class="cov0" title="0">{
                                cmds.PutCompleted(cmd)
                        }</span>
                }()
                <span class="cov0" title="0">last := len(exec) - 1
                if len(rewritten.Commands()) == len(commands) </span><span class="cov0" title="0">{ // all cache misses
                        return newResult(exec[last], nil)
                }</span>
                <span class="cov0" title="0">partial = exec[last].values()</span>
        } else<span class="cov0" title="0"> { // all cache hit
                result.val.attrs = cacheMark
        }</span>

        <span class="cov0" title="0">if len(result.val.values()) == 0 </span><span class="cov0" title="0">{
                result.val.setValues(make([]ValkeyMessage, keys))
        }</span>
        <span class="cov0" title="0">for i, entry := range entries.e </span><span class="cov0" title="0">{
                v, err := entry.Wait(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return newErrResult(err)
                }</span>
                <span class="cov0" title="0">result.val.values()[i] = v</span>
        }

        <span class="cov0" title="0">j := 0
        for _, ret := range partial </span><span class="cov0" title="0">{
                for ; j &lt; len(result.val.values()); j++ </span><span class="cov0" title="0">{
                        if result.val.values()[j].typ == 0 </span><span class="cov0" title="0">{
                                result.val.values()[j] = ret
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return result</span>
}

func (p *pipe) DoMultiCache(ctx context.Context, multi ...CacheableTTL) *valkeyresults <span class="cov0" title="0">{
        if p.cache == nil </span><span class="cov0" title="0">{
                commands := make([]Completed, len(multi))
                for i, ct := range multi </span><span class="cov0" title="0">{
                        commands[i] = Completed(ct.Cmd)
                }</span>
                <span class="cov0" title="0">return p.DoMulti(ctx, commands...)</span>
        }

        <span class="cov0" title="0">cmds.CacheableCS(multi[0].Cmd).Verify()

        results := resultsp.Get(len(multi), len(multi))
        entries := entriesp.Get(len(multi), len(multi))
        defer entriesp.Put(entries)
        var missing []Completed
        now := time.Now()
        for _, ct := range multi </span><span class="cov0" title="0">{
                if ct.Cmd.IsMGet() </span><span class="cov0" title="0">{
                        panic(panicmgetcsc)</span>
                }
        }
        <span class="cov0" title="0">if cache, ok := p.cache.(*lru); ok </span><span class="cov0" title="0">{
                missed := cache.Flights(now, multi, results.s, entries.e)
                for _, i := range missed </span><span class="cov0" title="0">{
                        ct := multi[i]
                        ck, _ := cmds.CacheKey(ct.Cmd)
                        missing = append(missing, p.optInCmd(), cmds.MultiCmd, cmds.NewCompleted([]string{"PTTL", ck}), Completed(ct.Cmd), cmds.ExecCmd)
                }</span>
        } else<span class="cov0" title="0"> {
                for i, ct := range multi </span><span class="cov0" title="0">{
                        ck, cc := cmds.CacheKey(ct.Cmd)
                        v, entry := p.cache.Flight(ck, cc, ct.TTL, now)
                        if v.typ != 0 </span><span class="cov0" title="0">{ // cache hit for one key
                                results.s[i] = newResult(v, nil)
                                continue</span>
                        }
                        <span class="cov0" title="0">if entry != nil </span><span class="cov0" title="0">{
                                entries.e[i] = entry // store entries for later entry.Wait() to avoid MGET deadlock each others.
                                continue</span>
                        }
                        <span class="cov0" title="0">missing = append(missing, p.optInCmd(), cmds.MultiCmd, cmds.NewCompleted([]string{"PTTL", ck}), Completed(ct.Cmd), cmds.ExecCmd)</span>
                }
        }

        <span class="cov0" title="0">var resp *valkeyresults
        if len(missing) &gt; 0 </span><span class="cov0" title="0">{
                resp = p.DoMulti(ctx, missing...)
                defer resultsp.Put(resp)
                for i := 4; i &lt; len(resp.s); i += 5 </span><span class="cov0" title="0">{
                        if err := resp.s[i].Error(); err != nil </span><span class="cov0" title="0">{
                                if _, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                        err = ErrDoCacheAborted
                                        if preErr := resp.s[i-1].Error(); preErr != nil </span><span class="cov0" title="0">{ // if {cmd} get a ValkeyError
                                                if _, ok := preErr.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                                        err = preErr
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">ck, cc := cmds.CacheKey(Cacheable(missing[i-1]))
                                p.cache.Cancel(ck, cc, err)</span>
                        }
                }
        }

        <span class="cov0" title="0">for i, entry := range entries.e </span><span class="cov0" title="0">{
                results.s[i] = newResult(entry.Wait(ctx))
        }</span>

        <span class="cov0" title="0">if len(missing) == 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        <span class="cov0" title="0">j := 0
        for i := 4; i &lt; len(resp.s); i += 5 </span><span class="cov0" title="0">{
                for ; j &lt; len(results.s); j++ </span><span class="cov0" title="0">{
                        if results.s[j].val.typ == 0 &amp;&amp; results.s[j].err == nil </span><span class="cov0" title="0">{
                                exec, err := resp.s[i].ToArray()
                                if err != nil </span><span class="cov0" title="0">{
                                        if _, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                                err = ErrDoCacheAborted
                                                if preErr := resp.s[i-1].Error(); preErr != nil </span><span class="cov0" title="0">{ // if {cmd} get a ValkeyError
                                                        if _, ok := preErr.(*ValkeyError); ok </span><span class="cov0" title="0">{
                                                                err = preErr
                                                        }</span>
                                                }
                                        }
                                        <span class="cov0" title="0">results.s[j] = newErrResult(err)</span>
                                } else<span class="cov0" title="0"> {
                                        results.s[j] = newResult(exec[len(exec)-1], nil)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }
        <span class="cov0" title="0">return results</span>
}

// incrWaits increments the lower 32 bits (waits).
func (p *pipe) incrWaits() uint32 <span class="cov8" title="1">{
        // Increment the lower 32 bits (waits)
        return uint32(p.wrCounter.Add(1))
}</span>

const (
        decrLo       = ^uint64(0)
        decrLoIncrHi = uint64(1&lt;&lt;32) - 1
)

// decrWaits decrements the lower 32 bits (waits).
func (p *pipe) decrWaits() uint32 <span class="cov8" title="1">{
        // Decrement the lower 32 bits (waits)
        return uint32(p.wrCounter.Add(decrLo))
}</span>

// decrWaitsAndIncrRecvs decrements the lower 32 bits (waits) and increments the upper 32 bits (recvs).
func (p *pipe) decrWaitsAndIncrRecvs() uint32 <span class="cov8" title="1">{
        newValue := p.wrCounter.Add(decrLoIncrHi)
        return uint32(newValue)
}</span>

// loadRecvs loads the upper 32 bits (recvs).
func (p *pipe) loadRecvs() int32 <span class="cov8" title="1">{
        // Load the upper 32 bits (recvs)
        return int32(p.wrCounter.Load() &gt;&gt; 32)
}</span>

// loadWaits loads the lower 32 bits (waits).
func (p *pipe) loadWaits() uint32 <span class="cov8" title="1">{
        // Load the lower 32 bits (waits)
        return uint32(p.wrCounter.Load())
}</span>

func (p *pipe) Error() error <span class="cov8" title="1">{
        if err := p.error.Load(); err != nil </span><span class="cov8" title="1">{
                return err.error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *pipe) Close() <span class="cov8" title="1">{
        p.error.CompareAndSwap(nil, errClosing)
        block := atomic.AddInt32(&amp;p.blcksig, 1)
        waits := p.incrWaits()
        stopping1 := atomic.CompareAndSwapInt32(&amp;p.state, 0, 2)
        stopping2 := atomic.CompareAndSwapInt32(&amp;p.state, 1, 2)
        if p.queue != nil </span><span class="cov8" title="1">{
                if stopping1 &amp;&amp; waits == 1 </span><span class="cov8" title="1">{ // make sure there is no sync read
                        p.background()
                }</span>
                <span class="cov8" title="1">if block == 1 &amp;&amp; (stopping1 || stopping2) </span><span class="cov8" title="1">{ // make sure there is no block cmd
                        p.incrWaits()
                        ch := p.queue.PutOne(cmds.PingCmd)
                        select </span>{
                        case &lt;-ch:<span class="cov8" title="1">
                                p.decrWaits()</span>
                        case &lt;-time.After(time.Second):<span class="cov0" title="0">
                                go func(ch chan ValkeyResult) </span><span class="cov0" title="0">{
                                        &lt;-ch
                                        p.decrWaits()
                                }</span>(ch)
                        }
                }
        }
        <span class="cov8" title="1">p.decrWaits()
        atomic.AddInt32(&amp;p.blcksig, -1)
        if p.pingTimer != nil </span><span class="cov8" title="1">{
                p.pingTimer.Stop()
        }</span>
        <span class="cov8" title="1">if p.conn != nil </span><span class="cov8" title="1">{
                p.conn.Close()
        }</span>
        <span class="cov8" title="1">if p.r2p != nil </span><span class="cov0" title="0">{
                p.r2p.Close()
        }</span>
}

func (p *pipe) StopTimer() bool <span class="cov8" title="1">{
        if p.lftmTimer == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return p.lftmTimer.Stop()</span>
}

func (p *pipe) ResetTimer() bool <span class="cov0" title="0">{
        if p.lftmTimer == nil || p.Error() != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return p.lftmTimer.Reset(p.lftm)</span>
}

func (p *pipe) expired() <span class="cov0" title="0">{
        p.error.CompareAndSwap(nil, errExpired)
        p.Close()
}</span>

type r2p struct {
        f func(context.Context) (p *pipe, err error) // func to build pipe for resp2 pubsub
        p *pipe                                      // internal pipe for resp2 pubsub only
        m sync.RWMutex
}

func (r *r2p) pipe(ctx context.Context) (r2p *pipe) <span class="cov0" title="0">{
        r.m.RLock()
        r2p = r.p
        r.m.RUnlock()
        if r2p == nil </span><span class="cov0" title="0">{
                r.m.Lock()
                if r.p != nil </span><span class="cov0" title="0">{
                        r2p = r.p
                }</span> else<span class="cov0" title="0"> {
                        var err error
                        if r2p, err = r.f(ctx); err != nil </span><span class="cov0" title="0">{
                                r2p = epipeFn(err)
                        }</span> else<span class="cov0" title="0"> {
                                r.p = r2p
                        }</span>
                }
                <span class="cov0" title="0">r.m.Unlock()</span>
        }
        <span class="cov0" title="0">return r2p</span>
}

func (r *r2p) Close() <span class="cov0" title="0">{
        r.m.RLock()
        if r.p != nil </span><span class="cov0" title="0">{
                r.p.Close()
        }</span>
        <span class="cov0" title="0">r.m.RUnlock()</span>
}

type pshks struct {
        hooks PubSubHooks
        close chan error
}

var emptypshks = &amp;pshks{
        hooks: PubSubHooks{
                OnMessage:      func(m PubSubMessage) {<span class="cov0" title="0">}</span>,
                OnSubscription: func(s PubSubSubscription) {<span class="cov0" title="0">}</span>,
        },
        close: nil,
}

var emptyclhks = func(error) {<span class="cov0" title="0">}</span>

func deadFn() *pipe <span class="cov8" title="1">{
        dead := &amp;pipe{state: 3}
        dead.error.Store(errClosing)
        dead.pshks.Store(emptypshks)
        dead.clhks.Store(emptyclhks)
        return dead
}</span>

func epipeFn(err error) *pipe <span class="cov0" title="0">{
        dead := &amp;pipe{state: 3}
        dead.error.Store(&amp;errs{error: err})
        dead.pshks.Store(emptypshks)
        dead.clhks.Store(emptyclhks)
        return dead
}</span>

const (
        protocolbug  = "protocol bug, message handled out of order"
        wrongreceive = "only SUBSCRIBE, SSUBSCRIBE, or PSUBSCRIBE command are allowed in Receive"
        multiexecsub = "SUBSCRIBE/UNSUBSCRIBE are not allowed in MULTI/EXEC block"
        panicmgetcsc = "MGET and JSON.MGET in DoMultiCache are not implemented, use DoCache instead"
)

var cacheMark = &amp;(ValkeyMessage{})
var (
        errClosing = &amp;errs{error: ErrClosing}
        errExpired = &amp;errs{error: errConnExpired}
)

type errs struct{ error }
</pre>
		
		<pre class="file" id="file11" style="display: none">package valkey

import (
        "context"
        "errors"
        "sync"
        "time"
)

// errAcquireComplete is a special error used to indicate that the Acquire operation has completed successfully
var errAcquireComplete = errors.New("acquire complete")

func newPool(cap int, dead wire, cleanup time.Duration, minSize int, makeFn func(context.Context) wire) *pool <span class="cov8" title="1">{
        if cap &lt;= 0 </span><span class="cov8" title="1">{
                cap = DefaultPoolSize
        }</span>

        <span class="cov8" title="1">return &amp;pool{
                size:    0,
                minSize: minSize,
                cap:     cap,
                dead:    dead,
                make:    makeFn,
                list:    make([]wire, 0, 4),
                cond:    sync.NewCond(&amp;sync.Mutex{}),
                cleanup: cleanup,
        }</span>
}

type pool struct {
        dead    wire
        cond    *sync.Cond
        timer   *time.Timer
        make    func(ctx context.Context) wire
        list    []wire
        cleanup time.Duration
        size    int
        minSize int
        cap     int
        down    bool
        timerOn bool
}

func (p *pool) Acquire(ctx context.Context) (v wire) <span class="cov0" title="0">{
        p.cond.L.Lock()

        // Set up ctx handling when waiting for an available connection
        if len(p.list) == 0 &amp;&amp; p.size == p.cap &amp;&amp; !p.down &amp;&amp; ctx.Err() == nil &amp;&amp; ctx.Done() != nil </span><span class="cov0" title="0">{
                poolCtx, cancel := context.WithCancelCause(ctx)
                defer cancel(errAcquireComplete)

                go func() </span><span class="cov0" title="0">{
                        &lt;-poolCtx.Done()
                        if context.Cause(poolCtx) != errAcquireComplete </span><span class="cov0" title="0">{ // no need to broadcast if the poolCtx is cancelled explicitly.
                                p.cond.Broadcast()
                        }</span>
                }()
        }

<span class="cov0" title="0">retry:
        for len(p.list) == 0 &amp;&amp; p.size == p.cap &amp;&amp; !p.down &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                p.cond.Wait()
        }</span>

        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                deadPipe := deadFn()
                deadPipe.error.Store(&amp;errs{error: ctx.Err()})
                v = deadPipe
                p.cond.L.Unlock()
                return v
        }</span>

        <span class="cov0" title="0">if p.down </span><span class="cov0" title="0">{
                v = p.dead
                p.cond.L.Unlock()
                return v
        }</span>
        <span class="cov0" title="0">if len(p.list) == 0 </span><span class="cov0" title="0">{
                p.size++
                // unlock before start to make a new wire
                // allowing others to make wires concurrently instead of waiting in line
                p.cond.L.Unlock()
                v = p.make(ctx)
                v.StopTimer()
                return v
        }</span>

        <span class="cov0" title="0">i := len(p.list) - 1
        v = p.list[i]
        p.list[i] = nil
        p.list = p.list[:i]
        if !v.StopTimer() || v.Error() != nil </span><span class="cov0" title="0">{
                p.size--
                v.Close()
                goto retry</span>
        }
        <span class="cov0" title="0">p.cond.L.Unlock()
        return v</span>
}

func (p *pool) Store(v wire) <span class="cov0" title="0">{
        p.cond.L.Lock()
        if !p.down &amp;&amp; v.Error() == nil </span><span class="cov0" title="0">{
                p.list = append(p.list, v)
                p.startTimerIfNeeded()
                v.ResetTimer()
        }</span> else<span class="cov0" title="0"> {
                p.size--
                v.Close()
        }</span>
        <span class="cov0" title="0">p.cond.L.Unlock()
        p.cond.Signal()</span>
}

func (p *pool) Close() <span class="cov8" title="1">{
        p.cond.L.Lock()
        p.down = true
        p.stopTimer()
        for _, w := range p.list </span><span class="cov0" title="0">{
                w.Close()
        }</span>
        <span class="cov8" title="1">p.cond.L.Unlock()
        p.cond.Broadcast()</span>
}

func (p *pool) startTimerIfNeeded() <span class="cov0" title="0">{
        if p.cleanup == 0 || p.timerOn || len(p.list) &lt;= p.minSize </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.timerOn = true
        if p.timer == nil </span><span class="cov0" title="0">{
                p.timer = time.AfterFunc(p.cleanup, p.removeIdleConns)
        }</span> else<span class="cov0" title="0"> {
                p.timer.Reset(p.cleanup)
        }</span>
}

func (p *pool) removeIdleConns() <span class="cov0" title="0">{
        p.cond.L.Lock()
        defer p.cond.L.Unlock()

        newLen := min(p.minSize, len(p.list))
        for i, w := range p.list[newLen:] </span><span class="cov0" title="0">{
                w.Close()
                p.list[newLen+i] = nil
                p.size--
        }</span>

        <span class="cov0" title="0">p.list = p.list[:newLen]
        p.timerOn = false</span>
}

func (p *pool) stopTimer() <span class="cov8" title="1">{
        p.timerOn = false
        if p.timer != nil </span><span class="cov0" title="0">{
                p.timer.Stop()
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package valkey

import (
        "sync"
        "sync/atomic"
)

// PubSubMessage represents a pubsub message from valkey
type PubSubMessage struct {
        // Pattern is only available with pmessage.
        Pattern string
        // Channel is the channel the message belongs to
        Channel string
        // Message is the message content
        Message string
}

// PubSubSubscription represent a pubsub "subscribe", "unsubscribe", "ssubscribe", "sunsubscribe", "psubscribe" or "punsubscribe" event.
type PubSubSubscription struct {
        // Kind is "subscribe", "unsubscribe", "ssubscribe", "sunsubscribe", "psubscribe" or "punsubscribe"
        Kind string
        // Channel is the event subject.
        Channel string
        // Count is the current number of subscriptions for a connection.
        Count int64
}

// PubSubHooks can be registered into DedicatedClient to process pubsub messages without using Client.Receive
type PubSubHooks struct {
        // OnMessage will be called when receiving "message" and "pmessage" event.
        OnMessage func(m PubSubMessage)
        // OnSubscription will be called when receiving "subscribe", "unsubscribe", "psubscribe" and "punsubscribe" event.
        OnSubscription func(s PubSubSubscription)
}

func (h *PubSubHooks) isZero() bool <span class="cov0" title="0">{
        return h.OnMessage == nil &amp;&amp; h.OnSubscription == nil
}</span>

func newSubs() *subs <span class="cov8" title="1">{
        return &amp;subs{chs: make(map[string]chs), sub: make(map[uint64]*sub)}
}</span>

type subs struct {
        chs map[string]chs
        sub map[uint64]*sub
        cnt uint64
        mu  sync.RWMutex
}

type chs struct {
        sub map[uint64]*sub
}

type sub struct {
        ch chan PubSubMessage
        fn func(PubSubSubscription)
        cs []string
}

func (s *subs) Publish(channel string, msg PubSubMessage) <span class="cov0" title="0">{
        if atomic.LoadUint64(&amp;s.cnt) != 0 </span><span class="cov0" title="0">{
                s.mu.RLock()
                for _, sb := range s.chs[channel].sub </span><span class="cov0" title="0">{
                        sb.ch &lt;- msg
                }</span>
                <span class="cov0" title="0">s.mu.RUnlock()</span>
        }
}

func (s *subs) Subscribe(channels []string, fn func(PubSubSubscription)) (ch chan PubSubMessage, cancel func()) <span class="cov0" title="0">{
        id := atomic.AddUint64(&amp;s.cnt, 1)
        s.mu.Lock()
        if s.chs != nil </span><span class="cov0" title="0">{
                ch = make(chan PubSubMessage, 16)
                sb := &amp;sub{cs: channels, ch: ch, fn: fn}
                s.sub[id] = sb
                for _, channel := range channels </span><span class="cov0" title="0">{
                        c := s.chs[channel].sub
                        if c == nil </span><span class="cov0" title="0">{
                                c = make(map[uint64]*sub, 1)
                                s.chs[channel] = chs{sub: c}
                        }</span>
                        <span class="cov0" title="0">c[id] = sb</span>
                }
                <span class="cov0" title="0">cancel = func() </span><span class="cov0" title="0">{
                        go func() </span><span class="cov0" title="0">{
                                for range ch </span>{<span class="cov0" title="0">
                                }</span>
                        }()
                        <span class="cov0" title="0">s.mu.Lock()
                        if s.chs != nil </span><span class="cov0" title="0">{
                                s.remove(id)
                        }</span>
                        <span class="cov0" title="0">s.mu.Unlock()</span>
                }
        }
        <span class="cov0" title="0">s.mu.Unlock()
        return ch, cancel</span>
}

func (s *subs) remove(id uint64) <span class="cov0" title="0">{
        if sb := s.sub[id]; sb != nil </span><span class="cov0" title="0">{
                for _, channel := range sb.cs </span><span class="cov0" title="0">{
                        if c := s.chs[channel].sub; c != nil </span><span class="cov0" title="0">{
                                delete(c, id)
                        }</span>
                }
                <span class="cov0" title="0">close(sb.ch)
                delete(s.sub, id)</span>
        }
}

func (s *subs) Confirm(sub PubSubSubscription) <span class="cov0" title="0">{
        if atomic.LoadUint64(&amp;s.cnt) != 0 </span><span class="cov0" title="0">{
                s.mu.RLock()
                for _, sb := range s.chs[sub.Channel].sub </span><span class="cov0" title="0">{
                        if sb.fn != nil </span><span class="cov0" title="0">{
                                sb.fn(sub)
                        }</span>
                }
                <span class="cov0" title="0">s.mu.RUnlock()</span>
        }
}

func (s *subs) Unsubscribe(sub PubSubSubscription) <span class="cov0" title="0">{
        if atomic.LoadUint64(&amp;s.cnt) != 0 </span><span class="cov0" title="0">{
                s.mu.Lock()
                for id, sb := range s.chs[sub.Channel].sub </span><span class="cov0" title="0">{
                        if sb.fn != nil </span><span class="cov0" title="0">{
                                sb.fn(sub)
                        }</span>
                        <span class="cov0" title="0">s.remove(id)</span>
                }
                <span class="cov0" title="0">delete(s.chs, sub.Channel)
                s.mu.Unlock()</span>
        }
}

func (s *subs) Close() <span class="cov8" title="1">{
        var sbs map[uint64]*sub
        s.mu.Lock()
        sbs = s.sub
        s.chs = nil
        s.sub = nil
        s.mu.Unlock()
        for _, sb := range sbs </span><span class="cov0" title="0">{
                close(sb.ch)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package valkey

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "math"
        "strconv"
        "strings"
        "sync"
        "unsafe"
)

var errChunked = errors.New("unbounded valkey message")
var errOldNull = errors.New("RESP2 null")

const (
        typeBlobString     = byte('$')
        typeSimpleString   = byte('+')
        typeSimpleErr      = byte('-')
        typeInteger        = byte(':')
        typeNull           = byte('_')
        typeEnd            = byte('.')
        typeFloat          = byte(',')
        typeBool           = byte('#')
        typeBlobErr        = byte('!')
        typeVerbatimString = byte('=')
        typeBigNumber      = byte('(')
        typeArray          = byte('*')
        typeMap            = byte('%')
        typeSet            = byte('~')
        typeAttribute      = byte('|')
        typePush           = byte('&gt;')
        typeChunk          = byte(';')
)

var typeNames = make(map[byte]string, 16)

type reader func(i *bufio.Reader) (ValkeyMessage, error)

var readers = [256]reader{}

func init() <span class="cov8" title="1">{
        readers[typeBlobString] = readBlobString
        readers[typeSimpleString] = readSimpleString
        readers[typeSimpleErr] = readSimpleString
        readers[typeInteger] = readInteger
        readers[typeNull] = readNull
        readers[typeFloat] = readSimpleString
        readers[typeBool] = readBoolean
        readers[typeBlobErr] = readBlobString
        readers[typeVerbatimString] = readBlobString
        readers[typeBigNumber] = readSimpleString
        readers[typeArray] = readArray
        readers[typeMap] = readMap
        readers[typeSet] = readArray
        readers[typeAttribute] = readMap
        readers[typePush] = readArray
        readers[typeEnd] = readNull

        typeNames[typeBlobString] = "blob string"
        typeNames[typeSimpleString] = "simple string"
        typeNames[typeSimpleErr] = "simple error"
        typeNames[typeInteger] = "int64"
        typeNames[typeNull] = "null"
        typeNames[typeFloat] = "float64"
        typeNames[typeBool] = "boolean"
        typeNames[typeBlobErr] = "blob error"
        typeNames[typeVerbatimString] = "verbatim string"
        typeNames[typeBigNumber] = "big number"
        typeNames[typeArray] = "array"
        typeNames[typeMap] = "map"
        typeNames[typeSet] = "set"
        typeNames[typeAttribute] = "attribute"
        typeNames[typePush] = "push"
        typeNames[typeEnd] = "null"
}</span>

func readSimpleString(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov8" title="1">{
        m.bytes, m.intlen, err = readS(i)
        return
}</span>

func readBlobString(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov8" title="1">{
        m.bytes, m.intlen, err = readB(i)
        if err == errChunked </span><span class="cov0" title="0">{
                sb := strings.Builder{}
                for </span><span class="cov0" title="0">{
                        if _, err = i.Discard(1); err != nil </span><span class="cov0" title="0">{ // discard the ';'
                                return ValkeyMessage{}, err
                        }</span>
                        <span class="cov0" title="0">length, err := readI(i)
                        if err != nil </span><span class="cov0" title="0">{
                                return ValkeyMessage{}, err
                        }</span>
                        <span class="cov0" title="0">if length == 0 </span><span class="cov0" title="0">{
                                m.setString(sb.String())
                                return m, nil
                        }</span>
                        <span class="cov0" title="0">sb.Grow(int(length))
                        if _, err = io.CopyN(&amp;sb, i, length); err != nil </span><span class="cov0" title="0">{
                                return ValkeyMessage{}, err
                        }</span>
                        <span class="cov0" title="0">if _, err = i.Discard(2); err != nil </span><span class="cov0" title="0">{
                                return ValkeyMessage{}, err
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func readInteger(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov8" title="1">{
        m.intlen, err = readI(i)
        return
}</span>

func readBoolean(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov0" title="0">{
        b, err := i.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return ValkeyMessage{}, err
        }</span>
        <span class="cov0" title="0">if b == 't' </span><span class="cov0" title="0">{
                m.intlen = 1
        }</span>
        <span class="cov0" title="0">_, err = i.Discard(2)
        return</span>
}

func readNull(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov0" title="0">{
        _, err = i.Discard(2)
        return
}</span>

func readArray(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov8" title="1">{
        length, err := readI(i)
        if err == nil </span><span class="cov8" title="1">{
                if length == -1 </span><span class="cov0" title="0">{
                        return m, errOldNull
                }</span>
                <span class="cov8" title="1">m.array, m.intlen, err = readA(i, length)</span>
        } else<span class="cov0" title="0"> if err == errChunked </span><span class="cov0" title="0">{
                m.array, m.intlen, err = readE(i)
        }</span>
        <span class="cov8" title="1">return m, err</span>
}

func readMap(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov8" title="1">{
        length, err := readI(i)
        if err == nil </span><span class="cov8" title="1">{
                m.array, m.intlen, err = readA(i, length*2)
        }</span> else<span class="cov0" title="0"> if err == errChunked </span><span class="cov0" title="0">{
                m.array, m.intlen, err = readE(i)
        }</span>
        <span class="cov8" title="1">return m, err</span>
}

const ok = "OK"
const okrn = "OK\r\n"

func readS(i *bufio.Reader) (*byte, int64, error) <span class="cov8" title="1">{
        if peek, _ := i.Peek(2); string(peek) == ok </span><span class="cov8" title="1">{
                if peek, _ = i.Peek(4); string(peek) == okrn </span><span class="cov8" title="1">{
                        _, _ = i.Discard(4)
                        return unsafe.StringData(ok), int64(len(ok)), nil
                }</span>
        }
        <span class="cov8" title="1">bs, err := i.ReadBytes('\n')
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">if trim := len(bs) - 2; trim &lt; 0 </span><span class="cov0" title="0">{
                return nil, 0, errors.New(unexpectedNoCRLF)
        }</span> else<span class="cov8" title="1"> {
                bs = bs[:trim]
        }</span>
        <span class="cov8" title="1">return unsafe.SliceData(bs), int64(len(bs)), nil</span>
}

func readI(i *bufio.Reader) (v int64, err error) <span class="cov8" title="1">{
        bs, err := i.ReadSlice('\n')
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if len(bs) &lt; 3 </span><span class="cov0" title="0">{
                return 0, errors.New(unexpectedNoCRLF)
        }</span>
        <span class="cov8" title="1">if bs[0] == '?' </span><span class="cov0" title="0">{
                return 0, errChunked
        }</span>
        <span class="cov8" title="1">var s = int64(1)
        if bs[0] == '-' </span><span class="cov0" title="0">{
                s = -1
                bs = bs[1:]
        }</span>
        <span class="cov8" title="1">for _, c := range bs[:len(bs)-2] </span><span class="cov8" title="1">{
                if d := int64(c - '0'); d &gt;= 0 &amp;&amp; d &lt;= 9 </span><span class="cov8" title="1">{
                        v = v*10 + d
                }</span> else<span class="cov0" title="0"> {
                        return 0, errors.New(unexpectedNumByte + strconv.Itoa(int(c)))
                }</span>
        }
        <span class="cov8" title="1">return v * s, nil</span>
}

func readB(i *bufio.Reader) (*byte, int64, error) <span class="cov8" title="1">{
        length, err := readI(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">if length == -1 </span><span class="cov0" title="0">{
                return nil, 0, errOldNull
        }</span>
        <span class="cov8" title="1">bs := make([]byte, length)
        if _, err = io.ReadFull(i, bs); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">if _, err = i.Discard(2); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">return unsafe.SliceData(bs), int64(len(bs)), nil</span>
}

func readE(i *bufio.Reader) (*ValkeyMessage, int64, error) <span class="cov0" title="0">{
        v := make([]ValkeyMessage, 0)
        for </span><span class="cov0" title="0">{
                n, err := readNextMessage(i)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">if n.typ == '.' </span><span class="cov0" title="0">{
                        return unsafe.SliceData(v), int64(len(v)), err
                }</span>
                <span class="cov0" title="0">v = append(v, n)</span>
        }
}

func readA(i *bufio.Reader, length int64) (*ValkeyMessage, int64, error) <span class="cov8" title="1">{
        var err error

        msgs := make([]ValkeyMessage, length)
        for n := int64(0); n &lt; length; n++ </span><span class="cov8" title="1">{
                if msgs[n], err = readNextMessage(i); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
        }
        <span class="cov8" title="1">return unsafe.SliceData(msgs), length, nil</span>
}

func writeB(o *bufio.Writer, id byte, str string) (err error) <span class="cov8" title="1">{
        _ = writeN(o, id, len(str))
        _, _ = o.WriteString(str)
        _, err = o.WriteString("\r\n")
        return err
}</span>

func writeS(o *bufio.Writer, id byte, str string) (err error) <span class="cov0" title="0">{
        _ = o.WriteByte(id)
        _, _ = o.WriteString(str)
        _, err = o.WriteString("\r\n")
        return err
}</span>

func writeN(o *bufio.Writer, id byte, n int) (err error) <span class="cov8" title="1">{
        _ = o.WriteByte(id)
        if n &lt; 10 </span><span class="cov8" title="1">{
                _ = o.WriteByte(byte('0' + n))
        }</span> else<span class="cov0" title="0"> {
                for d := int(math.Pow10(int(math.Log10(float64(n))))); d &gt; 0; d /= 10 </span><span class="cov0" title="0">{
                        _ = o.WriteByte(byte('0' + n/d))
                        n = n % d
                }</span>
        }
        <span class="cov8" title="1">_, err = o.WriteString("\r\n")
        return err</span>
}

func readNextMessage(i *bufio.Reader) (m ValkeyMessage, err error) <span class="cov8" title="1">{
        var attrs *ValkeyMessage
        var typ byte
        for </span><span class="cov8" title="1">{
                if typ, err = i.ReadByte(); err != nil </span><span class="cov8" title="1">{
                        return ValkeyMessage{}, err
                }</span>
                <span class="cov8" title="1">fn := readers[typ]
                if fn == nil </span><span class="cov0" title="0">{
                        return ValkeyMessage{}, errors.New(unknownMessageType + strconv.Itoa(int(typ)))
                }</span>
                <span class="cov8" title="1">if m, err = fn(i); err != nil </span><span class="cov0" title="0">{
                        if err == errOldNull </span><span class="cov0" title="0">{
                                return ValkeyMessage{typ: typeNull}, nil
                        }</span>
                        <span class="cov0" title="0">return ValkeyMessage{}, err</span>
                }
                <span class="cov8" title="1">m.typ = typ
                if m.typ == typeAttribute </span><span class="cov0" title="0">{ // handle the attributes
                        a := m     // clone the original m first, and then take the address of the clone
                        attrs = &amp;a // to avoid go compiler allocating the m on heap which causing worse performance.
                        m = ValkeyMessage{}
                        continue</span>
                }
                <span class="cov8" title="1">m.attrs = attrs
                return m, nil</span>
        }
}

var lrs = sync.Pool{New: func() any <span class="cov0" title="0">{ return &amp;io.LimitedReader{} }</span>}

func streamTo(i *bufio.Reader, w io.Writer) (n int64, err error, clean bool) <span class="cov0" title="0">{
</span>next:
        <span class="cov0" title="0">var typ byte
        if typ, err = i.ReadByte(); err != nil </span><span class="cov0" title="0">{
                return 0, err, false
        }</span>
        <span class="cov0" title="0">switch typ </span>{
        case typeBlobString, typeVerbatimString, typeChunk:<span class="cov0" title="0">
                if n, err = readI(i); err != nil </span><span class="cov0" title="0">{
                        if err == errChunked </span><span class="cov0" title="0">{
                                var nn int64
                                nn, err, clean = streamTo(i, w)
                                for n += nn; nn != 0 &amp;&amp; clean &amp;&amp; err == nil; n += nn </span><span class="cov0" title="0">{
                                        nn, err, clean = streamTo(i, w)
                                }</span>
                        }
                        <span class="cov0" title="0">return n, err, clean</span>
                }
                <span class="cov0" title="0">if n == -1 </span><span class="cov0" title="0">{
                        return 0, Nil, true
                }</span>
                <span class="cov0" title="0">full := n + 2
                if n != 0 </span><span class="cov0" title="0">{
                        lr := lrs.Get().(*io.LimitedReader)
                        lr.R = i
                        lr.N = n
                        n, err = io.Copy(w, lr)
                        lr.R = nil
                        lrs.Put(lr)
                }</span> else<span class="cov0" title="0"> if typ == typeChunk </span><span class="cov0" title="0">{
                        return n, err, true
                }</span>
                <span class="cov0" title="0">if _, err2 := i.Discard(int(full - n)); err2 == nil </span><span class="cov0" title="0">{
                        clean = true
                }</span> else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                        err = err2
                }</span>
                <span class="cov0" title="0">return n, err, clean</span>
        default:<span class="cov0" title="0">
                _ = i.UnreadByte()
                m, err := readNextMessage(i)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err, false
                }</span>
                <span class="cov0" title="0">switch m.typ </span>{
                case typeSimpleString, typeFloat, typeBigNumber:<span class="cov0" title="0">
                        n, err := w.Write([]byte(m.string()))
                        return int64(n), err, true</span>
                case typeNull:<span class="cov0" title="0">
                        return 0, Nil, true</span>
                case typeSimpleErr, typeBlobErr:<span class="cov0" title="0">
                        mm := m
                        return 0, (*ValkeyError)(&amp;mm), true</span>
                case typeInteger, typeBool:<span class="cov0" title="0">
                        n, err := w.Write([]byte(strconv.FormatInt(m.intlen, 10)))
                        return int64(n), err, true</span>
                case typePush:<span class="cov0" title="0">
                        goto next</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("unsupported valkey %q response for streaming read", typeNames[typ]), true</span>
                }
        }
}

func writeCmd(o *bufio.Writer, cmd []string) (err error) <span class="cov8" title="1">{
        err = writeN(o, '*', len(cmd))
        for _, m := range cmd </span><span class="cov8" title="1">{
                err = writeB(o, '$', m)
                // TODO: Can we set cmd[i] = "" here to allow GC to eagerly recycle memory?
                // Related: https://github.com/redis/rueidis/issues/364
        }</span>
        <span class="cov8" title="1">return err</span>
}

func flushCmd(o *bufio.Writer, cmd []string) (err error) <span class="cov0" title="0">{
        _ = writeCmd(o, cmd)
        return o.Flush()
}</span>

const (
        unexpectedNoCRLF   = "received unexpected simple string message ending without CRLF"
        unexpectedNumByte  = "received unexpected number byte: "
        unknownMessageType = "received unknown message type: "
)
</pre>
		
		<pre class="file" id="file14" style="display: none">package valkey

import (
        "context"
        "runtime"
        "time"

        "github.com/valkey-io/valkey-go/internal/util"
)

const (
        defaultMaxRetries    = 20
        defaultMaxRetryDelay = 1 * time.Second
)

// RetryDelayFn returns the delay that should be used before retrying the
// attempt. Will return a negative delay if the delay could not be determined or does not retry.
type RetryDelayFn func(attempts int, cmd Completed, err error) time.Duration

// defaultRetryDelayFn delays the next retry exponentially without considering the error.
// Max delay is 1 second.
// This "Equal Jitter" delay produced by this implementation is not monotonic increasing. ref: https://aws.amazon.com/ko/blogs/architecture/exponential-backoff-and-jitter/
func defaultRetryDelayFn(attempts int, _ Completed, _ error) time.Duration <span class="cov0" title="0">{
        base := 1 &lt;&lt; min(defaultMaxRetries, attempts)
        jitter := util.FastRand(base)
        return min(defaultMaxRetryDelay, time.Duration(base+jitter)*time.Microsecond)
}</span>

type retryHandler interface {
        // RetryDelay returns the delay that should be used before retrying the
        // attempt. Will return a negative delay if the delay could not be determined or does
        // not retry.
        // If the delay is zero, the next retry should be attempted immediately.
        RetryDelay(attempts int, cmd Completed, err error) time.Duration

        // WaitForRetry waits until the next retry should be attempted.
        WaitForRetry(ctx context.Context, duration time.Duration)

        // WaitOrSkipRetry waits until the next retry should be attempted
        // or returns false if the command should not be retried.
        // Returns false immediately if the command should not be retried.
        // Returns true after the delay if the command should be retried.
        WaitOrSkipRetry(ctx context.Context, attempts int, cmd Completed, err error) bool
}

type retryer struct {
        RetryDelayFn RetryDelayFn
}

var _ retryHandler = (*retryer)(nil)

func newRetryer(retryDelayFn RetryDelayFn) *retryer <span class="cov8" title="1">{
        return &amp;retryer{RetryDelayFn: retryDelayFn}
}</span>

func (r *retryer) RetryDelay(attempts int, cmd Completed, err error) time.Duration <span class="cov0" title="0">{
        return r.RetryDelayFn(attempts, cmd, err)
}</span>

func (r *retryer) WaitForRetry(ctx context.Context, duration time.Duration) <span class="cov0" title="0">{
        if duration &gt; 0 </span><span class="cov0" title="0">{
                if ch := ctx.Done(); ch != nil </span><span class="cov0" title="0">{
                        tm := time.NewTimer(duration)
                        defer tm.Stop()
                        select </span>{
                        case &lt;-ch:<span class="cov0" title="0"></span>
                        case &lt;-tm.C:<span class="cov0" title="0"></span>
                        }
                } else<span class="cov0" title="0"> {
                        time.Sleep(duration)
                }</span>
        }
}

func (r *retryer) WaitOrSkipRetry(
        ctx context.Context, attempts int, cmd Completed, err error,
) bool <span class="cov0" title="0">{
        if delay := r.RetryDelay(attempts, cmd, err); delay == 0 </span><span class="cov0" title="0">{
                runtime.Gosched()
                return true
        }</span> else<span class="cov0" title="0"> if delay &gt; 0 </span><span class="cov0" title="0">{
                if dl, ok := ctx.Deadline(); !ok || time.Until(dl) &gt; delay </span><span class="cov0" title="0">{
                        r.WaitForRetry(ctx, delay)
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package valkey

import (
        "sync"
        "sync/atomic"

        "golang.org/x/sys/cpu"
)

type queue interface {
        PutOne(m Completed) chan ValkeyResult
        PutMulti(m []Completed, resps []ValkeyResult) chan ValkeyResult
        NextWriteCmd() (Completed, []Completed, chan ValkeyResult)
        WaitForWrite() (Completed, []Completed, chan ValkeyResult)
        NextResultCh() (Completed, []Completed, chan ValkeyResult, []ValkeyResult, *sync.Cond)
}

var _ queue = (*ring)(nil)

func newRing(factor int) *ring <span class="cov8" title="1">{
        if factor &lt;= 0 </span><span class="cov8" title="1">{
                factor = DefaultRingScale
        }</span>
        <span class="cov8" title="1">r := &amp;ring{store: make([]node, 2&lt;&lt;(factor-1))}
        r.mask = uint32(len(r.store) - 1)
        for i := range r.store </span><span class="cov8" title="1">{
                m := &amp;sync.Mutex{}
                r.store[i].c1 = sync.NewCond(m)
                r.store[i].c2 = sync.NewCond(m)
                r.store[i].ch = make(chan ValkeyResult) // this channel can't be buffered
        }</span>
        <span class="cov8" title="1">return r</span>
}

type ring struct {
        store []node // store's size must be 2^N to work with the mask
        _     cpu.CacheLinePad
        write uint32
        _     cpu.CacheLinePad
        read1 uint32
        read2 uint32
        mask  uint32
}

type node struct {
        c1    *sync.Cond
        c2    *sync.Cond
        ch    chan ValkeyResult
        one   Completed
        multi []Completed
        resps []ValkeyResult
        mark  uint32
        slept bool
}

func (r *ring) PutOne(m Completed) chan ValkeyResult <span class="cov8" title="1">{
        n := &amp;r.store[atomic.AddUint32(&amp;r.write, 1)&amp;r.mask]
        n.c1.L.Lock()
        for n.mark != 0 </span><span class="cov0" title="0">{
                n.c1.Wait()
        }</span>
        <span class="cov8" title="1">n.one = m
        n.mark = 1
        s := n.slept
        n.c1.L.Unlock()
        if s </span><span class="cov8" title="1">{
                n.c2.Broadcast()
        }</span>
        <span class="cov8" title="1">return n.ch</span>
}

func (r *ring) PutMulti(m []Completed, resps []ValkeyResult) chan ValkeyResult <span class="cov0" title="0">{
        n := &amp;r.store[atomic.AddUint32(&amp;r.write, 1)&amp;r.mask]
        n.c1.L.Lock()
        for n.mark != 0 </span><span class="cov0" title="0">{
                n.c1.Wait()
        }</span>
        <span class="cov0" title="0">n.multi = m
        n.resps = resps
        n.mark = 1
        s := n.slept
        n.c1.L.Unlock()
        if s </span><span class="cov0" title="0">{
                n.c2.Broadcast()
        }</span>
        <span class="cov0" title="0">return n.ch</span>
}

// NextWriteCmd should be only called by one dedicated thread
func (r *ring) NextWriteCmd() (one Completed, multi []Completed, ch chan ValkeyResult) <span class="cov8" title="1">{
        r.read1++
        p := r.read1 &amp; r.mask
        n := &amp;r.store[p]
        n.c1.L.Lock()
        if n.mark == 1 </span><span class="cov8" title="1">{
                one, multi, ch = n.one, n.multi, n.ch
                n.mark = 2
        }</span> else<span class="cov8" title="1"> {
                r.read1--
        }</span>
        <span class="cov8" title="1">n.c1.L.Unlock()
        return</span>
}

// WaitForWrite should be only called by one dedicated thread
func (r *ring) WaitForWrite() (one Completed, multi []Completed, ch chan ValkeyResult) <span class="cov8" title="1">{
        r.read1++
        p := r.read1 &amp; r.mask
        n := &amp;r.store[p]
        n.c1.L.Lock()
        for n.mark != 1 </span><span class="cov8" title="1">{
                n.slept = true
                n.c2.Wait() // c1 and c2 share the same mutex
                n.slept = false
        }</span>
        <span class="cov8" title="1">one, multi, ch = n.one, n.multi, n.ch
        n.mark = 2
        n.c1.L.Unlock()
        return</span>
}

// NextResultCh should be only called by one dedicated thread
func (r *ring) NextResultCh() (one Completed, multi []Completed, ch chan ValkeyResult, resps []ValkeyResult, cond *sync.Cond) <span class="cov8" title="1">{
        r.read2++
        p := r.read2 &amp; r.mask
        n := &amp;r.store[p]
        cond = n.c1
        n.c1.L.Lock()
        if n.mark == 2 </span><span class="cov8" title="1">{
                one, multi, ch, resps = n.one, n.multi, n.ch, n.resps
                n.mark = 0
                n.one = Completed{}
                n.multi = nil
                n.resps = nil
        }</span> else<span class="cov8" title="1"> {
                r.read2--
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package valkey

import (
        "container/list"
        "context"
        "errors"
        "fmt"
        "io"
        "net"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/valkey-io/valkey-go/internal/cmds"
        "github.com/valkey-io/valkey-go/internal/util"
)

func newSentinelClient(opt *ClientOption, connFn connFn, retryer retryHandler) (client *sentinelClient, err error) <span class="cov0" title="0">{
        client = &amp;sentinelClient{
                cmd:          cmds.NewBuilder(cmds.NoSlot),
                mOpt:         opt,
                sOpt:         newSentinelOpt(opt),
                connFn:       connFn,
                sentinels:    list.New(),
                retry:        !opt.DisableRetry,
                retryHandler: retryer,
                hasLftm:      opt.ConnLifetime &gt; 0,
                replica:      opt.ReplicaOnly,
        }

        for _, sentinel := range opt.InitAddress </span><span class="cov0" title="0">{
                client.sentinels.PushBack(sentinel)
        }</span>

        <span class="cov0" title="0">if opt.ReplicaOnly &amp;&amp; opt.SendToReplicas != nil </span><span class="cov0" title="0">{
                return nil, ErrReplicaOnlyConflict
        }</span>

        <span class="cov0" title="0">if opt.SendToReplicas != nil || opt.ReplicaOnly </span><span class="cov0" title="0">{
                rOpt := *opt
                rOpt.ReplicaOnly = true
                client.rOpt = &amp;rOpt
        }</span>

        <span class="cov0" title="0">if err = client.refresh(); err != nil </span><span class="cov0" title="0">{
                client.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

type sentinelClient struct {
        mConn        atomic.Value
        rConn        atomic.Value
        sConn        conn
        retryHandler retryHandler
        connFn       connFn
        mOpt         *ClientOption
        sOpt         *ClientOption
        rOpt         *ClientOption
        sentinels    *list.List
        mAddr        atomic.Value
        rAddr        atomic.Value
        sAddr        string
        sc           call
        mu           sync.Mutex
        stop         uint32
        cmd          Builder
        retry        bool
        hasLftm      bool
        replica      bool
}

func (c *sentinelClient) B() Builder <span class="cov0" title="0">{
        return c.cmd
}</span>

func (c *sentinelClient) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">cc := c.pick(cmd)
        resp = cc.Do(ctx, cmd)
        if err := resp.Error(); err != nil </span><span class="cov0" title="0">{
                if err == errConnExpired </span><span class="cov0" title="0">{
                        goto retry</span>
                }
                <span class="cov0" title="0">if c.retry &amp;&amp; cmd.IsReadOnly() &amp;&amp; c.isRetryable(err, ctx) </span><span class="cov0" title="0">{
                        if c.retryHandler.WaitOrSkipRetry(ctx, attempts, cmd, err) </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">if resp.NonValkeyError() == nil </span><span class="cov0" title="0">{ // not recycle cmds if error, since cmds may be used later in the pipe.
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (c *sentinelClient) DoMulti(ctx context.Context, multi ...Completed) []ValkeyResult <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">attempts := 1
        sendToReplica := c.sendAllToReplica(multi)
</span>retry:
        <span class="cov0" title="0">cc := c.pickMulti(sendToReplica)
        resps := cc.DoMulti(ctx, multi...)
        if c.hasLftm </span><span class="cov0" title="0">{
                var ml []Completed
        </span>recover:
                <span class="cov0" title="0">ml = ml[:0]
                var txIdx int // check transaction block, if zero, then not in transaction
                for i, resp := range resps.s </span><span class="cov0" title="0">{
                        if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                if txIdx &gt; 0 </span><span class="cov0" title="0">{
                                        ml = multi[txIdx:]
                                }</span> else<span class="cov0" title="0"> {
                                        ml = multi[i:]
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                        // if no error, then check if transaction block
                        <span class="cov0" title="0">if isMulti(multi[i]) </span><span class="cov0" title="0">{
                                txIdx = i
                        }</span> else<span class="cov0" title="0"> if isExec(multi[i]) </span><span class="cov0" title="0">{
                                txIdx = 0
                        }</span>
                }
                <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                        rs := cc.DoMulti(ctx, ml...).s
                        resps.s = append(resps.s[:len(resps.s)-len(rs)], rs...)
                        goto recover</span>
                }
        }
        <span class="cov0" title="0">if c.retry &amp;&amp; allReadOnly(multi) </span><span class="cov0" title="0">{
                for i, resp := range resps.s </span><span class="cov0" title="0">{
                        if c.isRetryable(resp.Error(), ctx) </span><span class="cov0" title="0">{
                                shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                        ctx, attempts, multi[i], resp.Error(),
                                )
                                if shouldRetry </span><span class="cov0" title="0">{
                                        resultsp.Put(resps)
                                        attempts++
                                        goto retry</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                if resps.s[i].NonValkeyError() == nil </span><span class="cov0" title="0">{
                        cmds.PutCompleted(cmd)
                }</span>
        }
        <span class="cov0" title="0">return resps.s</span>
}

func (c *sentinelClient) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp ValkeyResult) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">cc := c.pick(Completed(cmd))
        resp = cc.DoCache(ctx, cmd, ttl)
        if err := resp.Error(); err != nil </span><span class="cov0" title="0">{
                if err == errConnExpired </span><span class="cov0" title="0">{
                        goto retry</span>
                }
                <span class="cov0" title="0">if c.retry &amp;&amp; c.isRetryable(err, ctx) </span><span class="cov0" title="0">{
                        if c.retryHandler.WaitOrSkipRetry(ctx, attempts, Completed(cmd), err) </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">if err := resp.NonValkeyError(); err == nil || err == ErrDoCacheAborted </span><span class="cov0" title="0">{
                cmds.PutCacheable(cmd)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (c *sentinelClient) DoMultiCache(ctx context.Context, multi ...CacheableTTL) []ValkeyResult <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">attempts := 1

        sendToReplica := c.sendAllToReplicaCache(multi)
</span>retry:
        <span class="cov0" title="0">cc := c.pickMulti(sendToReplica)
        resps := cc.DoMultiCache(ctx, multi...)
        if c.hasLftm </span><span class="cov0" title="0">{
                var ml []CacheableTTL
        </span>recover:
                <span class="cov0" title="0">ml = ml[:0]
                for i, resp := range resps.s </span><span class="cov0" title="0">{
                        if resp.NonValkeyError() == errConnExpired </span><span class="cov0" title="0">{
                                ml = multi[i:]
                                break</span>
                        }
                }
                <span class="cov0" title="0">if len(ml) &gt; 0 </span><span class="cov0" title="0">{
                        rs := cc.DoMultiCache(ctx, ml...).s
                        resps.s = append(resps.s[:len(resps.s)-len(rs)], rs...)
                        goto recover</span>
                }
        }
        <span class="cov0" title="0">if c.retry </span><span class="cov0" title="0">{
                for i, resp := range resps.s </span><span class="cov0" title="0">{
                        if c.isRetryable(resp.Error(), ctx) </span><span class="cov0" title="0">{
                                shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                        ctx, attempts, Completed(multi[i].Cmd), resp.Error(),
                                )
                                if shouldRetry </span><span class="cov0" title="0">{
                                        resultsp.Put(resps)
                                        attempts++
                                        goto retry</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">for i, cmd := range multi </span><span class="cov0" title="0">{
                if err := resps.s[i].NonValkeyError(); err == nil || err == ErrDoCacheAborted </span><span class="cov0" title="0">{
                        cmds.PutCacheable(cmd.Cmd)
                }</span>
        }
        <span class="cov0" title="0">return resps.s</span>
}

func (c *sentinelClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) <span class="cov0" title="0">{
        attempts := 1
</span>retry:
        <span class="cov0" title="0">cc := c.pick(subscribe)
        err = cc.Receive(ctx, subscribe, fn)
        if err == errConnExpired </span><span class="cov0" title="0">{
                goto retry</span>
        }
        <span class="cov0" title="0">if c.retry </span><span class="cov0" title="0">{
                if _, ok := err.(*ValkeyError); !ok &amp;&amp; c.isRetryable(err, ctx) </span><span class="cov0" title="0">{
                        shouldRetry := c.retryHandler.WaitOrSkipRetry(
                                ctx, attempts, subscribe, err,
                        )
                        if shouldRetry </span><span class="cov0" title="0">{
                                attempts++
                                goto retry</span>
                        }
                }
        }
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                cmds.PutCompleted(subscribe)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *sentinelClient) DoStream(ctx context.Context, cmd Completed) ValkeyResultStream <span class="cov0" title="0">{
        cc := c.pick(cmd)
        resp := cc.DoStream(ctx, cmd)
        cmds.PutCompleted(cmd)
        return resp
}</span>

func (c *sentinelClient) DoMultiStream(ctx context.Context, multi ...Completed) MultiValkeyResultStream <span class="cov0" title="0">{
        if len(multi) == 0 </span><span class="cov0" title="0">{
                return ValkeyResultStream{e: io.EOF}
        }</span>

        <span class="cov0" title="0">cc := c.pickMulti(c.sendAllToReplica(multi))
        s := cc.DoMultiStream(ctx, multi...)
        for _, cmd := range multi </span><span class="cov0" title="0">{
                cmds.PutCompleted(cmd)
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (c *sentinelClient) Dedicated(fn func(DedicatedClient) error) (err error) <span class="cov0" title="0">{
        var cc conn
        if c.replica </span><span class="cov0" title="0">{
                cc = c.rConn.Load().(conn)
        }</span> else<span class="cov0" title="0"> {
                cc = c.mConn.Load().(conn)
        }</span>
        <span class="cov0" title="0">wire := cc.Acquire(context.Background())
        dsc := &amp;dedicatedSingleClient{cmd: c.cmd, conn: cc, wire: wire, retry: c.retry, retryHandler: c.retryHandler}
        err = fn(dsc)
        dsc.release()
        return err</span>
}

func (c *sentinelClient) Dedicate() (DedicatedClient, func()) <span class="cov0" title="0">{
        var cc conn
        if c.replica </span><span class="cov0" title="0">{
                cc = c.rConn.Load().(conn)
        }</span> else<span class="cov0" title="0"> {
                cc = c.mConn.Load().(conn)
        }</span>
        <span class="cov0" title="0">wire := cc.Acquire(context.Background())
        dsc := &amp;dedicatedSingleClient{cmd: c.cmd, conn: cc, wire: wire, retry: c.retry, retryHandler: c.retryHandler}
        return dsc, dsc.release</span>
}

func (c *sentinelClient) Nodes() map[string]Client <span class="cov0" title="0">{
        disableCache := c.mOpt != nil &amp;&amp; c.mOpt.DisableCache

        switch </span>{
        case c.replica:<span class="cov0" title="0">
                cc := c.rConn.Load().(conn)
                return map[string]Client{cc.Addr(): newSingleClientWithConn(cc, c.cmd, c.retry, disableCache, c.retryHandler, false)}</span>
        case c.mOpt.SendToReplicas != nil:<span class="cov0" title="0">
                master := c.mConn.Load().(conn)
                replica := c.rConn.Load().(conn)
                return map[string]Client{
                        master.Addr():  newSingleClientWithConn(master, c.cmd, c.retry, disableCache, c.retryHandler, false),
                        replica.Addr(): newSingleClientWithConn(replica, c.cmd, c.retry, disableCache, c.retryHandler, false),
                }</span>
        default:<span class="cov0" title="0">
                cc := c.mConn.Load().(conn)
                return map[string]Client{cc.Addr(): newSingleClientWithConn(cc, c.cmd, c.retry, disableCache, c.retryHandler, false)}</span>
        }
}

func (c *sentinelClient) Mode() ClientMode <span class="cov0" title="0">{
        return ClientModeSentinel
}</span>

func (c *sentinelClient) Close() <span class="cov0" title="0">{
        atomic.StoreUint32(&amp;c.stop, 1)
        c.mu.Lock()
        if c.sConn != nil </span><span class="cov0" title="0">{
                c.sConn.Close()
        }</span>
        <span class="cov0" title="0">if master := c.mConn.Load(); master != nil </span><span class="cov0" title="0">{
                master.(conn).Close()
        }</span>
        <span class="cov0" title="0">if replica := c.rConn.Load(); replica != nil </span><span class="cov0" title="0">{
                replica.(conn).Close()
        }</span>
        <span class="cov0" title="0">c.mu.Unlock()</span>
}

func (c *sentinelClient) isRetryable(err error, ctx context.Context) (should bool) <span class="cov0" title="0">{
        if err == nil || err == Nil || err == ErrDoCacheAborted || atomic.LoadUint32(&amp;c.stop) != 0 || ctx.Err() != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err, ok := err.(*ValkeyError); ok </span><span class="cov0" title="0">{
                return err.IsLoading()
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (c *sentinelClient) addSentinel(addr string) <span class="cov0" title="0">{
        c.mu.Lock()
        c._addSentinel(addr)
        c.mu.Unlock()
}</span>

func (c *sentinelClient) _addSentinel(addr string) <span class="cov0" title="0">{
        for e := c.sentinels.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                if e.Value.(string) == addr </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">c.sentinels.PushFront(addr)</span>
}

func (c *sentinelClient) pick(cmd Completed) (cc conn) <span class="cov0" title="0">{
        switch </span>{
        case c.replica:<span class="cov0" title="0">
                cc = c.rConn.Load().(conn)</span>
        case c.mOpt.SendToReplicas != nil:<span class="cov0" title="0">
                if c.mOpt.SendToReplicas(cmd) </span><span class="cov0" title="0">{
                        cc = c.rConn.Load().(conn)
                }</span> else<span class="cov0" title="0"> {
                        cc = c.mConn.Load().(conn)
                }</span>
        default:<span class="cov0" title="0">
                cc = c.mConn.Load().(conn)</span>
        }
        <span class="cov0" title="0">return cc</span>
}

func (c *sentinelClient) pickMulti(sendToReplica bool) (cc conn) <span class="cov0" title="0">{
        switch </span>{
        case c.replica:<span class="cov0" title="0">
                cc = c.rConn.Load().(conn)</span>
        case c.mOpt.SendToReplicas != nil:<span class="cov0" title="0">
                if sendToReplica </span><span class="cov0" title="0">{
                        cc = c.rConn.Load().(conn)
                }</span> else<span class="cov0" title="0"> {
                        cc = c.mConn.Load().(conn)
                }</span>
        default:<span class="cov0" title="0">
                cc = c.mConn.Load().(conn)</span>
        }

        <span class="cov0" title="0">return cc</span>
}

func (c *sentinelClient) sendAllToReplica(cmds []Completed) bool <span class="cov0" title="0">{
        if c.mOpt.SendToReplicas == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, cmd := range cmds </span><span class="cov0" title="0">{
                if !c.mOpt.SendToReplicas(cmd) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (c *sentinelClient) sendAllToReplicaCache(cmds []CacheableTTL) bool <span class="cov0" title="0">{
        if c.mOpt.SendToReplicas == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, cmd := range cmds </span><span class="cov0" title="0">{
                if !c.mOpt.SendToReplicas(Completed(cmd.Cmd)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (c *sentinelClient) switchTargetRetry(addr string, isMaster bool) <span class="cov0" title="0">{
        c.mu.Lock()
        err := c._switchTarget(addr, isMaster)
        c.mu.Unlock()
        if err != nil </span><span class="cov0" title="0">{
                go c.refreshRetry()
        }</span>
}

func (c *sentinelClient) _switchTarget(addr string, isMaster bool) (err error) <span class="cov0" title="0">{
        if atomic.LoadUint32(&amp;c.stop) == 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var (
                target conn
                opt    *ClientOption
        )

        if isMaster </span><span class="cov0" title="0">{
                opt = c.mOpt
                if mAddr := c.mAddr.Load(); mAddr != nil &amp;&amp; mAddr.(string) == addr </span><span class="cov0" title="0">{
                        target = c.mConn.Load().(conn)
                        if target.Error() != nil </span><span class="cov0" title="0">{
                                target = nil
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                opt = c.rOpt
                if rAddr := c.rAddr.Load(); rAddr != nil &amp;&amp; rAddr.(string) == addr </span><span class="cov0" title="0">{
                        target = c.rConn.Load().(conn)
                        if target.Error() != nil </span><span class="cov0" title="0">{
                                target = nil
                        }</span>
                }
        }

        <span class="cov0" title="0">if target == nil </span><span class="cov0" title="0">{
                target = c.connFn(addr, opt)
                if err = target.Dial(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">resp, err := target.Do(context.Background(), cmds.RoleCmd).ToArray()
        if err != nil </span><span class="cov0" title="0">{
                target.Close()
                return err
        }</span>

        <span class="cov0" title="0">if isMaster </span><span class="cov0" title="0">{
                if resp[0].string() != "master" </span><span class="cov0" title="0">{
                        target.Close()
                        return errNotMaster
                }</span>

                <span class="cov0" title="0">c.mAddr.Store(addr)

                if old := c.mConn.Swap(target); old != nil </span><span class="cov0" title="0">{
                        if prev := old.(conn); prev != target </span><span class="cov0" title="0">{
                                prev.Close()
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                if resp[0].string() != "slave" </span><span class="cov0" title="0">{
                        target.Close()
                        return errNotSlave
                }</span>

                <span class="cov0" title="0">c.rAddr.Store(addr)

                if old := c.rConn.Swap(target); old != nil </span><span class="cov0" title="0">{
                        if prev := old.(conn); prev != target </span><span class="cov0" title="0">{
                                prev.Close()
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *sentinelClient) refreshRetry() <span class="cov0" title="0">{
</span>retry:
        <span class="cov0" title="0">if err := c.refresh(); err != nil </span><span class="cov0" title="0">{
                goto retry</span>
        }
}

func (c *sentinelClient) refresh() (err error) <span class="cov0" title="0">{
        return c.sc.Do(context.Background(), c._refresh)
}</span>

func (c *sentinelClient) _refresh() (err error) <span class="cov0" title="0">{
        var (
                master    string
                replica   string
                sentinels []string
        )

        c.mu.Lock()
        head := c.sentinels.Front()
        for e := head; e != nil; </span><span class="cov0" title="0">{
                if atomic.LoadUint32(&amp;c.stop) == 1 </span><span class="cov0" title="0">{
                        c.mu.Unlock()
                        return nil
                }</span>
                <span class="cov0" title="0">addr := e.Value.(string)

                if c.sAddr != addr || c.sConn == nil || c.sConn.Error() != nil </span><span class="cov0" title="0">{
                        if c.sConn != nil </span><span class="cov0" title="0">{
                                c.sConn.Close()
                        }</span>
                        <span class="cov0" title="0">c.sAddr = addr
                        c.sConn = c.connFn(addr, c.sOpt)
                        err = c.sConn.Dial()</span>
                }
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        // listWatch returns the server address with sentinels.
                        // check if the target is master or replica
                        if master, replica, sentinels, err = c.listWatch(c.sConn); err == nil </span><span class="cov0" title="0">{
                                for _, sentinel := range sentinels </span><span class="cov0" title="0">{
                                        c._addSentinel(sentinel)
                                }</span>

                                <span class="cov0" title="0">switch </span>{
                                case c.replica:<span class="cov0" title="0">
                                        err = c._switchTarget(replica, false)</span>
                                case c.mOpt.SendToReplicas != nil:<span class="cov0" title="0">
                                        errs := make(chan error, 1)
                                        go func(errs chan error, master string) </span><span class="cov0" title="0">{
                                                errs &lt;- c._switchTarget(master, true)
                                        }</span>(errs, master)
                                        <span class="cov0" title="0">go func(errs chan error, replica string) </span><span class="cov0" title="0">{
                                                errs &lt;- c._switchTarget(replica, false)
                                        }</span>(errs, replica)

                                        <span class="cov0" title="0">for i := 0; i &lt; 2; i++ </span><span class="cov0" title="0">{
                                                if e := &lt;-errs; e != nil </span><span class="cov0" title="0">{
                                                        err = e
                                                        break</span>
                                                }
                                        }
                                default:<span class="cov0" title="0">
                                        err = c._switchTarget(master, true)</span>
                                }

                                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">c.sConn.Close()</span>
                }
                <span class="cov0" title="0">c.sentinels.MoveToBack(e)
                if e = c.sentinels.Front(); e == head </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">c.mu.Unlock()

        if err == nil </span><span class="cov0" title="0">{
                if c.replica </span><span class="cov0" title="0">{
                        if replica := c.rConn.Load(); replica == nil </span><span class="cov0" title="0">{
                                err = ErrNoAddr
                        }</span> else<span class="cov0" title="0"> {
                                err = replica.(conn).Error()
                        }</span>
                } else<span class="cov0" title="0"> {
                        if master := c.mConn.Load(); master == nil </span><span class="cov0" title="0">{
                                err = ErrNoAddr
                        }</span> else<span class="cov0" title="0"> {
                                err = master.(conn).Error()
                        }</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

// listWatch will use sentinel to list the current master,replica address along with sentinel address
func (c *sentinelClient) listWatch(cc conn) (master string, replica string, sentinels []string, err error) <span class="cov0" title="0">{
        ctx := context.Background()
        sentinelsCMD := c.cmd.SentinelSentinels().Master(c.mOpt.Sentinel.MasterSet).Build()
        getMasterCMD := c.cmd.SentinelGetMasterAddrByName().Master(c.mOpt.Sentinel.MasterSet).Build()
        replicasCMD := c.cmd.SentinelReplicas().Master(c.mOpt.Sentinel.MasterSet).Build()

        defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{ // not recycle cmds if error, since cmds may be used later in the pipe.
                        cmds.PutCompleted(sentinelsCMD)
                        cmds.PutCompleted(getMasterCMD)
                        cmds.PutCompleted(replicasCMD)
                }</span>
        }()

        // unsubscribe in case there is any previous subscription
        <span class="cov0" title="0">cc.Do(ctx, cmds.SentinelUnSubscribe)

        go func(cc conn) </span><span class="cov0" title="0">{
                if err := cc.Receive(ctx, cmds.SentinelSubscribe, func(event PubSubMessage) </span><span class="cov0" title="0">{
                        switch event.Channel </span>{
                        case "+sentinel":<span class="cov0" title="0">
                                m := strings.SplitN(event.Message, " ", 4)
                                c.addSentinel(net.JoinHostPort(m[2], m[3]))</span>
                        case "+switch-master":<span class="cov0" title="0">
                                m := strings.SplitN(event.Message, " ", 5)
                                if m[0] == c.sOpt.Sentinel.MasterSet </span><span class="cov0" title="0">{
                                        c.switchTargetRetry(net.JoinHostPort(m[3], m[4]), true)
                                }</span>
                        case "+reboot":<span class="cov0" title="0">
                                m := strings.SplitN(event.Message, " ", 7)
                                if m[0] == "master" &amp;&amp; m[1] == c.sOpt.Sentinel.MasterSet </span><span class="cov0" title="0">{
                                        c.switchTargetRetry(net.JoinHostPort(m[2], m[3]), true)
                                }</span> else<span class="cov0" title="0"> if (c.replica || c.rOpt != nil) &amp;&amp; m[0] == "slave" &amp;&amp; m[5] == c.sOpt.Sentinel.MasterSet </span><span class="cov0" title="0">{
                                        c.refreshRetry()
                                }</span>
                        // note that in case of failover, every slave in the setup
                        // will send +slave event individually.
                        case "+slave", "+sdown", "-sdown":<span class="cov0" title="0">
                                m := strings.SplitN(event.Message, " ", 7)
                                if (c.replica || c.rOpt != nil) &amp;&amp; m[0] == "slave" &amp;&amp; m[5] == c.sOpt.Sentinel.MasterSet </span><span class="cov0" title="0">{
                                        // call refresh to randomly choose a new slave
                                        c.refreshRetry()
                                }</span>
                        }
                }); err != nil &amp;&amp; atomic.LoadUint32(&amp;c.stop) == 0 <span class="cov0" title="0">{
                        c.refreshRetry()
                }</span>
        }(cc)

        <span class="cov0" title="0">var commands Commands
        if c.replica </span><span class="cov0" title="0">{
                commands = Commands{sentinelsCMD, replicasCMD}
        }</span> else<span class="cov0" title="0"> if c.mOpt.SendToReplicas != nil </span><span class="cov0" title="0">{
                commands = Commands{sentinelsCMD, getMasterCMD, replicasCMD}
        }</span> else<span class="cov0" title="0"> {
                commands = Commands{sentinelsCMD, getMasterCMD}
        }</span>

        <span class="cov0" title="0">resp := cc.DoMulti(ctx, commands...)
        defer resultsp.Put(resp)
        others, err := resp.s[0].ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", nil, err
        }</span>
        <span class="cov0" title="0">for _, other := range others </span><span class="cov0" title="0">{
                if m, err := other.AsStrMap(); err == nil </span><span class="cov0" title="0">{
                        sentinels = append(sentinels, net.JoinHostPort(m["ip"], m["port"]))
                }</span>
        }

        // we return a random slave address instead of master
        <span class="cov0" title="0">if c.replica </span><span class="cov0" title="0">{
                addr, err := pickReplica(resp.s[1])
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", nil, err
                }</span>

                <span class="cov0" title="0">return "", addr, sentinels, nil</span>
        }

        <span class="cov0" title="0">var r string
        if c.mOpt.SendToReplicas != nil </span><span class="cov0" title="0">{
                addr, err := pickReplica(resp.s[2])
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", nil, err
                }</span>

                <span class="cov0" title="0">r = addr</span>
        }

        <span class="cov0" title="0">m, err := resp.s[1].AsStrSlice()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", nil, err
        }</span>
        <span class="cov0" title="0">return net.JoinHostPort(m[0], m[1]), r, sentinels, nil</span>
}

func pickReplica(resp ValkeyResult) (string, error) <span class="cov0" title="0">{
        replicas, err := resp.ToArray()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">eligible := make([]map[string]string, 0, len(replicas))
        // eliminate replicas with the s_down condition
        for i := range replicas </span><span class="cov0" title="0">{
                replica, err := replicas[i].AsStrMap()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if _, ok := replica["s-down-time"]; !ok </span><span class="cov0" title="0">{
                        eligible = append(eligible, replica)
                }</span>
        }

        <span class="cov0" title="0">if len(eligible) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("not enough ready replicas")
        }</span>

        // choose a replica randomly
        <span class="cov0" title="0">m := eligible[util.FastRand(len(eligible))]
        return net.JoinHostPort(m["ip"], m["port"]), nil</span>
}

func newSentinelOpt(opt *ClientOption) *ClientOption <span class="cov0" title="0">{
        o := *opt
        o.Username = o.Sentinel.Username
        o.Password = o.Sentinel.Password
        o.ClientName = o.Sentinel.ClientName
        o.Dialer = o.Sentinel.Dialer
        o.TLSConfig = o.Sentinel.TLSConfig
        o.SelectDB = 0 // https://github.com/redis/rueidis/issues/138
        return &amp;o
}</span>

var (
        errNotMaster = errors.New("the valkey role is not master")
        errNotSlave  = errors.New("the valkey role is not slave")
)
</pre>
		
		<pre class="file" id="file17" style="display: none">package valkey

import (
        "context"
        "sync"
        "time"
)

type call struct {
        ts time.Time
        ch chan struct{}
        cn int
        mu sync.Mutex
}

func (c *call) Do(ctx context.Context, fn func() error) error <span class="cov0" title="0">{
        c.mu.Lock()
        c.cn++
        ch := c.ch
        if ch != nil </span><span class="cov0" title="0">{
                c.mu.Unlock()
                if ctxCh := ctx.Done(); ctxCh != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ch:<span class="cov0" title="0"></span>
                        case &lt;-ctxCh:<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                } else<span class="cov0" title="0"> {
                        &lt;-ch
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">ch = make(chan struct{})
        c.ch = ch
        c.mu.Unlock()
        return c.do(ch, fn)</span>
}

func (c *call) LazyDo(threshold time.Duration, fn func() error) <span class="cov0" title="0">{
        c.mu.Lock()
        ch := c.ch
        if ch != nil </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">ch = make(chan struct{})
        c.ch = ch
        c.cn++
        ts := c.ts
        c.mu.Unlock()
        go func(ts time.Time, ch chan struct{}, fn func() error) </span><span class="cov0" title="0">{
                time.Sleep(time.Until(ts))
                c.do(ch, fn)
        }</span>(ts.Add(threshold), ch, fn)
}

func (c *call) do(ch chan struct{}, fn func() error) (err error) <span class="cov0" title="0">{
        err = fn()
        c.mu.Lock()
        c.ch = nil
        c.cn = 0
        c.ts = time.Now()
        c.mu.Unlock()
        close(ch)
        return
}</span>

func (c *call) suppressing() int <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.cn
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package valkey

import (
        "context"
        "errors"
        "math/rand/v2"
        "time"

        "github.com/valkey-io/valkey-go/internal/cmds"
)

func newStandaloneClient(opt *ClientOption, connFn connFn, retryer retryHandler) (*standalone, error) <span class="cov8" title="1">{
        if len(opt.InitAddress) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoAddr
        }</span>
        
        // Validate that EnableRedirect and ReplicaAddress cannot be used together
        <span class="cov8" title="1">if opt.Standalone.EnableRedirect &amp;&amp; len(opt.Standalone.ReplicaAddress) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("EnableRedirect and ReplicaAddress cannot be used together")
        }</span>
        <span class="cov8" title="1">p := connFn(opt.InitAddress[0], opt)
        if err := p.Dial(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s := &amp;standalone{
                toReplicas:     opt.SendToReplicas,
                primary:        newSingleClientWithConn(p, cmds.NewBuilder(cmds.NoSlot), !opt.DisableRetry, opt.DisableCache, retryer, false),
                replicas:       make([]*singleClient, len(opt.Standalone.ReplicaAddress)),
                enableRedirect: opt.Standalone.EnableRedirect,
                connFn:         connFn,
                opt:            opt,
                retryer:        retryer,
        }
        opt.ReplicaOnly = true
        for i := range s.replicas </span><span class="cov8" title="1">{
                replicaConn := connFn(opt.Standalone.ReplicaAddress[i], opt)
                if err := replicaConn.Dial(); err != nil </span><span class="cov0" title="0">{
                        s.primary.Close() // close primary if any replica fails
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                s.replicas[j].Close()
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">s.replicas[i] = newSingleClientWithConn(replicaConn, cmds.NewBuilder(cmds.NoSlot), !opt.DisableRetry, opt.DisableCache, retryer, false)</span>
        }
        <span class="cov8" title="1">return s, nil</span>
}

type standalone struct {
        toReplicas     func(Completed) bool
        primary        *singleClient
        replicas       []*singleClient
        enableRedirect bool
        connFn         connFn
        opt            *ClientOption
        retryer        retryHandler
}

func (s *standalone) B() Builder <span class="cov8" title="1">{
        return s.primary.B()
}</span>

func (s *standalone) pick() int <span class="cov0" title="0">{
        if len(s.replicas) == 1 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return rand.IntN(len(s.replicas))</span>
}

func (s *standalone) handleRedirect(ctx context.Context, cmd Completed, result ValkeyResult) ValkeyResult <span class="cov8" title="1">{
        if !s.enableRedirect </span><span class="cov8" title="1">{
                return result
        }</span>
        
        <span class="cov8" title="1">if ret, yes := IsValkeyErr(result.Error()); yes </span><span class="cov8" title="1">{
                if addr, ok := ret.IsRedirect(); ok </span><span class="cov8" title="1">{
                        // Create a new connection to the redirect address
                        redirectOpt := *s.opt
                        redirectOpt.InitAddress = []string{addr}
                        redirectConn := s.connFn(addr, &amp;redirectOpt)
                        if err := redirectConn.Dial(); err != nil </span><span class="cov0" title="0">{
                                // If redirect fails, return the original result
                                return result
                        }</span>
                        <span class="cov8" title="1">defer redirectConn.Close()
                        
                        // Create a temporary client for the redirect
                        redirectClient := newSingleClientWithConn(redirectConn, cmds.NewBuilder(cmds.NoSlot), !s.opt.DisableRetry, s.opt.DisableCache, s.retryer, false)
                        defer redirectClient.Close()
                        
                        // Execute the command on the redirect target
                        return redirectClient.Do(ctx, cmd)</span>
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

func (s *standalone) Do(ctx context.Context, cmd Completed) (resp ValkeyResult) <span class="cov8" title="1">{
        if s.toReplicas != nil &amp;&amp; s.toReplicas(cmd) </span><span class="cov0" title="0">{
                resp = s.replicas[s.pick()].Do(ctx, cmd)
        }</span> else<span class="cov8" title="1"> {
                resp = s.primary.Do(ctx, cmd)
        }</span>
        
        <span class="cov8" title="1">return s.handleRedirect(ctx, cmd, resp)</span>
}

func (s *standalone) DoMulti(ctx context.Context, multi ...Completed) (resp []ValkeyResult) <span class="cov0" title="0">{
        toReplica := true
        for _, cmd := range multi </span><span class="cov0" title="0">{
                if s.toReplicas == nil || !s.toReplicas(cmd) </span><span class="cov0" title="0">{
                        toReplica = false
                        break</span>
                }
        }
        <span class="cov0" title="0">if toReplica </span><span class="cov0" title="0">{
                resp = s.replicas[s.pick()].DoMulti(ctx, multi...)
        }</span> else<span class="cov0" title="0"> {
                resp = s.primary.DoMulti(ctx, multi...)
        }</span>
        
        // Handle redirects for each command in the multi
        <span class="cov0" title="0">if s.enableRedirect </span><span class="cov0" title="0">{
                for i, result := range resp </span><span class="cov0" title="0">{
                        if i &lt; len(multi) </span><span class="cov0" title="0">{
                                resp[i] = s.handleRedirect(ctx, multi[i], result)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return resp</span>
}

func (s *standalone) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) error <span class="cov0" title="0">{
        if s.toReplicas != nil &amp;&amp; s.toReplicas(subscribe) </span><span class="cov0" title="0">{
                return s.replicas[s.pick()].Receive(ctx, subscribe, fn)
        }</span>
        <span class="cov0" title="0">return s.primary.Receive(ctx, subscribe, fn)</span>
}

func (s *standalone) Close() <span class="cov8" title="1">{
        s.primary.Close()
        for _, replica := range s.replicas </span><span class="cov8" title="1">{
                replica.Close()
        }</span>
}

func (s *standalone) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp ValkeyResult) <span class="cov0" title="0">{
        return s.primary.DoCache(ctx, cmd, ttl)
}</span>

func (s *standalone) DoMultiCache(ctx context.Context, multi ...CacheableTTL) (resp []ValkeyResult) <span class="cov0" title="0">{
        return s.primary.DoMultiCache(ctx, multi...)
}</span>

func (s *standalone) DoStream(ctx context.Context, cmd Completed) ValkeyResultStream <span class="cov0" title="0">{
        var stream ValkeyResultStream
        if s.toReplicas != nil &amp;&amp; s.toReplicas(cmd) </span><span class="cov0" title="0">{
                stream = s.replicas[s.pick()].DoStream(ctx, cmd)
        }</span> else<span class="cov0" title="0"> {
                stream = s.primary.DoStream(ctx, cmd)
        }</span>
        
        // Check if there's a redirect error in the stream
        <span class="cov0" title="0">if s.enableRedirect &amp;&amp; stream.Error() != nil </span><span class="cov0" title="0">{
                if ret, yes := IsValkeyErr(stream.Error()); yes </span><span class="cov0" title="0">{
                        if addr, ok := ret.IsRedirect(); ok </span><span class="cov0" title="0">{
                                // Create a new connection to the redirect address
                                redirectOpt := *s.opt
                                redirectOpt.InitAddress = []string{addr}
                                redirectConn := s.connFn(addr, &amp;redirectOpt)
                                if err := redirectConn.Dial(); err != nil </span><span class="cov0" title="0">{
                                        // If redirect fails, return the original stream
                                        return stream
                                }</span>
                                <span class="cov0" title="0">defer redirectConn.Close()
                                
                                // Create a temporary client for the redirect
                                redirectClient := newSingleClientWithConn(redirectConn, cmds.NewBuilder(cmds.NoSlot), !s.opt.DisableRetry, s.opt.DisableCache, s.retryer, false)
                                defer redirectClient.Close()
                                
                                // Execute the command on the redirect target
                                return redirectClient.DoStream(ctx, cmd)</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return stream</span>
}

func (s *standalone) DoMultiStream(ctx context.Context, multi ...Completed) MultiValkeyResultStream <span class="cov0" title="0">{
        var stream MultiValkeyResultStream
        toReplica := true
        for _, cmd := range multi </span><span class="cov0" title="0">{
                if s.toReplicas == nil || !s.toReplicas(cmd) </span><span class="cov0" title="0">{
                        toReplica = false
                        break</span>
                }
        }
        <span class="cov0" title="0">if toReplica </span><span class="cov0" title="0">{
                stream = s.replicas[s.pick()].DoMultiStream(ctx, multi...)
        }</span> else<span class="cov0" title="0"> {
                stream = s.primary.DoMultiStream(ctx, multi...)
        }</span>
        
        // Check if there's a redirect error in the stream
        <span class="cov0" title="0">if s.enableRedirect &amp;&amp; stream.Error() != nil </span><span class="cov0" title="0">{
                if ret, yes := IsValkeyErr(stream.Error()); yes </span><span class="cov0" title="0">{
                        if addr, ok := ret.IsRedirect(); ok </span><span class="cov0" title="0">{
                                // Create a new connection to the redirect address
                                redirectOpt := *s.opt
                                redirectOpt.InitAddress = []string{addr}
                                redirectConn := s.connFn(addr, &amp;redirectOpt)
                                if err := redirectConn.Dial(); err != nil </span><span class="cov0" title="0">{
                                        // If redirect fails, return the original stream
                                        return stream
                                }</span>
                                <span class="cov0" title="0">defer redirectConn.Close()
                                
                                // Create a temporary client for the redirect
                                redirectClient := newSingleClientWithConn(redirectConn, cmds.NewBuilder(cmds.NoSlot), !s.opt.DisableRetry, s.opt.DisableCache, s.retryer, false)
                                defer redirectClient.Close()
                                
                                // Execute the command on the redirect target
                                return redirectClient.DoMultiStream(ctx, multi...)</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return stream</span>
}

func (s *standalone) Dedicated(fn func(DedicatedClient) error) (err error) <span class="cov0" title="0">{
        return s.primary.Dedicated(fn)
}</span>

func (s *standalone) Dedicate() (client DedicatedClient, cancel func()) <span class="cov0" title="0">{
        return s.primary.Dedicate()
}</span>

func (s *standalone) Nodes() map[string]Client <span class="cov0" title="0">{
        nodes := make(map[string]Client, len(s.replicas)+1)
        for addr, client := range s.primary.Nodes() </span><span class="cov0" title="0">{
                nodes[addr] = client
        }</span>
        <span class="cov0" title="0">for _, replica := range s.replicas </span><span class="cov0" title="0">{
                for addr, client := range replica.Nodes() </span><span class="cov0" title="0">{
                        nodes[addr] = client
                }</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

func (s *standalone) Mode() ClientMode <span class="cov8" title="1">{
        return ClientModeStandalone
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package valkey

import (
        "time"

        "github.com/valkey-io/valkey-go/internal/util"
)

var (
        resultsp = util.NewPool(func(capacity int) *valkeyresults <span class="cov8" title="1">{
                return &amp;valkeyresults{s: make([]ValkeyResult, 0, capacity)}
        }</span>)
        mgetcmdsp = util.NewPool(func(capacity int) *mgetcmds <span class="cov0" title="0">{
                return &amp;mgetcmds{s: make([]Completed, 0, capacity)}
        }</span>)
        retryp = util.NewPool(func(capacity int) *retry <span class="cov0" title="0">{
                return &amp;retry{
                        cIndexes: make([]int, 0, capacity),
                        commands: make([]Completed, 0, capacity),
                }
        }</span>)
        mgetcachecmdsp = util.NewPool(func(capacity int) *mgetcachecmds <span class="cov0" title="0">{
                return &amp;mgetcachecmds{s: make([]CacheableTTL, 0, capacity)}
        }</span>)
        retrycachep = util.NewPool(func(capacity int) *retrycache <span class="cov0" title="0">{
                return &amp;retrycache{
                        cIndexes: make([]int, 0, capacity),
                        commands: make([]CacheableTTL, 0, capacity),
                }
        }</span>)
        batchcachep = util.NewPool(func(capacity int) *batchcache <span class="cov0" title="0">{
                return &amp;batchcache{
                        cIndexes: make([]int, 0, capacity),
                        commands: make([]CacheableTTL, 0, capacity),
                }
        }</span>)
        batchcachemaps = util.NewPool(func(capacity int) *batchcachemap <span class="cov0" title="0">{
                return &amp;batchcachemap{m: make(map[uint16]*batchcache, capacity), n: capacity}
        }</span>)
        muxslotsp = util.NewPool(func(capacity int) *muxslots <span class="cov0" title="0">{
                return &amp;muxslots{s: make([]int, 0, capacity)}
        }</span>)
        connretryp = util.NewPool(func(capacity int) *connretry <span class="cov0" title="0">{
                return &amp;connretry{m: make(map[conn]*retry, capacity), n: capacity}
        }</span>)
        conncountp = util.NewPool(func(capacity int) *conncount <span class="cov0" title="0">{
                return &amp;conncount{m: make(map[conn]int, capacity), n: capacity}
        }</span>)
        connretrycachep = util.NewPool(func(capacity int) *connretrycache <span class="cov0" title="0">{
                return &amp;connretrycache{m: make(map[conn]*retrycache, capacity), n: capacity}
        }</span>)
)

type muxslots struct {
        s []int
}

func (r *muxslots) Capacity() int <span class="cov0" title="0">{
        return cap(r.s)
}</span>

func (r *muxslots) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.s)
        r.s = r.s[:n]
}</span>

func (r *muxslots) LessThen(n int) bool <span class="cov0" title="0">{
        count := 0
        for _, value := range r.s </span><span class="cov0" title="0">{
                if value &gt; 0 </span><span class="cov0" title="0">{
                        if count++; count == n </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

type valkeyresults struct {
        s []ValkeyResult
}

func (r *valkeyresults) Capacity() int <span class="cov8" title="1">{
        return cap(r.s)
}</span>

func (r *valkeyresults) ResetLen(n int) <span class="cov8" title="1">{
        clear(r.s)
        r.s = r.s[:n]
}</span>

type cacheentries struct {
        e map[int]CacheEntry
        c int
}

func (c *cacheentries) Capacity() int <span class="cov0" title="0">{
        return c.c
}</span>

func (c *cacheentries) ResetLen(n int) <span class="cov0" title="0">{
        clear(c.e)
}</span>

var entriesp = util.NewPool(func(capacity int) *cacheentries <span class="cov0" title="0">{
        return &amp;cacheentries{e: make(map[int]CacheEntry, capacity), c: capacity}
}</span>)

type mgetcachecmds struct {
        s []CacheableTTL
}

func (r *mgetcachecmds) Capacity() int <span class="cov0" title="0">{
        return cap(r.s)
}</span>

func (r *mgetcachecmds) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.s)
        r.s = r.s[:n]
}</span>

type mgetcmds struct {
        s []Completed
}

func (r *mgetcmds) Capacity() int <span class="cov0" title="0">{
        return cap(r.s)
}</span>

func (r *mgetcmds) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.s)
        r.s = r.s[:n]
}</span>

type retry struct {
        cIndexes []int
        commands []Completed
        aIndexes []int
        cAskings []Completed
}

func (r *retry) Capacity() int <span class="cov0" title="0">{
        return cap(r.commands)
}</span>

func (r *retry) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.cIndexes)
        clear(r.commands)
        clear(r.aIndexes)
        clear(r.cAskings)
        r.cIndexes = r.cIndexes[:n]
        r.commands = r.commands[:n]
        r.aIndexes = r.aIndexes[:0]
        r.cAskings = r.cAskings[:0]
}</span>

type retrycache struct {
        cIndexes []int
        commands []CacheableTTL
        aIndexes []int
        cAskings []CacheableTTL
}

func (r *retrycache) Capacity() int <span class="cov0" title="0">{
        return cap(r.commands)
}</span>

func (r *retrycache) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.cIndexes)
        clear(r.commands)
        clear(r.aIndexes)
        clear(r.cAskings)
        r.cIndexes = r.cIndexes[:n]
        r.commands = r.commands[:n]
        r.aIndexes = r.aIndexes[:0]
        r.cAskings = r.cAskings[:0]
}</span>

type batchcache struct {
        cIndexes []int
        commands []CacheableTTL
}

func (r *batchcache) Capacity() int <span class="cov0" title="0">{
        return cap(r.commands)
}</span>

func (r *batchcache) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.cIndexes)
        clear(r.commands)
        r.cIndexes = r.cIndexes[:n]
        r.commands = r.commands[:n]
}</span>

type batchcachemap struct {
        m map[uint16]*batchcache
        n int
}

func (r *batchcachemap) Capacity() int <span class="cov0" title="0">{
        return r.n
}</span>

func (r *batchcachemap) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.m)
}</span>

type conncount struct {
        m map[conn]int
        n int
}

func (r *conncount) Capacity() int <span class="cov0" title="0">{
        return r.n
}</span>

func (r *conncount) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.m)
}</span>

type connretry struct {
        m          map[conn]*retry
        n          int
        RetryDelay time.Duration // NOTE: This is not thread-safe.
        Redirects  uint32        // NOTE: This is not thread-safe.
}

func (r *connretry) Capacity() int <span class="cov0" title="0">{
        return r.n
}</span>

func (r *connretry) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.m)
        r.Redirects = 0
        r.RetryDelay = time.Duration(-1) // No retry.
}</span>

type connretrycache struct {
        m          map[conn]*retrycache
        n          int
        RetryDelay time.Duration // NOTE: This is not thread-safe.
        Redirects  uint32        // NOTE: This is not thread-safe.
}

func (r *connretrycache) Capacity() int <span class="cov0" title="0">{
        return r.n
}</span>

func (r *connretrycache) ResetLen(n int) <span class="cov0" title="0">{
        clear(r.m)
        r.Redirects = 0
        r.RetryDelay = time.Duration(-1) // No retry.
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package valkey

import (
        "context"
        "crypto/tls"
        "fmt"
        "net"
        "net/url"
        "strconv"
        "strings"
        "time"
)

// ParseURL parses a valkey URL into ClientOption.
// https://github.com/redis/redis-specifications/blob/master/uri/redis.txt
// Example:
//
// redis://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;db_number&gt;
// redis://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;?addr=&lt;host2&gt;:&lt;port2&gt;&amp;addr=&lt;host3&gt;:&lt;port3&gt;
// unix://&lt;user&gt;:&lt;password&gt;@&lt;/path/to/redis.sock&gt;?db=&lt;db_number&gt;
func ParseURL(str string) (opt ClientOption, err error) <span class="cov0" title="0">{
        u, err := url.Parse(str)
        if err != nil </span><span class="cov0" title="0">{
                return opt, err
        }</span>
        <span class="cov0" title="0">parseAddr := func(hostport string) (host string, addr string) </span><span class="cov0" title="0">{
                host, port, _ := net.SplitHostPort(hostport)
                if host == "" </span><span class="cov0" title="0">{
                        host = u.Host
                }</span>
                <span class="cov0" title="0">if host == "" </span><span class="cov0" title="0">{
                        host = "localhost"
                }</span>
                <span class="cov0" title="0">if port == "" </span><span class="cov0" title="0">{
                        port = "6379"
                }</span>
                <span class="cov0" title="0">return host, net.JoinHostPort(host, port)</span>
        }
        <span class="cov0" title="0">switch u.Scheme </span>{
        case "unix":<span class="cov0" title="0">
                opt.DialCtxFn = func(ctx context.Context, s string, dialer *net.Dialer, config *tls.Config) (conn net.Conn, err error) </span><span class="cov0" title="0">{
                        return dialer.DialContext(ctx, "unix", s)
                }</span>
                <span class="cov0" title="0">opt.InitAddress = []string{strings.TrimSpace(u.Path)}</span>
        case "rediss", "valkeys":<span class="cov0" title="0">
                opt.TLSConfig = &amp;tls.Config{
                        MinVersion: tls.VersionTLS12,
                }</span>
        case "redis", "valkey":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return opt, fmt.Errorf("valkey: invalid URL scheme: %s", u.Scheme)</span>
        }
        <span class="cov0" title="0">if opt.InitAddress == nil </span><span class="cov0" title="0">{
                host, addr := parseAddr(u.Host)
                opt.InitAddress = []string{addr}
                if opt.TLSConfig != nil </span><span class="cov0" title="0">{
                        opt.TLSConfig.ServerName = host
                }</span>
        }
        <span class="cov0" title="0">if u.User != nil </span><span class="cov0" title="0">{
                opt.Username = u.User.Username()
                opt.Password, _ = u.User.Password()
        }</span>
        <span class="cov0" title="0">if u.Scheme != "unix" </span><span class="cov0" title="0">{
                if ps := strings.Split(u.Path, "/"); len(ps) == 2 </span><span class="cov0" title="0">{
                        if opt.SelectDB, err = strconv.Atoi(ps[1]); err != nil </span><span class="cov0" title="0">{
                                return opt, fmt.Errorf("valkey: invalid database number: %q", ps[1])
                        }</span>
                } else<span class="cov0" title="0"> if len(ps) &gt; 2 </span><span class="cov0" title="0">{
                        return opt, fmt.Errorf("valkey: invalid URL path: %s", u.Path)
                }</span>
        }
        <span class="cov0" title="0">q := u.Query()
        if q.Has("db") </span><span class="cov0" title="0">{
                if opt.SelectDB, err = strconv.Atoi(q.Get("db")); err != nil </span><span class="cov0" title="0">{
                        return opt, fmt.Errorf("valkey: invalid database number: %q", q.Get("db"))
                }</span>
        }
        <span class="cov0" title="0">if q.Has("dial_timeout") </span><span class="cov0" title="0">{
                if opt.Dialer.Timeout, err = time.ParseDuration(q.Get("dial_timeout")); err != nil </span><span class="cov0" title="0">{
                        return opt, fmt.Errorf("valkey: invalid dial timeout: %q", q.Get("dial_timeout"))
                }</span>
        }
        <span class="cov0" title="0">if q.Has("write_timeout") </span><span class="cov0" title="0">{
                if opt.Dialer.Timeout, err = time.ParseDuration(q.Get("write_timeout")); err != nil </span><span class="cov0" title="0">{
                        return opt, fmt.Errorf("valkey: invalid write timeout: %q", q.Get("write_timeout"))
                }</span>
        }
        <span class="cov0" title="0">for _, addr := range q["addr"] </span><span class="cov0" title="0">{
                _, addr = parseAddr(addr)
                opt.InitAddress = append(opt.InitAddress, addr)
        }</span>
        <span class="cov0" title="0">if opt.TLSConfig != nil &amp;&amp; q.Has("skip_verify") </span><span class="cov0" title="0">{
                skipVerifyParam := q.Get("skip_verify")
                if skipVerifyParam == "" </span><span class="cov0" title="0">{
                        opt.TLSConfig.InsecureSkipVerify = true
                }</span> else<span class="cov0" title="0"> {
                        skipVerify, err := strconv.ParseBool(skipVerifyParam)
                        if err != nil </span><span class="cov0" title="0">{
                                return opt, fmt.Errorf("valkey: invalid skip verify: %q", skipVerifyParam)
                        }</span>
                        <span class="cov0" title="0">opt.TLSConfig.InsecureSkipVerify = skipVerify</span>
                }
        }
        <span class="cov0" title="0">opt.AlwaysRESP2 = q.Get("protocol") == "2"
        opt.DisableCache = q.Get("client_cache") == "0"
        opt.DisableRetry = q.Get("max_retries") == "0"
        opt.ClientName = q.Get("client_name")
        opt.Sentinel.MasterSet = q.Get("master_set")
        return</span>
}

func MustParseURL(str string) ClientOption <span class="cov0" title="0">{
        opt, err := ParseURL(str)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return opt</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package valkey is a fast Golang Valkey RESP3 client that does auto pipelining and supports client side caching.
package valkey

//go:generate go run hack/cmds/gen.go internal/cmds hack/cmds/*.json

import (
        "context"
        "crypto/tls"
        "errors"
        "math"
        "net"
        "runtime"
        "strings"
        "time"

        "github.com/valkey-io/valkey-go/internal/util"
)

const (
        // DefaultCacheBytes is the default value of ClientOption.CacheSizeEachConn, which is 128 MiB
        DefaultCacheBytes = 128 * (1 &lt;&lt; 20)
        // DefaultRingScale is the default value of ClientOption.RingScaleEachConn, which results into having a ring of size 2^10 for each connection
        DefaultRingScale = 10
        // DefaultPoolSize is the default value of ClientOption.BlockingPoolSize
        DefaultPoolSize = 1024
        // DefaultBlockingPipeline is the default value of ClientOption.BlockingPipeline
        DefaultBlockingPipeline = 2000
        // DefaultDialTimeout is the default value of ClientOption.Dialer.Timeout
        DefaultDialTimeout = 5 * time.Second
        // DefaultTCPKeepAlive is the default value of ClientOption.Dialer.KeepAlive
        DefaultTCPKeepAlive = 1 * time.Second
        // DefaultReadBuffer is the default value of bufio.NewReaderSize for each connection, which is 0.5MiB
        DefaultReadBuffer = 1 &lt;&lt; 19
        // DefaultWriteBuffer is the default value of bufio.NewWriterSize for each connection, which is 0.5MiB
        DefaultWriteBuffer = 1 &lt;&lt; 19
        // MaxPipelineMultiplex is the maximum meaningful value for ClientOption.PipelineMultiplex
        MaxPipelineMultiplex = 8
        // https://github.com/valkey-io/valkey/blob/1a34a4ff7f101bb6b17a0b5e9aa3bf7d6bd29f68/src/networking.c#L4118-L4124
        ClientModeCluster    ClientMode = "cluster"
        ClientModeSentinel   ClientMode = "sentinel"
        ClientModeStandalone ClientMode = "standalone"
)

var (
        // ErrClosing means the Client.Close had been called
        ErrClosing = errors.New("valkey client is closing or unable to connect valkey")
        // ErrNoAddr means the ClientOption.InitAddress is empty
        ErrNoAddr = errors.New("no alive address in InitAddress")
        // ErrNoCache means your valkey does not support client-side caching and must set ClientOption.DisableCache to true
        ErrNoCache = errors.New("ClientOption.DisableCache must be true for valkey not supporting client-side caching or not supporting RESP3")
        // ErrRESP2PubSubMixed means your valkey does not support RESP3 and valkey can't handle SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE in mixed case
        ErrRESP2PubSubMixed = errors.New("valkey does not support SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE mixed with other commands in RESP2")
        // ErrBlockingPubSubMixed valkey can't handle SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE mixed with other blocking commands
        ErrBlockingPubSubMixed = errors.New("valkey does not support SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE mixed with other blocking commands")
        // ErrDoCacheAborted means valkey abort EXEC request or connection closed
        ErrDoCacheAborted = errors.New("failed to fetch the cache because EXEC was aborted by valkey or connection closed")
        // ErrReplicaOnlyNotSupported means ReplicaOnly flag is not supported by
        // the current client
        ErrReplicaOnlyNotSupported = errors.New("ReplicaOnly is not supported for single client")
        // ErrNoSendToReplicas means the SendToReplicas function must be provided for a standalone client with replicas.
        ErrNoSendToReplicas = errors.New("no SendToReplicas provided for standalone client with replicas")
        // ErrWrongPipelineMultiplex means wrong value for ClientOption.PipelineMultiplex
        ErrWrongPipelineMultiplex = errors.New("ClientOption.PipelineMultiplex must not be bigger than MaxPipelineMultiplex")
        // ErrDedicatedClientRecycled means the caller attempted to use the dedicated client which has been already recycled (after canceled/closed).
        ErrDedicatedClientRecycled = errors.New("dedicated client should not be used after recycled")
        // DisableClientSetInfo is the value that can be used for ClientOption.ClientSetInfo to disable making the CLIENT SETINFO command
        DisableClientSetInfo = make([]string, 0)
)

// ClientOption should be passed to NewClient to construct a Client
type ClientOption struct {
        TLSConfig *tls.Config

        // DialFn allows for a custom function to be used to create net.Conn connections
        // Deprecated: use DialCtxFn instead.
        DialFn func(string, *net.Dialer, *tls.Config) (conn net.Conn, err error)

        // DialCtxFn allows for a custom function to be used to create net.Conn connections
        DialCtxFn func(context.Context, string, *net.Dialer, *tls.Config) (conn net.Conn, err error)

        // NewCacheStoreFn allows a custom client side caching store for each connection
        NewCacheStoreFn NewCacheStoreFn

        // OnInvalidations is a callback function in case of client-side caching invalidation received.
        // Note that this function must be fast; otherwise other valkey messages will be blocked.
        OnInvalidations func([]ValkeyMessage)

        // SendToReplicas is a function that returns true if the command should be sent to replicas.
        // NOTE: This function can't be used with the ReplicaOnly option.
        SendToReplicas func(cmd Completed) bool

        // AuthCredentialsFn allows for setting the AUTH username and password dynamically on each connection attempt to
        // support rotating credentials
        AuthCredentialsFn func(AuthCredentialsContext) (AuthCredentials, error)

        // RetryDelay is the function that returns the delay that should be used before retrying the attempt.
        // The default is an exponential backoff with a maximum delay of 1 second.
        // Only used when DisableRetry is false.
        RetryDelay RetryDelayFn

        // ReplicaSelector selects a replica node when `SendToReplicas` returns true.
        // If the function is set, the client will send the selected command to the replica node.
        // The Returned value is the index of the replica node in the replica slice.
        // If the returned value is out of range, the primary node will be selected.
        // If the primary node does not have any replica, the primary node will be selected
        // and the function will not be called.
        // Currently only used for a cluster client.
        // Each ReplicaInfo must not be modified.
        // NOTE: This function can't be used with ReplicaOnly option.
        // NOTE: This function must be used with the SendToReplicas function.
        ReplicaSelector func(slot uint16, replicas []ReplicaInfo) int

        // Sentinel options, including MasterSet and Auth options
        Sentinel SentinelOption

        // TCP &amp; TLS
        // Dialer can be used to customize how valkey connect to a valkey instance via TCP, including
        // - Timeout, the default is DefaultDialTimeout
        // - KeepAlive, the default is DefaultTCPKeepAlive
        // The Dialer.KeepAlive interval is used to detect an unresponsive idle tcp connection.
        // OS takes at least (tcp_keepalive_probes+1)*Dialer.KeepAlive time to conclude an idle connection to be unresponsive.
        // For example, DefaultTCPKeepAlive = 1s and the default of tcp_keepalive_probes on Linux is 9.
        // Therefore, it takes at least 10s to kill an idle and unresponsive tcp connection on Linux by default.
        Dialer net.Dialer

        // Valkey AUTH parameters
        Username   string
        Password   string
        ClientName string

        // ClientSetInfo will assign various info attributes to the current connection.
        // Note that ClientSetInfo should have exactly 2 values, the lib name and the lib version respectively.
        ClientSetInfo []string

        // InitAddress point to valkey nodes.
        // Valkey will connect to them one by one and issue a CLUSTER SLOT command to initialize the cluster client until success.
        // If len(InitAddress) == 1 and the address is not running in cluster mode, valkey will fall back to the single client mode.
        // If ClientOption.Sentinel.MasterSet is set, then InitAddress will be used to connect sentinels
        // You can bypass this behavior by using ClientOption.ForceSingleClient.
        InitAddress []string

        // ClientTrackingOptions will be appended to the CLIENT TRACKING ON command when the connection is established.
        // The default is []string{"OPTIN"}
        ClientTrackingOptions []string

        // Standalone is the option for the standalone client.
        Standalone StandaloneOption

        SelectDB int

        // CacheSizeEachConn is valkey client side cache size that bind to each TCP connection to a single valkey instance.
        // The default is DefaultCacheBytes.
        CacheSizeEachConn int

        // RingScaleEachConn sets the size of the ring buffer in each connection to (2 ^ RingScaleEachConn).
        // The default is RingScaleEachConn, which results in having a ring of size 2^10 for each connection.
        // Reducing this value can reduce the memory consumption of each connection at the cost of potential throughput degradation.
        // Values smaller than 8 are typically not recommended.
        RingScaleEachConn int

        // ReadBufferEachConn is the size of the bufio.NewReaderSize for each connection, default to DefaultReadBuffer (0.5 MiB).
        ReadBufferEachConn int
        // WriteBufferEachConn is the size of the bufio.NewWriterSize for each connection, default to DefaultWriteBuffer (0.5 MiB).
        WriteBufferEachConn int

        // BlockingPoolCleanup is the duration for cleaning up idle connections.
        // If BlockingPoolCleanup is 0, then idle connections will not be cleaned up.
        BlockingPoolCleanup time.Duration
        // BlockingPoolMinSize is the minimum size of the connection pool
        // shared by blocking commands (ex BLPOP, XREAD with BLOCK).
        // Only relevant if BlockingPoolCleanup is not 0. This parameter limits
        // the number of idle connections that can be removed by BlockingPoolCleanup.
        BlockingPoolMinSize int

        // BlockingPoolSize is the size of the connection pool shared by blocking commands (ex BLPOP, XREAD with BLOCK).
        // The default is DefaultPoolSize.
        BlockingPoolSize int
        // BlockingPipeline is the threshold of a pipeline that will be treated as blocking commands when exceeding it.
        BlockingPipeline int

        // PipelineMultiplex determines how many tcp connections used to pipeline commands to one valkey instance.
        // The default for single and sentinel clients is 2, which means 4 connections (2^2).
        // The default for cluster clients is 0, which means 1 connection (2^0).
        PipelineMultiplex int

        // ConnWriteTimeout is a read/write timeout for each connection. If specified,
        // it is used to control the maximum duration waits for responses to pipeline commands.
        // Also, ConnWriteTimeout is applied net.Conn.SetDeadline and periodic PINGs,
        // since the Dialer.KeepAlive will not be triggered if there is data in the outgoing buffer.
        // ConnWriteTimeout should be set to detect local congestion or unresponsive valkey server.
        // This default is ClientOption.Dialer.KeepAlive * (9+1), where 9 is the default of tcp_keepalive_probes on Linux.
        ConnWriteTimeout time.Duration

        // ConnLifetime is a lifetime for each connection. If specified,
        // connections will close after passing lifetime. Note that the connection which a dedicated client and blocking use is not closed.
        ConnLifetime time.Duration

        // MaxFlushDelay when greater than zero pauses pipeline write loop for some time (not larger than MaxFlushDelay)
        // after each flushing of data to the connection. This gives the pipeline a chance to collect more commands to send
        // to Valkey. Adding this delay increases latency, reduces throughput – but in most cases may significantly reduce
        // application and Valkey CPU utilization due to less executed system calls. By default, Valkey flushes data to the
        // connection without extra delays. Depending on network latency and application-specific conditions, the value
        // of MaxFlushDelay may vary, something like 20 microseconds should not affect latency/throughput a lot but still
        // produce notable CPU usage reduction under load. Ref: https://github.com/redis/rueidis/issues/156
        MaxFlushDelay time.Duration

        // ClusterOption is the options for the valkey cluster client.
        ClusterOption ClusterOption

        // DisableTCPNoDelay turns on Nagle's algorithm in pipelining mode by using conn.SetNoDelay(false).
        // Turning this on can result in lower p99 latencies and lower CPU usages if all your requests are small.
        // But if you have large requests or fast network, this might degrade the performance. Ref: https://github.com/redis/rueidis/pull/650
        DisableTCPNoDelay bool

        // ShuffleInit is a handy flag that shuffles the InitAddress after passing to the NewClient() if it is true
        ShuffleInit bool
        // ClientNoTouch controls whether commands alter LRU/LFU stats
        ClientNoTouch bool
        // DisableRetry disables retrying read-only commands under network errors
        DisableRetry bool
        // DisableCache falls back Client.DoCache/Client.DoMultiCache to Client.Do/Client.DoMulti
        DisableCache bool
        // DisableAutoPipelining makes valkey.Client always pick a connection from the BlockingPool to serve each request.
        DisableAutoPipelining bool
        // AlwaysPipelining makes valkey.Client always pipeline valkey commands even if they are not issued concurrently.
        AlwaysPipelining bool
        // AlwaysRESP2 makes valkey.Client always uses RESP2; otherwise, it will try using RESP3 first.
        AlwaysRESP2 bool
        //  ForceSingleClient force the usage of a single client connection, without letting the lib guessing
        //  if valkey instance is a cluster or a single valkey instance.
        ForceSingleClient bool

        // ReplicaOnly indicates that this client will only try to connect to readonly replicas of valkey setup.
        ReplicaOnly bool

        // ClientNoEvict sets the client eviction mode for the current connection.
        // When turned on and client eviction is configured,
        // the current connection will be excluded from the client eviction process
        // even if we're above the configured client eviction threshold.
        ClientNoEvict bool

        // EnableReplicaAZInfo enables the client to load the replica node's availability zone.
        // If true, the client will set the `AZ` field in `ReplicaInfo`.
        EnableReplicaAZInfo bool
}

// SentinelOption contains MasterSet,
type SentinelOption struct {
        // TCP &amp; TLS, same as ClientOption but for connecting sentinel
        Dialer    net.Dialer
        TLSConfig *tls.Config

        // MasterSet is the valkey master set name monitored by sentinel cluster.
        // If this field is set, then ClientOption.InitAddress will be used to connect to the sentinel cluster.
        MasterSet string

        // Valkey AUTH parameters for sentinel
        Username   string
        Password   string
        ClientName string
}

// ClusterOption is the options for the valkey cluster client.
type ClusterOption struct {
        // ShardsRefreshInterval is the interval to scan the cluster topology.
        // If the value is zero, refreshment will be disabled.
        // Cluster topology cache refresh happens always in the background after a successful scan.
        ShardsRefreshInterval time.Duration
}

// StandaloneOption is the options for the standalone client.
type StandaloneOption struct {
        // ReplicaAddress is the list of replicas for the primary node.
        // Note that these addresses must be online and cannot be promoted.
        // An example use case is the reader endpoint provided by cloud vendors.
        ReplicaAddress []string
        // EnableRedirect enables the CLIENT CAPA redirect feature for Valkey 8+
        // When enabled, the client will send CLIENT CAPA redirect during connection
        // initialization and handle REDIRECT responses from the server.
        EnableRedirect bool
}

// ReplicaInfo is the information of a replica node in a valkey cluster.
type ReplicaInfo struct {
        Addr string
        AZ   string
}

type ClientMode string

// Client is the valkey client interface for both single valkey instance and valkey cluster. It should be created from the NewClient()
type Client interface {
        CoreClient

        // DoCache is similar to Do, but it uses opt-in client side caching and requires a client side TTL.
        // The explicit client side TTL specifies the maximum TTL on the client side.
        // If the key's TTL on the server is smaller than the client side TTL, the client side TTL will be capped.
        //  client.Do(ctx, client.B().Get().Key("k").Cache(), time.Minute).ToString()
        // The above example will send the following command to valkey if the cache misses:
        //  CLIENT CACHING YES
        //  PTTL k
        //  GET k
        // The in-memory cache size is configured by ClientOption.CacheSizeEachConn.
        // The cmd parameter is recycled after passing into DoCache() and should not be reused.
        DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp ValkeyResult)

        // DoMultiCache is similar to DoCache but works with multiple cacheable commands across different slots.
        // It will first group commands by slots and will send only cache missed commands to valkey.
        DoMultiCache(ctx context.Context, multi ...CacheableTTL) (resp []ValkeyResult)

        // DoStream send a command to valkey through a dedicated connection acquired from a connection pool.
        // It returns a ValkeyResultStream, but it does not read the command response until the ValkeyResultStream.WriteTo is called.
        // After the ValkeyResultStream.WriteTo is called, the underlying connection is then recycled.
        // DoStream should only be used when you want to stream valkey response directly to an io.Writer without additional allocation,
        // otherwise, the normal Do() should be used instead.
        // Also note that DoStream can only work with commands returning string, integer, or float response.
        DoStream(ctx context.Context, cmd Completed) ValkeyResultStream

        // DoMultiStream is similar to DoStream, but pipelines multiple commands to valkey.
        // It returns a MultiValkeyResultStream, and users should call MultiValkeyResultStream.WriteTo as many times as the number of commands sequentially
        // to read each command response from valkey. After all responses are read, the underlying connection is then recycled.
        // DoMultiStream should only be used when you want to stream valkey responses directly to an io.Writer without additional allocation,
        // otherwise, the normal DoMulti() should be used instead.
        // DoMultiStream does not support multiple key slots when connecting to a valkey cluster.
        DoMultiStream(ctx context.Context, multi ...Completed) MultiValkeyResultStream

        // Dedicated acquire a connection from the blocking connection pool, no one else can use the connection
        // during Dedicated. The main usage of Dedicated is CAS operations, which is WATCH + MULTI + EXEC.
        // However, one should try to avoid CAS operation but use a Lua script instead, because occupying a connection
        // is not good for performance.
        Dedicated(fn func(DedicatedClient) error) (err error)

        // Dedicate does the same as Dedicated, but it exposes DedicatedClient directly
        // and requires user to invoke cancel() manually to put connection back to the pool.
        Dedicate() (client DedicatedClient, cancel func())

        // Nodes returns each valkey node this client known as valkey.Client. This is useful if you want to
        // send commands to some specific valkey nodes in the cluster.
        Nodes() map[string]Client
        // Mode returns the current mode of the client, which indicates whether the client is operating
        // in standalone, sentinel, or cluster mode.
        // This can be useful for determining the type of Valkey deployment the client is connected to
        // and for making decisions based on the deployment type.
        Mode() ClientMode
}

// DedicatedClient is obtained from Client.Dedicated() and it will be bound to a single valkey connection, and
// no other commands can be pipelined into this connection during Client.Dedicated().
// If the DedicatedClient is obtained from a cluster client, the first command to it must have a Key() to identify the valkey node.
type DedicatedClient interface {
        CoreClient

        // SetPubSubHooks is an alternative way to processing Pub/Sub messages instead of using Receive.
        // SetPubSubHooks is non-blocking and allows users to subscribe/unsubscribe channels later.
        // Note that the hooks will be called sequentially but in another goroutine.
        // The return value will be either:
        //   1. an error channel, if the hooks passed in are not zero, or
        //   2. nil, if the hooks passed in are zero. (used for reset hooks)
        // In the former case, the error channel is guaranteed to be close when the hooks will not be called anymore
        // and has at most one error describing the reason why the hooks will not be called anymore.
        // Users can use the error channel to detect disconnection.
        SetPubSubHooks(hooks PubSubHooks) &lt;-chan error
}

// CoreClient is the minimum interface shared by the Client and the DedicatedClient.
type CoreClient interface {
        // B is the getter function to the command builder for the client
        // If the client is a cluster client, the command builder also prohibits cross-key slots in one command.
        B() Builder
        // Do is the method sending user's valkey command building from the B() to a valkey node.
        //  client.Do(ctx, client.B().Get().Key("k").Build()).ToString()
        // All concurrent non-blocking commands will be pipelined automatically and have better throughput.
        // Blocking commands will use another separated connection pool.
        // The cmd parameter is recycled after passing into Do() and should not be reused.
        Do(ctx context.Context, cmd Completed) (resp ValkeyResult)
        // DoMulti takes multiple valkey commands and sends them together, reducing RTT from the user code.
        // The multi parameters are recycled after passing into DoMulti() and should not be reused.
        DoMulti(ctx context.Context, multi ...Completed) (resp []ValkeyResult)
        // Receive accepts SUBSCRIBE, SSUBSCRIBE, PSUBSCRIBE command and a message handler.
        // Receive will block and then return value only when the following cases:
        //   1. return nil when received any unsubscribe/punsubscribe message related to the provided `subscribe` command.
        //   2. return ErrClosing when the client is closed manually.
        //   3. return ctx.Err() when the `ctx` is done.
        //   4. return non-nil err when the provided `subscribe` command failed.
        Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) error
        // Close will make further calls to the client be rejected with ErrClosing,
        // and Close will wait until all pending calls finished.
        Close()
}

// CT is a shorthand constructor for CacheableTTL
func CT(cmd Cacheable, ttl time.Duration) CacheableTTL <span class="cov0" title="0">{
        return CacheableTTL{Cmd: cmd, TTL: ttl}
}</span>

// CacheableTTL is a parameter container of DoMultiCache
type CacheableTTL struct {
        Cmd Cacheable
        TTL time.Duration
}

// AuthCredentialsContext is the parameter container of AuthCredentialsFn
type AuthCredentialsContext struct {
        Address net.Addr
}

// AuthCredentials is the output of AuthCredentialsFn
type AuthCredentials struct {
        Username string
        Password string
}

// NewClient uses ClientOption to initialize the Client for both a cluster client and a single client.
// It will first try to connect as a cluster client. If the len(ClientOption.InitAddress) == 1 and
// the address does not enable cluster mode, the NewClient() will use single client instead.
func NewClient(option ClientOption) (client Client, err error) <span class="cov8" title="1">{
        if option.ReadBufferEachConn &lt; 32 </span><span class="cov8" title="1">{ // the buffer should be able to hold an int64 string at least
                option.ReadBufferEachConn = DefaultReadBuffer
        }</span>
        <span class="cov8" title="1">if option.WriteBufferEachConn &lt; 32 </span><span class="cov8" title="1">{
                option.WriteBufferEachConn = DefaultWriteBuffer
        }</span>
        <span class="cov8" title="1">if option.CacheSizeEachConn &lt;= 0 </span><span class="cov8" title="1">{
                option.CacheSizeEachConn = DefaultCacheBytes
        }</span>
        <span class="cov8" title="1">if option.Dialer.Timeout == 0 </span><span class="cov8" title="1">{
                option.Dialer.Timeout = DefaultDialTimeout
        }</span>
        <span class="cov8" title="1">if option.Dialer.KeepAlive == 0 </span><span class="cov8" title="1">{
                option.Dialer.KeepAlive = DefaultTCPKeepAlive
        }</span>
        <span class="cov8" title="1">if option.ConnWriteTimeout == 0 </span><span class="cov8" title="1">{
                option.ConnWriteTimeout = max(DefaultTCPKeepAlive, option.Dialer.KeepAlive) * 10
        }</span>
        <span class="cov8" title="1">if option.BlockingPipeline == 0 </span><span class="cov8" title="1">{
                option.BlockingPipeline = DefaultBlockingPipeline
        }</span>
        <span class="cov8" title="1">if option.DisableAutoPipelining </span><span class="cov0" title="0">{
                option.AlwaysPipelining = false
        }</span>
        <span class="cov8" title="1">if option.ShuffleInit </span><span class="cov0" title="0">{
                util.Shuffle(len(option.InitAddress), func(i, j int) </span><span class="cov0" title="0">{
                        option.InitAddress[i], option.InitAddress[j] = option.InitAddress[j], option.InitAddress[i]
                }</span>)
        }
        <span class="cov8" title="1">if option.PipelineMultiplex &gt; MaxPipelineMultiplex </span><span class="cov8" title="1">{
                return nil, ErrWrongPipelineMultiplex
        }</span>
        <span class="cov8" title="1">if option.RetryDelay == nil </span><span class="cov8" title="1">{
                option.RetryDelay = defaultRetryDelayFn
        }</span>
        <span class="cov8" title="1">if option.Sentinel.MasterSet != "" </span><span class="cov0" title="0">{
                option.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)
                return newSentinelClient(&amp;option, makeConn, newRetryer(option.RetryDelay))
        }</span>
        <span class="cov8" title="1">if option.Standalone.EnableRedirect </span><span class="cov0" title="0">{
                option.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)
                return newStandaloneClient(&amp;option, makeConn, newRetryer(option.RetryDelay))
        }</span>
        <span class="cov8" title="1">if len(option.Standalone.ReplicaAddress) &gt; 0 </span><span class="cov8" title="1">{
                if option.SendToReplicas == nil </span><span class="cov8" title="1">{
                        return nil, ErrNoSendToReplicas
                }</span>
                <span class="cov8" title="1">option.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)
                return newStandaloneClient(&amp;option, makeConn, newRetryer(option.RetryDelay))</span>
        }
        <span class="cov0" title="0">if option.ForceSingleClient </span><span class="cov0" title="0">{
                option.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)
                return newSingleClient(&amp;option, nil, makeConn, newRetryer(option.RetryDelay))
        }</span>
        <span class="cov0" title="0">if client, err = newClusterClient(&amp;option, makeConn, newRetryer(option.RetryDelay)); err != nil </span><span class="cov0" title="0">{
                if client == (*clusterClient)(nil) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(option.InitAddress) == 1 &amp;&amp; (err.Error() == valkeyErrMsgCommandNotAllow || strings.Contains(strings.ToUpper(err.Error()), "CLUSTER")) </span><span class="cov0" title="0">{
                        option.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)
                        client, err = newSingleClient(&amp;option, client.(*clusterClient).single(), makeConn, newRetryer(option.RetryDelay))
                }</span> else<span class="cov0" title="0"> {
                        client.Close()
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return client, err</span>
}

func singleClientMultiplex(multiplex int) int <span class="cov8" title="1">{
        if multiplex == 0 </span><span class="cov8" title="1">{
                if multiplex = int(math.Log2(float64(runtime.GOMAXPROCS(0)))); multiplex &gt;= 2 </span><span class="cov8" title="1">{
                        multiplex = 2
                }</span>
        }
        <span class="cov8" title="1">if multiplex &lt; 0 </span><span class="cov0" title="0">{
                multiplex = 0
        }</span>
        <span class="cov8" title="1">return multiplex</span>
}

func makeConn(dst string, opt *ClientOption) conn <span class="cov8" title="1">{
        return makeMux(dst, opt, dial)
}</span>

func dial(ctx context.Context, dst string, opt *ClientOption) (conn net.Conn, err error) <span class="cov8" title="1">{
        if opt.DialCtxFn != nil </span><span class="cov0" title="0">{
                return opt.DialCtxFn(ctx, dst, &amp;opt.Dialer, opt.TLSConfig)
        }</span>
        <span class="cov8" title="1">if opt.DialFn != nil </span><span class="cov0" title="0">{
                return opt.DialFn(dst, &amp;opt.Dialer, opt.TLSConfig)
        }</span>
        <span class="cov8" title="1">if opt.TLSConfig != nil </span><span class="cov0" title="0">{
                dialer := tls.Dialer{NetDialer: &amp;opt.Dialer, Config: opt.TLSConfig}
                conn, err = dialer.DialContext(ctx, "tcp", dst)
        }</span> else<span class="cov8" title="1"> {
                conn, err = opt.Dialer.DialContext(ctx, "tcp", dst)
        }</span>
        <span class="cov8" title="1">return conn, err</span>
}

const valkeyErrMsgCommandNotAllow = "command is not allowed"

var (
        // errConnExpired means the wrong connection that ClientOption.ConnLifetime had passed since connecting
        errConnExpired = errors.New("connection is expired")
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
